<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>希尔的博客</title>
  
  <subtitle>兰之猗猗，扬扬其香。不采而佩，于兰何伤？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zshell.cc/"/>
  <updated>2019-01-13T08:09:48.935Z</updated>
  <id>http://zshell.cc/</id>
  
  <author>
    <name>zshellzhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“一个人”的社交</title>
    <link href="http://zshell.cc/2019/01/01/life-thought--%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%A4%BE%E4%BA%A4/"/>
    <id>http://zshell.cc/2019/01/01/life-thought--一个人的社交/</id>
    <published>2019-01-01T08:08:40.000Z</published>
    <updated>2019-01-13T08:09:48.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开年第一天，我想写篇文章纪念一下我与我的博客之间的故事。<br>这个博客，它为何而来？它正在表达什么？它将向何处去？这些问题的答案，于我而言，是认真而虔诚的。<br>社交，并非总是在固定时间维度下的空间活动。常言道，读一本书便是在与作者对话，无论是如雨果这样的文豪大家，还是如我一般渺小的普通作者，阅读他们的文字，即是倾听对方的声音，即是探入对方的心灵。这何尝不是另一种形式的社交呢？<br>这样的社交，虽不曾面对面把酒当歌，却能剥离所有的外在，坦诚相待；这样的社交，即使对方的肉身早已灰飞烟灭，却仍然能够无视时间的束缚，在精神层面上，实现纯粹的碰撞与交融。</p></blockquote><a id="more"></a><hr><h3 id="我为何选择博客"><a href="#我为何选择博客" class="headerlink" title="我为何选择博客"></a><strong>我为何选择博客</strong></h3><p>今天是 2019 年的第一天。站在此刻，往前看是曲折而难以忘怀的 2018，往后看是充满抉择、机遇与挑战的 2019。昨晚在我的微信朋友圈里，各式各样的人儿都晒出了自己的 2019 年度目标，也有少部分人自豪得展示着 2018 年的目标完成情况。我作为一名特殊的人类成员，当然也会有自己特殊的表达方式，比如现在正写着的这篇文章。</p><p>新加我微信的人总是好奇地问我：“你好像不发朋友圈动态，一条都没有哇？”其实这个问题我已经问过自己千百遍了，可以说这个博客的存在本身就是这个问题的答案。或许，我六年前的遭遇也在其中掺杂了一些似有似无的影响，但时至今日，经过不断的思考与经历，我已经完全明白自己到底在做什么，而不是被一些悲伤的情绪所左右。</p><p>朋友圈是人们社交的出入口，人们通过展示自己的生活片段与别人交流，互相了解，增进感情。同微博类似，当我们点开朋友圈下拉刷新，我们的视线将被各式各样的信息占有，有想看到的，也有不想看到的，统统进入我们的眼帘。这是一个被动的过程，我们事先并不能预测将获取谁的信息，这些全靠系统投喂给我们。</p><p>而我所做的，只是找回快被人们遗忘在从前的另一种表达方式：博客。与微博，朋友圈不同，访问博客是一个主动的过程，我们很确定我们在接受谁传达出来的信息，既然我们愿意进入他的博客，这本身就意味着对他的期待，意味着对他往日博文的肯定。而每次刷朋友圈，有时的确会收获一些惊喜与价值，但它来自于谁，来自于哪个时刻，都是不确定的事情。“朋友”们的动态此消彼长，只要信息的总量保持稳定，没有人会刻意关心谁的动态少了，而谁的动态又多了。久而久之，刷朋友圈变成了一种猎奇，一种感官刺激，真正的人际关系反而模糊了。</p><p>微博、朋友圈是为移动端设计的表达渠道，其特点是短小，简单，字数限制，换句话说可能便是浮于浅层，难以深入。这固然降低了使用者的门槛，圈揽了大量用户，但也导致信息生产的质量问题。于是，我们经常看到各种转发的公众号文章，这些公众号在一定程度上弥补了朋友圈信息的质量问题，但是公众号，本质上讲不就是另一种形式的博客吗？在微信的流量生态下，知识分子为了事业上取得更好得发展，不得不转换战场，以跟上目标读者的脚步。于我而言，博客并非我谋生的渠道，所以我并不需要适应移动互联网时代下的新环境。</p><p>像我这样另辟蹊径使用传统模式表达自我，其实还有另外一点好处。在没有屏蔽拉黑的假设前提下，我们发表的朋友圈动态会推送到每一位联系人的手机上。我无法预知自己即将发布的内容会不会受到大家的欢迎，我只知道如果有人不喜欢看到我的信息，我的动态也会被推送到他的手机上，接着他很有可能就会把我拉黑。反观写博客，我就不需要承受如此的心理压力，没有人知道我在思考什么，没有人知道我在感慨什么，除非你主动访问我的博客。另外，互联网是连接世界的，访问我的博客根本就不需要认识我，你喜欢便会驻留，不喜欢便会离开，于我而言没有任何区别。</p><h3 id="孑然而立的博客"><a href="#孑然而立的博客" class="headerlink" title="孑然而立的博客"></a><strong>孑然而立的博客</strong></h3><p>当然，我的博客是我内心深处的秘密，我从不轻易公开博客地址，这里是我肆意想象，恣情意淫的天地。而这博客维护了这么长时间，我能察觉到，唯一一名对我保持长期关注的访客，是 google 的爬虫引擎：在 google 上检索相关关键词便会出现我的博客文章。与之相对应的是，百度从来都没有“感知”到我的存在，当然这也在情理之中，我使用“敏感网站” github page 发布博客，使用境外的顶级域名，没做过 SEO，也不作 ICP 备案，政治正确的百度对此一定讳莫如深。</p><p>一般而言，人们总是倾向于表达并推广自我，以获得别人的接纳，满足被认同的心理需求，实现内心的价值归属。而我却不希望将我的博客曝光于世界之下，更不打算在微信朋友圈展现自己的面貌，这可能是属于我个人的审美倾向。在我的其它文章中，也会表达出类似的观念：我一直在追求的，是一种缺憾，一种惋叹，心花怒放，而黯然神伤，红杏含苞，却伏于墙隅，只待世人“蓦然回首，那人却在，灯火阑珊处。”</p><p>既然我已决定不轻易公开博客地址，百度也不打算帮我推广介绍，我自然就不用指望会有人关注我了。如此一说，我这个博客的意义，怕是离“社交”的定位有点远了，我对世界唯一打开的一扇门，在实质上却等效于是关闭的。在现代社交网络的世界里，离群索居的我，谁怜一片影，相失万重云？</p><p>皎皎明月，皓然当空，她的美令众人侧目，她的美引嘉赞无数；一颗寒星，孤悬天际，遗世乎凡宇间的热闹，独立于红尘中的来往。众人赏月之际，会不会有一位走心的少年，裹挟着探索与好奇之心，向深邃的夜空一瞥，令那株隐隐若现，那抹微乎缥缈，在其双眸之内留下属于自己的一粒像素？</p><p>其实，关于这一点，我自建站之初就已做好了心理准备。“兰之猗猗，扬扬其香。不采而佩，于兰何伤？”我节选韩愈《猗兰操》中的片段作为自己博客的副标题，影射自己的志向：就算没有人欣赏我，于我而言又有何可悲？只需做自己便好，哪怕世间万事万物都背对着我，我和我自己也永远面对着面！</p><p>好在，生活中有一样东西在万物中最为珍贵：希望。希望是一种可能性，就算发生的概率再低，只要不是零，它就配得上叫做希望。墨菲定律说，只要事情存在可能性，那么给足了时间，就总有它发生的一天。我在这里写博客不正是这样的一件事吗？看起来似乎已没什么通达之径指向我的世界，可实际上这个网站一直在与互联网保持着连接！谁又敢说将来的某一天，一定不会有人误打误撞在浏览器里输入了我的博客地址，踏进我为 ta 打开的这扇门呢？</p><h3 id="历史召唤的博客"><a href="#历史召唤的博客" class="headerlink" title="历史召唤的博客"></a><strong>历史召唤的博客</strong></h3><p>华夏民族的历史是一部苦难之作。落第、贬谪、离亲、亡国，令愤懑、忧郁、悲恸、疾首在文人骚客的心中冲撞回荡。而转身之念，挥斥方遒，激扬文字，脍炙人口的篇章顷然奔泄。文人本也萎靡柔弱，但在自己的文字面前，却显万丈长情。晋出陶渊明“问君何能尔？心远地自偏”，南现李煜“一江春水向东流”；唐成刘禹锡“斯是陋室，惟吾德馨”，宋就文天祥“留取丹心照汗青”。即便命运再残败不堪，即使世道再腐朽不治，一腔情潮，只要找着了文字，便拥有了寄托之处。何谓寄托？于古人言，那是将自己人生的价值追求全数倾注，以不朽的文字为载体，向世人宣告：“零落成泥碾作尘，只有香如故。”他们深信不疑，就算“众人皆醉我独醒”，冥冥之中，也定有真命知己，在未来注定的某一刻，为自己的文字潸然落泪。幸运的是，前辈们的菁华之作已悉数为后世所珍，并至此处为吾感念，遂谨以告慰各在天之灵。</p><p>于是从小学，中学，到大学，我们品读诗书，向灵魂深处注入了中华文化的基因。在文学大家的感召下，潜移默化之中，我亦对文字产生了一种深深的依恋，一种模仿前辈的冲动本能般在心中酝酿。一个人如果有千言万语无处诉说，文字将成为其最好的发泄口。就在这一瞬间，前辈的指引，内心的悸动，诉说的渴望，各种复杂的情愫糅杂在一块，一个属于我自己的博客诞生了。</p><p>今时不比往日，黯淡了刀光剑影，远去了鼓角争鸣。和平时代的我，在互联网的熏陶之下，没有了壮士断腕的悲烈，多出来的则是宁静的思考，婉转的歌啼，以及，细腻的想象。我想象着，一位读者，于不经意之间闯进了这片田地，柔和的屏幕前，ta 规律得眨着眼儿，一行一行在文字间扫动、跳跃，时而停留在某一段落反复咀嚼，时而又蹙眉思考，有着共鸣之音，亦有着质疑之声；我想象着，在时间的某个角落，历史的必然性教我在这里结识朋友，遇见知己，有没有可能收获爱情呢？</p><p>我愿意等着那个 ta。在那一天到来之前，每一篇文章，都将是庄严的仪式，都将是虔诚的呼唤。一个人能做的事情实在有限，然而一个人能做的事情有时却可以超越时间的界限。“一个人”的社交，其实从来都不是一个人，而是你，我，以及历史星空中的点点繁星，共同筑起的，珍贵的情感纽带，深切的情感寄托。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开年第一天，我想写篇文章纪念一下我与我的博客之间的故事。&lt;br&gt;这个博客，它为何而来？它正在表达什么？它将向何处去？这些问题的答案，于我而言，是认真而虔诚的。&lt;br&gt;社交，并非总是在固定时间维度下的空间活动。常言道，读一本书便是在与作者对话，无论是如雨果这样的文豪大家，还是如我一般渺小的普通作者，阅读他们的文字，即是倾听对方的声音，即是探入对方的心灵。这何尝不是另一种形式的社交呢？&lt;br&gt;这样的社交，虽不曾面对面把酒当歌，却能剥离所有的外在，坦诚相待；这样的社交，即使对方的肉身早已灰飞烟灭，却仍然能够无视时间的束缚，在精神层面上，实现纯粹的碰撞与交融。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
      <category term="thought" scheme="http://zshell.cc/categories/life/thought/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>情感安全绳</title>
    <link href="http://zshell.cc/2018/12/02/life-thought--%E6%83%85%E6%84%9F%E5%AE%89%E5%85%A8%E7%BB%B3/"/>
    <id>http://zshell.cc/2018/12/02/life-thought--情感安全绳/</id>
    <published>2018-12-02T08:21:12.000Z</published>
    <updated>2019-01-13T08:35:10.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近我的思路有一点悲观，在大量思考着那些 “最坏的打算”。可能是宏观形势所迫吧，在经济周期末期，中美对弈的大背景下，保值，落袋，避险等逐渐走向了聚光灯下，这样的外部语境，再结合我个人经历的内部语境，我心中逐渐酝酿出“情感安全绳”的概念来。<br>如果要用一个词语概括一下它的含义，我想应该是：“对冲”。没错，我觉得非常恰当，就是这两个字。</p></blockquote><a id="more"></a><hr><h3 id="安全与保险"><a href="#安全与保险" class="headerlink" title="安全与保险"></a><strong>安全与保险</strong></h3><p>风筝因为有了线，我们才敢放之于天空翱翔；车儿因为有了刹，我们才敢驾驶其于路面奔驰；</p><p>蹦极时我们并不会真正感到害怕，因为身上有一根绳在拉着；跳伞时我们也不会感到恐慌，因为肩上的装备将为自己撑起一个有力的面；</p><p>断了线的风筝将随风远去，最终坠落在无名之地；坏了刹的车儿将失去控制，最终车毁人亡；</p><p>没有了安全绳或者降落伞的保护，大家定然不敢从极高之处纵身一跃，因为那意味着死亡；</p><p>当我们在渴望一件事情的同时，却同时需要与我们的渴望相反的力量，只有接受这种力量的制约与归束，我们才能有效得控制住自己，才能在追求的道路上不断得持久得走下去。我想这个道理适用于生活中的很多场景。</p><p>偶然之间，我开始思考这个规则是否能够同样迁移到情感关系中去：当我们在努力追求幸福，当我们在认真经营感情时，如果突然遭遇不测，在我们即将坠入旋涡无法自拔之刻，可不可以有一根绳子出现在手边，将我们从深渊中拉上岸？</p><p>我想，在感情上受过伤的人或许非常渴望能拥有这样一根绳子：我们都不希望将痛苦重新复制一次，但却也十分渴望爱情，渴望真正遇到一个值得相伴一生的人，全心投入，与其共同结出丰收的硕果。如果能有这样一根绳子，无异于为爱情上了一份保险，令幸福多了一份保障，使我们得以敞开心扉，大胆得追求，不必担心，也无需犹豫。</p><p>保险的意义，不就是以一个微小而可控的代价，为我们这充满各种不确定的生活，换来一份安定与缓冲吗？我相信，乘坐飞机，买一份航空意外险，没有人会认为你是怕死鬼，认为你在诅咒飞机坠亡；健康的你，为家人买一份重疾险，并不会因此遭来亲人的不满，认为你在期望他们患病倒下。这些不幸的事情，没有人希望它们发生，但我们又没有绝对的实力，完全阻止它们可能的存在。如果没有准备，当噩耗真正传来时，我们的生活将被无情地摧毁，谁也无法回避。</p><p>为生命，为健康，为财富附上保障，已经成为了我们的共识。但是如果被保障的对象是一段感情，很多人在心态上却全然无法接受，一个典型的例子就是：婚前财产公证，这成为很多情侣踏入婚姻殿堂前最后一块羁绊。“难道你以为我和你在一起是为了你的钱吗？”这是一个很容易令对方哑口无言的问题：你确实感觉的到，两人的感情很好，你们是因为爱而走到了一起，钱算什么？所以你也开始怀疑，难道真的有必要去作婚前财产公证吗？这岂不是对这段婚姻的侮辱？可是你转念又想，感情好的是现在的你们，但不一定是将来的你们，人是可以变的。“所以你根本就对我们的爱情没有信心，那我们又何必要结婚呢？”是的，谁也不希望大家婚后不幸福，只是那么多活生生的悲剧摆在面前，你又有何特别之处，敢说这种事情绝不可能降临在你们身上呢？</p><p>可是，如果没在感情上经历过挫折，捧着一尊无暇的爱情理想，将很难接受这种事情，婚前财产公证，有时竟成为一段缘分的死亡陷阱。不过，我接下来所设想的“感情保险”，与有形的事物没有任何关系，它可以是只存在于自己心里的秘密，所以相比于婚前财产公证，“风险”要低很多。</p><h3 id="情感安全绳"><a href="#情感安全绳" class="headerlink" title="情感安全绳"></a><strong>情感安全绳</strong></h3><p>我是一个近视度数比较高的人，左眼五百，右眼三百。不过，在前往世纪佳缘与约好的女孩见面时，我从来不带眼镜，这样我将只能看见女孩模糊的面庞，而看不清她的真实容貌。我故意这么做，因为我不想因为相貌因素而扰乱我对女孩的判断，在模糊的视线下，我可以更加集中精神与她交流，以获取我真正想了解的信息。</p><p>于是我遇到了现在这位女孩，从性格、职业、爱好等来看，感觉都挺合适，我们加了微信。在进入她的微信朋友圈之前，我对她的映像可以说是相当好的，但是等我看到她发的朋友圈动态，等到她清晰的照片毫无遮拦地进入我的视线，我产生了一点小小的失落感。</p><p>没错，我之所以不带眼镜，就是为了应对这种情况，为了避免偏见，避免以貌取人。虽然道理我们都明白，但是内心却依旧很“诚实”，所以我才使用这种强制的方式来促使我“服从”道理。现在无论她是何等容貌，我都必须承认，抛开所有外在的东西，她确实是个不错的女孩。或者从另一个角度想，如果我是一个盲人，那我现在一定会发自内心得对她感到满意（当然，如果我是盲人，她可能就不愿意同我交往了）。</p><p>这个时候，我须要静下心来思考，我想追求的，到底是怎样的另一半？</p><p>显然不是为了一个外在的艳丽。人总有老去的时候，不消二十年，我们都将褪去当前的年轻模样，剩下的是见识，视野，灵魂和思想。人生七八十载，从情窦初开到步入中年，属于外表的荷尔蒙时代终究是短暂的。所以，摘下眼镜，当视线朦胧的那一刻，心里面反而更加清晰，更加坚定了：外貌的缺憾，无足一顾，内心的契合，才是真的可贵。</p><p>想要遇见完美无缺的人实在是太难，更何况在完美无缺者的眼中，我们却反而是一个各种缺点的集成者。所以，欣赏对方的优点，同时也需要包容对方的缺点，求同而存异，抓住大美而放下小丑，唯有如此，才能与人携手向时间纵深处前行。当恋人的缺点攥在自己手里时，愚钝的人控制不住得将其放大，满腹牢骚，抱怨连天；睿智的人则理智对待，甚至循循善诱，将对方的不足加以引导，领向另一番别致的天地，化腐朽为神奇。</p><p>而我想说的是，攥在自己手里的，不仅仅是恋人的缺点，也是为自己订制的一份“保险”，它无形却有踪，它的存在与否完全取决于自己，它是一种平衡，我将其定义为：情感安全绳，一条由自我把控，可以在心中变魔术的绳。在感情上升期以及感情稳定期，恋人的缺点是唯美风景中的一层雾霭，当我们用手轻轻拨开，秀色风光尽收眼底；当感情发生变故，遭遇抛弃或打击之时，这样的缺点就化身为结实稳固的绳，曾经我们包容它是因为爱，而现在爱已落空，它便成为我们宽慰自我，放下感情的手段，抓紧它，向上爬，我们得以顺利得从跌落的歧路中重回正道。</p><p>“我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病，它真讨厌。只有一点好，爱你。”可是，如果没有了最后那一点好，就如王小波前面一句总结的一般：它真讨厌！讨厌到我需要立刻远离你，接着长长地舒一口气。</p><p>这样的描述或许夸张了些，但这并不是在刻意黑化前任，而是当心态跌入了极左之境，顺势以一股反向朝右的力量将其拉向平衡。这些话当然没有必要通过外在的途径宣泄出来，就让心中的摆钟自己去校准吧。当内心重新回归，若是没有背叛和伤害，就将这段关系当作美好的回忆珍藏在心中吧；若是因为不懂得珍惜而辜负了真心，这样的人也必定是无法配得上为之倾注心血的。总之无论如何，要相信，下一次，我们将遇见更好的人。</p><p>再回到我自己身上，尽管曾经心有余悸，六年不敢再爱，然今非昔比，我已在心里为自己编织好了一根绳，从而可以大胆放手迎接任何可能性。我会做一个睿智的人，当彼此互相拥有时，就尽心用爱去包容，若失去她，则双手握紧这情感的安全绳。</p><h3 id="另一种形式"><a href="#另一种形式" class="headerlink" title="另一种形式"></a><strong>另一种形式</strong></h3><p>作为一个在南京走完自己快乐学生时代的人，如今身在杭州，当如“别是一番滋味在心头”：我刚来杭之时，还有几位北京认识的老同事在杭州。不消半年，各位皆已离杭回北，只留我一人独守“空城”，孑然一身。另外，在我毕业之前，我最好的朋友，熟悉的同学，关系不错的老师，以及我的亲戚，基本都在南京发展。在我的人脉关系结构中，杭州是一座孤岛，而我却身陷其中。正因此，独处的时间多了，我便沉浸于思考之中，并不厌其烦得堆砌着这些个文字。也正因此，我开始寻觅被我搁置已久的爱情。</p><p>我何尝不想回南京？互联网巨头已经开始着力布局南京，金陵古城已然不是当年的互联网沙漠，这些变化就在这短短的一两年内发生了。想去年我会选择杭州，是因为时机不成熟，在南京没有找到合适我的职位。今非昔比，我现在完全可以在南京找到理想的职位，而不会比杭州逊色。</p><p>于是我和自己约定了一份协议：截至明年六月，在我来杭满一周年之际，如果仍未找到值得相伴一生的人，我就离开杭州，打道回宁。然而只要在此期限之前遇见了合适的人并确定了彼此，除非关系破裂，否则不考虑回南京。</p><p>这是一个平衡代价与收益的博弈。首先，我肯定是需要一个 deadline 的，绝不可能无止境得等待与寻找，这样做的机会成本无法控制。一年对于我来说是一个关键的时间：从个人职业发展的角度看，互联网行业，在一个公司任职一年时间，虽不算长，但也不能说短，这是行业特征，如果选择明年年中离职，我的简历不会因此而给下一位东家的 HR 留下不好的印象；从个人情感的角度看，如果经历了一年仍未找到那个她，确实可以考虑换一下大环境，毕竟继续当前状态下的边际效益已经大大降低了。不过，一旦找到了真正合适的人，我绝对不能因为我的地域情结而错过她：我在杭州已经苦苦不得缘分而如此挣扎，我又有何等胆量敢说自己回南京之后一定会比杭州更加顺利呢？机会难得，稍纵即逝，一旦错过，或许后悔一生。</p><p>更进一步说，南京就是我最后的阵地了，无论是现实生活中，还是我的内心里。什么叫最后的阵地？就是坚守到最后一兵一卒，直至全部阵亡，全军覆没，因为再往后，根本退无可退了。此时的我对南京依然充满了无限的向往（怀念），换句话说这叫生活的希望，无论我在杭州有多么不顺心不如意，只要想起南京，我就依然对未来保留着信心，假想着自己衣锦还乡，与朋友重逢相聚的场面。可一旦真的回去了，一个大大的陷阱或许就横亘在我面前，就像很多美好的事物，在得到其之前，总是令人怦然心动，而待到真正拥有时，却又失望满盈。我从北京来到杭州后的经历，不就是一个活生生的例证吗？我从北京来到杭州尚且有南京这一条退路，倘若我再从杭州回到南京，就是孤注一掷，最后一搏了，赌输了，就是命了。如此说来，有些话只有烂在肚子里才有它的意义，有些憧憬只有不去实现才能体现它的价值。</p><p>如此一看，这般的憧憬，这般的希望，这般的怀念，还是节约着使用为妙。不到万不得已，不到大限将至，不可随意挥霍。当在某些极端事件的冲击下，比如为情所伤，悲楚欲绝之际，我们才有充分的理由祭出这一手底牌。《乱世佳人》的女主角，在小说结尾男主角执意放下她抽身而去后，并没有绝望得了此一生，而是满怀希望得鼓励自己：“我要回塔拉庄园，那里才是我的家，明天又是新的一天了。”所以说，当我们心中有这么一片土地，这么一座城市，它是否也可以类似地，成为我们心中的情感安全绳？它曾经带给我们快乐，它构成了我们美好的青春回忆，遭受情感挫折的我们，如果有机会回去那里重整旗鼓，兴许会感慨：另外一座城市的她像是鱼，而这座城市就是熊掌，二者不可得兼，如今放下了鱼，才有机会重新拾起熊掌。</p><p>这样的情结是否可以算得上是对憧憬价值的兑现？不管其最终是否被证实为一个陷阱，真到了那一刻，我想这一着棋当值得一走吧。相较于失恋的痛苦，那些北漂，沪漂，深漂，杭漂的人儿，改变一下环境真如举手之劳：不过是举起手抓住身旁的情感安全绳而已，又何苦在深坳中自寻烦恼呢？</p><p>当然话说回来，针对我目前的情况，我必将严格执行协议的内容，理智需要排在第一位，不可以被情绪所左右。半年后我究竟会不会回到南京，拭目以待吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近我的思路有一点悲观，在大量思考着那些 “最坏的打算”。可能是宏观形势所迫吧，在经济周期末期，中美对弈的大背景下，保值，落袋，避险等逐渐走向了聚光灯下，这样的外部语境，再结合我个人经历的内部语境，我心中逐渐酝酿出“情感安全绳”的概念来。&lt;br&gt;如果要用一个词语概括一下它的含义，我想应该是：“对冲”。没错，我觉得非常恰当，就是这两个字。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
      <category term="thought" scheme="http://zshell.cc/categories/life/thought/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="情感" scheme="http://zshell.cc/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>孩之生日，母之难日</title>
    <link href="http://zshell.cc/2018/11/19/life-thought--%E5%AD%A9%E4%B9%8B%E7%94%9F%E6%97%A5%EF%BC%8C%E6%AF%8D%E4%B9%8B%E9%9A%BE%E6%97%A5/"/>
    <id>http://zshell.cc/2018/11/19/life-thought--孩之生日，母之难日/</id>
    <published>2018-11-19T13:40:56.000Z</published>
    <updated>2019-01-13T08:07:50.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生日，纪念着生命的诞生，度量着生命的年岁。<br>生日是快乐的，蛋糕前许愿的人儿又长大了一岁；生日是严肃的，静坐闭目冥想中反思着又一年的收获；生日是痛苦的，产房中撕裂的叫喊化作了人类文明延续的沉重代价。</p></blockquote><a id="more"></a><h3 id="往日之态"><a href="#往日之态" class="headerlink" title="往日之态"></a><strong>往日之态</strong></h3><p>从早到晚，我今日收到生日祝福的顺序如下：妈妈，招商银行，中国联通，东吴证券，爸爸，支付宝，google。</p><p>我已经有十五年没有为一年中这“特殊”的日子在心中产生丝毫的波澜了，上一次高兴得过生日还是 2003 年我十岁的时候。后继的时日里我如一尊入定的石佛，不喜不悲，平和而淡定得踏过了十五座春秋，似一本书将十五页纸轻轻翻过。这几年在步入社会之后，我稍稍令其变得与其他日子有些不同：每当这一天来临，我便以闭目冥想的方式反思自己走过的又一年，而今天，下班后回到家，我正在写着这篇文章。</p><p>早几年前 QQ 还没有销声匿迹的时候，我记得当一个人的生日临近了，QQ 便会向这个人的所有联系人推送，告诉大家这位朋友的生日快到了，快去送上祝福吧。可惜了一旦填写了生日，QQ 就不允许取消设置，只能修改。为了避免 QQ 引导别人向我送祝福，我只好在我生日前差不多一个月的时候，把我填写的出生日期给改到半年后去，等到我生日过了差不多一个月，再给它改回来，这样我就成功令大家“遗忘”了我。此中乐趣，不足为外人道也。</p><p>我曾仔细得思考过我这种奇怪心理的动机：说白了，我之所以会如此平静，是因为我不觉得，在这一天之前，与这一天之后，我的生活会有什么变化。该付出的努力一丝不能松懈，该承受的压力一毫不会减少，每一天都在迎接新的生活挑战。如果这一天的心情激昂而上，第二天难免又回落至常态，到头来只是徒添怅惘。</p><p>我发现，与我这种心境类似，却又形成鲜明对比的是处于耄耋之年的老人：他们也不需要在乎生日了，来自晚辈长寿云云的祝福，于当事人不过虚言罢了。年岁至此，于夕阳之下拄杖前行，每一天都可能是最后的绝唱，只有当清晨沐浴在新的日光之下，才是从心底生发出的由衷感谢。</p><p>在我的微信朋友圈里，时不时得有人晒出自己生日聚会上的美照，幸福的表情洋溢在脸上。对于她们来说，那应该是发自内心的快乐吧。想必大部分人都不会如我一般，竭尽全力得让自己消失于众人的视野之下，竭尽全力得将自己的心境保持为长久的低谷，深涧的细流。每个人的认识，期待，追求都不一样，我们需要尊重自己的感受，更要尊重他人的感受，每个人都有属于自己的仪式，去迎接自己生命中的特殊之刻。所以，如果今后有一个人可以和我一起生活，在她的生日那天，我一定会用心策划，给她惊喜，满足她的期待，而在我生日的那天，我只希望能和她如平日里一样，自然而充实得度过这一天。</p><h3 id="新的理解"><a href="#新的理解" class="headerlink" title="新的理解"></a><strong>新的理解</strong></h3><p>是的，纪念生日，每个人的方式千姿百态。而在这万态之间，有一种最为特殊，自古以来穿越了整个人类文明：我们向世界问候的第一声啼哭。生命在其中酝酿，母亲在倚头微笑，怀中的婴儿可知这微笑背后的辛酸泪？</p><p>2018 年 11 月 9 日，刘强东的妹妹刘强茹，在临床生产时因羊水栓塞不幸去世。她是一个高龄产妇，43 岁怀孕，这或许是其发生意外最致命的因素之一，不过在此之上，还意味着另一个事实：即便再有钱，在生育这件事上，也和普通人面临着同样的危险，同样也有医生回天乏术的时候。</p><p>我们每个人活着来到这个世界，并非理所当然，这是我们的母亲冒着生命危险换来的。在几百年前，黑暗的中世纪，当女孩得知自己怀孕，要做的第一件事情是：立遗嘱。即便医学技术高度发达的今天，我们的分娩死亡率也没有低到令大家觉得可以忽略不计。就算母子平安无恙，但分娩的痛苦，现代的女性同几百年前的女性也没有什么差异。我的一位同事，其夫人几乎被折磨了两天后才终于分娩成功，他激动得说道：要爱妻子一辈子，恨这个小男人一万年！</p><p>故曰：孩之生日，母之难日。如果我们正在为自己庆生，又或者我们正在闭目回顾，我们都不能够忘记，很久之前的今天，我们伟大的母亲，冒着生命的危险，熬过了巨大的痛苦，诞下我们，并赐予了我们生命。而妈妈又总是第一个为我们送上生日祝福的人，不是因为她们忘不了当年的痛苦，想让我们也一同记住，而是因为她们看到自己的孩子又长大了一岁而真心感到高兴，这就是母爱！</p><p>感谢妈妈！</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://zhidao.baidu.com/daily/view?id=145625" target="_blank" rel="noopener">“羊水栓塞”，何以如此凶险？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生日，纪念着生命的诞生，度量着生命的年岁。&lt;br&gt;生日是快乐的，蛋糕前许愿的人儿又长大了一岁；生日是严肃的，静坐闭目冥想中反思着又一年的收获；生日是痛苦的，产房中撕裂的叫喊化作了人类文明延续的沉重代价。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
      <category term="thought" scheme="http://zshell.cc/categories/life/thought/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>一位爱情初级玩家的偏见式独白</title>
    <link href="http://zshell.cc/2018/11/11/life-thought--%E4%B8%80%E4%BD%8D%E7%88%B1%E6%83%85%E5%88%9D%E7%BA%A7%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%81%8F%E8%A7%81%E5%BC%8F%E7%8B%AC%E7%99%BD/"/>
    <id>http://zshell.cc/2018/11/11/life-thought--一位爱情初级玩家的偏见式独白/</id>
    <published>2018-11-11T06:48:44.000Z</published>
    <updated>2019-01-13T07:19:09.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.10.27 ~ 2018.11.05，一周多一点儿的时间，却如同历经了一岁枯荣。<br>在爱情这场人生游戏里，我刚迈出第一步，却又将脚缩了回来。技能的缺失，经验的空白，让我这么一位初来乍到者感到了前所未有的迷茫。<br>但我没有选择，逝者如斯夫，犹豫不前将导向不可逆转的败局。我只能不断摸索，凭借着本能的反应，以及单身这么多年来建立的固有认知，以自己 “独特” 的方式闯入 “这场游戏的主战场”，开启 “战斗 - 挫败 - 总结 - 提升” 的玩家晋级之路。</p></blockquote><a id="more"></a><hr><h3 id="释然"><a href="#释然" class="headerlink" title="释然"></a><strong>释然</strong></h3><p>感谢这一周的时间，有你从我的生活中走过。</p><p>这一周仿佛很漫长，有紧张和期待，有兴奋和快乐，也有焦虑，以及，最后的惆怅，如同上帝赠予我的一本小小恋爱指导手册。酸甜苦辣，别样滋味，悉数为我品尝，不啻一段动人的爱情故事。</p><p>说实话，我竟真有种恋爱的感觉，这感觉在我身体里如小鹿乱撞，令我心神不宁，令我寤寐无眠。现在结束了，一切终归平静，多情应笑我，早生华发。</p><p>人海茫茫，一缘难求。相遇如同分手埋下的伏笔，甜蜜似是哀伤垂下的鱼钩。生活无常，聚散流沙，前路漫漫，蹀躞万里。但我相信，只要真诚不减，挫折不过谈笑间的樯橹；只要信念不折，困难只是霓虹中的蜃楼。</p><p>生活暂告一段落，而来路方长。愿你我都能易装换马，再度出发！</p><h3 id="回味"><a href="#回味" class="headerlink" title="回味"></a><strong>回味</strong></h3><p>失去女朋友是什么感受？就是现在傍晚时分，秋雨微停，空气清爽，男男女女走出办公楼，享受下班后的惬意，而我却再也不能联系她，与她共同分享这等美妙的时光。</p><p>我为何会有失恋般的惆怅？六年前，我的第一段感情持续了两个月。之后的哀思如一江春水滚滚东逝，尽管岁月的洗刷冲淡了愁情，但时至我来到杭州，依旧细若游丝，挥斩不断。而这一次，仅仅是一周之缘，她并不算我的女朋友，我们甚至也只有过一面之谋，当是萍水相逢而已，可固执的我还是没能摆脱多愁善感的毛病，身陷过往的覆辙之中。</p><p>在我的理解里，一段关系中的男女，只有双方都尽心尽力，才能将关系维系下去。倘若一方走了心，很快便能被另一方所察觉。有人曾对我说，初次见面是互换一个初始印象，并决定是否可以尝试交往；第二次见面应该察言观色，考察互相的修养与品味；第三次见面可以深入的交流，探究对方的理想与追求。三次见面后如果互相都感觉不错，双方就可以专注得投入到一段感情中了。可是，我认为感情并不是个有章可循的手艺活，每个人的性格迥异，所能接受的交往方式也千差万别，固化的内容未免教条。比如我就倾向于在第一次见面交流中就去了解最关键的基本面，如果我觉得没有问题，值得交往，我就会全力投入其中。琐碎的细节与瑕疵，只要没有让我感到足以影响我对她大方向上的判断，我都不会介意，求同存异是我一向的态度。</p><p>作为一个一旦点燃，便热情如火的我，所对面的交往对象可能是一个腼腆内向的女孩，但这不是什么问题，我并不期望对方一定要主动，我只希望我的主动能换来对方真诚的回应，我明白尽心尽力并不是具体到行为上的刻意要求，而是每个不同的人，在自身的性格与特质下从内心不由自主生发出的情感与反应，其是否尽心尽力，关系中的另一方是可以清晰感受到的。我会与她分享乐趣，分担烦恼，探讨真善美，感悟人生，她快乐我便快乐，她难过我也难过。总之，她会完全融入到我的生活之中，我的生活从此不可能存在没考虑到她的地方。</p><p>既然每个人所能接受的交往方式不可一概而论，那么必然会有人无法接受我这种火焰般的热情。保守的女孩将本能得排斥我，扑灭我刚刚对她升腾起的热情。没关系，感情本就是双向的，轻轻得退出就好。不过，我绝不会因为女孩的保守性格而改变我追求她的方式，事实上，我也改变不了，天性使然。能自然而然走到一起才算是缘分，没有缘分而强求缘分，何苦这般逼迫自己，扭曲了个性，到头来还不是画虎类犬，落得一个分手的狼狈结局。</p><p>固然，第一次的见面无法面面俱到，就算开始互相吸引，也总可能有那么一天，我们发现对方其实不是自己想找的那个人。失望过后，就要面对如何退出的问题。我其实直到现在也不确定，从上周五之后，她几乎就是突然地，不再认真得回复我的微信消息，这是否就是她寻求结束关系的方式，只是她不肯由她那一边主动把话挑明，她希望我能明白她的意思并好自为之？反正从那之后，我便陷入了莫名的焦虑之中，寝食难安。我的耐心被一点一点消磨，直到我主动提出结束关系前的那一刹，彻底化为乌有。</p><p>折好的纸飞机刚一掷出便栽倒在地；睁开眼的小鹿刚一迈步就失去重心；醉人的烟花刚一绽放就殒身天地；剔透的雪花刚一落地就遁于无形。我不安地发现，一对恋人的未来之路，竟是荆棘遍布：生活爱好，生活习惯，消费观，房子，车子，彩礼，婚礼，生育，教育，养儿，养老······每一关背后都安置着致命的陷阱。两个人之间的分歧就如同枝枝桠桠的树木，每一处分叉，都是一次考验，每一处分叉，都可以是分手的理由。我曾经历过的两段关系，无一不是早早夭折，上帝似乎在看我笑话，看我这存在先天缺陷的性格，如何演绎一段段滑稽的情感闹剧。要知道，每一关考验都艰难险阻，然在任何一关失足，都意味着前面闯过的关卡都前功尽弃，只能从头再来。</p><p>我现今的状态，大抵还徘徊在第一关：沟通，因为我的前两段经历，应该都没有通过这一关。第一段感情，在对方提出分手之前，我甚至都没有意识到问题出在哪里，最后还是对方隐约为我指出了一些方向。第二段经历，也就是这一次，我有了沟通的意识，但是由于自己的性格原因，最终还是酿成了遗憾。在发现微信渠道受阻的情况下，我尝试着给她打电话，没有料到电话对面传来的声音却是别样的动人，别样的真诚，让我不敢相信这和微信里的她是同一个人。果然，挂掉电话，再次回到微信中，她还是和原来一样冷落我，这大概就是理想与现实的距离吧，我最终选择了放弃。女孩的心思难以揣度，像孩童吹起的泡沫，远观无法窥见其细腻的纹理，近看又在亲昵的触碰下乍然破裂。当遭遇无法解释的行为，不着边际的猜疑开始在我心中作祟：就像上面小节中所描述的那样，我至今都无从得知她在微信里疏远我的原因，莫非是她真的很忙？莫非是信号不好？莫非她正经历每个月必定来拜访的烦恼？不猜了不猜了，恐怕误会本身都已经被我误会了。</p><p>只能说，这第一关沟通，是后续所有关卡的基础，没有沟通就无法化解矛盾，没有沟通两个人就很容易走向不同的分叉，越走越远，最后形同陌路。这段关系过后，我突然变得能接受打电话这种沟通方式了，我大概想通了，微信与电话，无非是形式的区别，不是战略与战术的关系。只要电话里能谈的来，终归是有机会拉近彼此的距离的，我必须得接受这种方式，两段关系的失败结局已经给了我足够的警示。下一段缘分的到来，我希望能真正把握好，闯过第一关，并有机会接受后续更多关卡的挑战。</p><p>但我内心还是有有所不解，一段关系中，男孩作为相对主动的一方，女孩作为相对被动的一方，我去追女孩子，我尽量使用女孩乐于接受的方式去接触她，这无可厚非。但是，如果女孩对男孩真的有好感，并渴望与他交往，难道不应该考虑一下男孩的感受？你说你对我的印象还不错，可是你如此冰冷得回应我发给你的微信消息，就算我对你爱的深沉，也无可避免被你的冷漠所伤害。我不相信一个还对我有好感的女孩子会作出这般无情的事情，所以我只能选择退出，否则每一天对我来说都是煎熬。</p><p>再继续往更深处回味，我发现了更多之前未曾察觉的事情。我把自己置身于一个假设性的场景之中：如果她没有如此良好的家境，如果她在杭州没有房子，然后把我们这一周的经历回放一遍，我能坚持到第几天？这真是一个毒辣的问题，令我突然意识到我内心的潜意识究竟在渴望什么。结论很明显：我大概在上周三，上周四的时候，就会修正我对她大方向上的判断，然后主动提出结束交往。甚至还可能更糟糕，我们第一次见面交流后，我就不会向她要来联系方式，这段关系根本没机会开始。</p><p>人是如此好吃懒做的生物。若不提及女孩的家世，如果她在杭州没房，我大概是非常笃定，自己将通过事业上的提升，通过自身的努力，自力更生，安居乐业。但是你突然告诉我有这么一条捷径可以走，我就这么着了魔，就这么满怀期待得与她开始交往。我自己在心中描绘出了一个美好的她，仿佛我们志趣相投，我们互相欣赏。但事实终归是事实，我们没法欣赏各自的兴趣爱好，我们交流话题的范围变得越来越狭窄，可我还在这里苦苦支撑，不甘放弃，是什么原因在背后指使我愿不放手，我现在算是恍然大悟了。而对于她，就没有这些无端的干扰，因为优越的条件本就是属于她自己的，我不过是一个普通的男孩，如果已经没有了共同语言，对我的兴趣自然就结束了。只是她没那么决绝，留下我一个人又挣扎了几天，最终无力地熄灭。</p><p>所以说，物质条件总是以一种不经意的方式，扰乱人们正常的感情交往，它看不见却很强大，强大到令人身不由己，甚至无法自拔。我很庆幸，我及时抽身出来了，或许是因为我不够 “坚定”，没有那种不撞南墙不回头的 “精神”？我觉得，大概是我还相信自己的经济实力，即便没有捷径可走，脚踏实地的努力也不算遥远。而想想那些嫁入豪门的女孩们，其中不乏终日以泪洗面者，但她们没有能力，也没有勇气对生活说不。</p><p>当我发现我难于放手的根本原因后，我感觉浑身轻松了许多。是的，终究我还是要靠自己的本事吃饭，其他的幻想都不要有。</p><h3 id="深夜复盘"><a href="#深夜复盘" class="headerlink" title="深夜复盘"></a><strong>深夜复盘</strong></h3><p>秋雨绵延，辗转难眠。虽然之前已悟出些许道理，但是，我感觉这一周的伤心遭遇，还是有些细节没有被正视，前因后果，不明不白。我怕以后重蹈今日的覆辙，故挑灯伏案，借着夜的透彻与深邃，欲将其和盘托出，重新审视一番。</p><p><strong>星期六</strong><br>下午我们第一次见面，相谈盛欢，我们交流了各自的一些状况，聊到了各自的生活乐趣，比如喜欢的电影之类。我向她简述了我对艺术的追求，以及我对于跨领域跨学科综合涉猎的推崇，等等。末了，我询问了她对于我这些生活爱好，人生观念的看法，她笑着告诉我，她觉得我很优秀。这是向我抛出了橄榄枝，我有些兴奋，感觉新生活就要来临了！</p><p>可是我被兴奋冲昏了头脑，竟然忘了反过来问一问她的生活爱好，以及一些追求，态度之类的问题。至此，我对她性格爱好的了解仅限于见面前提前了解到的：她属于文静型的女孩，喜欢旅游。</p><p>这个草率的开头，似乎为一周后的结局埋下了伏笔。</p><p><strong>星期日</strong><br>早晨九点醒来，我赶忙在微信上向其问好，并配上可爱的表情。心里想着以后要早点起床，不能等到她都起床好半天了我才和她打招呼。她以同样可爱的表情回应我的问好，这真是一个美好的开端。</p><p>白天她要参加一个专业培训，我不再打扰她。晚上等她下课了，我给她打了一个电话，我们聊了一个半小时，谈天说地，非常愉快。在电话中，我不加掩饰得表达了昨日与她见面的喜悦之情，以及对能够与她交往的期待。她似乎是半开玩笑得回复我：“我感觉你说的好像有一点点······ 哈哈！” 我知道这当然不是什么表白，所以没多想，自然也就没从她的话中读出其他的信号：她其实是一个十分保守的女孩，直到经历了后续的事情，我才回味了过来。</p><p><strong>星期一</strong><br>开始要上班了，我早早地起床向其问好，并试探性得问她，应该不会对我每天早上的问好感到厌烦吧？她笑着回答说不会。同时，我和她协商，工作的时候我们就专注得工作，等晚上下班了再尽情聊天，这些我们都非常愉快得达成共识了。</p><p>等晚上我们都下班后，再次进入了两个人的聊天世界中。我们聊到了李咏的去世，聊到了他最后的遗言：“没有遗憾，只有不舍”。就着这些话题，我们探讨了爱情观，家庭观，事业观等等。我感觉我说的比较多，真的是有感而发，她也跟随着我的节奏，就其中的一些内容表达自己的看法，这样的聊天节奏与聊天氛围真的让人满意。</p><p>这个晚上，我突然在思考一件事：我是一个文字爱好者，有时甚至无悔于花费我全部的节假日时间，只为倾吐内心的感慨。不久之前的国庆节，我就几乎使用了七天之间的全部空隙，完成了我最近六年来心路历程的总结，只求探究一个真实的自我。我在想，我要不要把这篇文章给她看一下，毕竟这是我最真诚的情感抒发，尽管文章里提及了前几年我生活上的挫败，但通过整篇文章，的确可以更加深入得了解我这个人的价值观与人生观。</p><p>犹豫了一下，我决定暂时还是不要让她知道，我不敢保证她读完以后的感受，所以还是先度过一些美好轻松的时光吧。</p><p><strong>星期二</strong><br>白天照旧，与昨日类似，一切都显得十分顺利与和谐。</p><p>我这两天会有意识地搜集一些有趣而值得探讨的事情，这样我们彼此就能通过交流观点而加深了解。这一天我搜集到的是一个五岁小朋友的入学简历，小朋友非常优秀，简历很棒，我正好可以借机与她讨论讨论子女教育的问题。</p><p>晚上和她交流相关话题时，也聊的挺精彩的，可以说面对这些问题我们的基本理念是一致的。可就在这一晚我突然隐约发现了一个细节：她从未唤过我的名字，更准确的说，是我的姓名。我每天从早上第一句问候，到后面每一句对其生活的关心，我一定会呼唤她的名字，以表示亲切。诚然，她的姓名包含了三个字，所以当我截断姓氏后只取其名，两个字读起来显得朗朗上口。可是我的姓名就只包含两个字，如果全读出来，会显得过于正式，似有 “直呼其名” 之嫌。只取我的名字那一个字，又显得过于亲昵，倘若把这一个字念作叠音，更是不适合刚交往的对象。我不知道她是不是也这么想的，不过这里确实有难处，我能理解。</p><p>从这里其实也能引申出一个问题：三个字的姓名比两个字的姓名在社会交往中更加容易被自然得称呼，更容易从心里上被接受。所以在给自己孩子起名字的时候，尤其要注意这一点。</p><p><strong>星期三</strong><br>这一天开始有一点小波折了。我如往日一样，早早得送上清晨的问候，但是她并没有及时回复我，等我已经到公司了，她终于发消息告诉我她睡过头了。刚才还隐隐有些不安的我看到她的回复之后长舒了一口气，否则我还真担心出了什么事呢。<br>这天晚上，我们聊的话题比较发散，没有一个明确的主题，有时候谈到一些社会现象，有时候又聊到各自的爱好。于是，我终于了解到了，平日里，她很喜欢看韩剧，日剧，以及一些其他的综艺节目。我有一些发愣，因为娱乐领域我是真的不了解，也真的不感兴趣。一时间有种奇怪的感觉爬上了我的身体，我不知道这是一种什么感觉，但我又知道这是一种什么感觉。</p><p>后来没多想了，正如我在 <a href="#回味">回味</a> 那一篇中所描述的，我不愿意想那么多，有种力量在我身后不允许我想那么多。</p><p><strong>星期四</strong><br>保持节奏，清晨准时同她问好。然而这一天开始成为整个交往过程的转折点。</p><p>首先是，她早上回复我的问好不再带上表情了，只是三个字：早上好。这也无妨，我心里一直告诉自己不要特别在意一些细节。接着是，我中午向她分享了我的午餐内容，她没有回复我。关于这一点，我其实也能够理解，这几天中午我都时不时得分享一些琐碎的东西给她，而中午大家吃饭午休的时间都很短，若天天中午都抽空与我互动，次数多了是会有些不耐烦，只要换位思考，设身处地得想象一下便能体察那种感觉，所以说只要晚上我们下班后能愉快得交流我就心满意足了，其他的不必强求。</p><p>果然，晚上我们如期开始了微信上的交流。这天晚上和星期三类似，也是没有什么突出的主题，你一句我一句的，从天上聊到地下。不知道节奏是被谁带偏了，没一会儿我们竟然又聊到了兴趣爱好上面。说真的，经历了昨晚的交流，我现在不是特别想与她聊电视剧这个话题，但是这一天她似乎有点主动，主动追着问我会看一些什么样的电视剧。这让我很尴尬，我是真的很少看电视剧。可想而知，这一轮对话后，气氛瞬时凝固起来。短时间内她没有再发送消息，我隔着屏幕似乎感觉到了她淡淡的失望。“你有没有觉得我这个人有点无趣？”我以一种自责的口吻打破了临时的僵局。“没有啦，每个人的兴趣爱好不同是很正常的事情嘛。”</p><p>是的，我们每个人出生于全然不同的环境，自然而然得塑成了不同的生活习惯与兴趣爱好。我一直追求的是一种求同存异的关系，但是何谓同，何谓异？究竟该如何拿捏同与异的分寸，我之前并未深入细致得思考过，我内心一直持有的是这样的观点：态度，态度是关键。生活中有些事情是我们的心之所向，我们愿素履以往；有些事情虽谈不上喜欢，但却理解喜欢这些事的人，并认同追求这些事给 ta 带来的价值，或许在长期的交往过程中，我们也会在潜移默化之中同样爱上这些事情；还有些是我们不太理解，也不感兴趣的事情；当然必不可少的，总也会有些事，令我们十分反感，完全不能接受。</p><p>所以，有一个非常简洁而高效的筛选方法，就是逆向筛选。比如说，我非常反感抽烟，反感饭局与酒桌文化，反感各种网络游戏，反感类似直播、抖音这种极其浪费时间的娱乐工具。讨厌与反感是一种十分强烈的态度，是每个人不可妥协的底线，底线相互冲突，泾渭分明，也就没什么好谈的了。在逆向筛选之后，剩下的选择就不可能通过如此粗暴的方法实现了，但有些还是比较好判断的。比如共同的爱好，这将为我们对其印象加分不少，所以相当一部分有缘人皆源于同行。即便没有共同的爱好，但若能互相认可各自追求的价值，也是一件十分幸运的事，我想说，这就是我所理解的 “同” 的含义。君子和而不同，在价值追求的态度与原则上保持相同，而追求的具体手段与方式，可以不尽相同，这就是 “异”。当然，其他与态度及原则无关的生活习惯，那些经过交流后很容易作出妥协与改变的东西，也都属于 “异” 的范畴之内。</p><p>我似乎是在以一种理想化的方式解释我的择偶观，是定格某个静止的时刻，然后从这一截面横切进去作观察与判断。而然人是会变的，一旦考虑加入时间这一参量，整个求解过程便瞬间复杂起来，这将引出另一个艰深的领域，那是关于如何经营感情，如何处理好两性关系的深奥学问，已经超出了我此刻正在面对的问题。</p><p>这天晚上，我执拗地想理清楚一件事情：看电视剧对我来说究竟意味着什么？首先喜欢肯定是算不上。那么它应该被归类到剩下三个中的哪一类呢？这似乎不是一个可以被独立归类的事情，而是需要将电视剧的具体内容以及观看时长一并考虑进去才能综合给出的结论。就像电影一样，我喜欢电影，但不可能全局通吃，所有都看，我也只是看我感兴趣的，觉得有价值的电影。首先要肯定，电视剧是一种影视艺术，同电影在本质上是一致的，只是它的叙事不用像电影那么紧凑，它可以使用很长的篇幅来细致得表现主题，细腻得刻画人物。我喜欢高质量的经典电影，是因为其以精炼的篇幅表现深刻的主题，或者说，我可以利用相对短暂的时间完成对一部完整作品的欣赏。但电视剧过长的篇幅，容易花费大量的时间，让人陷入其中。我很少看电视剧的一个重要原因，就是我不想陷入对某一部电视剧的无尽追逐之中，我能体会追剧的痛苦。但如果遇到了质量优秀，主题深刻的电视剧，追逐一下也无妨，比如去年的作品《人民的名义》，这是我这两年看过的唯一一部电视剧，感觉相当满意。说白了，我反感的并不是电视剧本身，而是无止尽地耗费大量时间追逐低质量的肥皂剧，这其实与把时间花费在抖音、直播等上面没有本质的区别。</p><p>可惜当天晚上我并没有将这件事像上述文字那般理得如此清楚，我只是想象了一下如果以后我们真的在一起了，在同一个房间里，她在看韩剧，我在读书或者作文的场景，用一句话形如就是：各做各的事，没有共同语言。我是如此得冲动以至于提前亮出了我的底牌：我告诉了她我国庆节写过一篇探究真实自我的文章，我希望她能看一下。是的，如果已经察觉出什么了，最直白的做法就是大声对她说出来。但我选择了如此含蓄的方式来表达自己，含蓄到其实我自己都需要好好揣摩一下我这么做的用意何在：我正在被物质条件的优越所魅惑，我做不到由我这边主动把话挑明，我希望她能给个结论，在看完这篇文章之后。周一的晚上我之所以犹豫要不要给她看这篇文章，是因为我那时还拿不准她对这篇文章的态度。而这天晚上我亮出了文章，是因为我好像猜到了她可能的表态了。</p><p>现在看来，我那天这么做的确是一个无厘头的决定，我既不知道她在看什么具体内容的日剧韩剧，也不知道她一周花费多少时间在追剧上面，我好像是直接假想出了一个天天花费大量时间追逐各种无意义肥皂剧的她，但是又不忍心向她提出结束交往，最后以一篇文章的形式把这个决定权交给了她。</p><p>“今天不早了，明天我把这篇文章的链接发给你吧。” “好的。”</p><p><strong>星期五</strong><br>既然现在还没有得知最终的结论，所以我一如往常，向她问好。</p><p>中午的时候，我不再打扰她了。但是她倒是反过来主动给我发了一个新闻，讲的是前两天重庆公交车坠江案的责任认定结果，并附带了一句话：“午安”。简洁之余透着一股匆忙，似乎证明了我昨天的想法。但是她主动向我发信息，不知是不是觉得没有被我如期骚扰好像有一点反常？</p><p>晚上下班了，我给她发了一些消息，并琢磨着在什么时间点以什么方式发给她那篇文章比较合适。想着想着，我发现好长时间了她还没回我消息，见鬼了，不会是和同事聚餐了吧？我手里把玩着手机，揣摩着她现在的状态。我还没发给她文章链接呢，难道她已经察觉出什么了？中午那句午安到底向我发出了怎样的信号？</p><p>“我不小心把手机设置成免打扰模式了，没看到你的消息。你该不会生我的气吧？”终于，我看到她的回复，又是长舒了一口气。我怎么可能会对和我交往中的女孩生气？我只会感到难过，失望，以及惆怅，我是不容易被激怒的。没有犹豫，我发送了一个愉悦而期待的表情给她。</p><p>这就是微信，充满了各种假装与粉饰，你永远无法窥探到消息背后的人究竟是以一种怎样的心情在发送，唯一不能掩饰的就是回复消息的时间，这大概是微信交流中最诚实的信号了。</p><p>如果你正和你的对象交往，在下班后本应该愉快聊天的时间，收不到对方的消息了，你接下来本能得会怎么做？我就在这里时不时得看一下她有没有回复，时不时得刷出了最新的失望。她就在那里做着自己的事情，两个小时过去了，她突然发现不小心把手机设成了免打扰模式。</p><p>我和她大概都不是善于与对方真诚交流的人。当她中午对我频繁的消息感到厌烦时，她选择了使用沉默而不是沟通来向我传递她的不满；当我对她长时间不关心对方的消息而感到心寒时，我选择了使用一个愉悦的表情来表达我的 “不在意”。看来我比她更狠，她好歹还是间接得让我知道了她的想法，而我用这样的 “一腔热情” 将我的失望封藏得滴水不漏。</p><p>可该聊的天还是得聊，她至少问了我有没有生她的气，无论如何她都关心了一下我对她的态度。我半开玩笑得问她是不是在看什么引人入胜的节目，她笑着回答我说，她现在只是在和我聊天，顺手捣鼓捣鼓其他一些零碎的事情而已。这听上去多么像是对自己刚才的走心作出的补偿，而这种方法对于我这样的人又是如此奏效，似乎一瞬间又填补上了我内心失望的空白，让我顿扫所有的阴霾，重新拾起了热情。</p><p>但与往日不同的是，在尽兴聊天之余，我还保持了一份敏锐的心思，我在观察时机，在寻找一个恰当的时间点向她展示那篇文章的链接。不管今晚聊得多么欢畅，我都不会忘记我昨天和她说过的事，她忘记了不要紧，但我不能忘，哪怕我知道促使她回忆起昨日的对话可能并不是一件让她感到高兴的事。现在我们的关系正处在一个微妙的时刻，昨日与今日的反常似已令互相心生嫌隙，而我已决定摊出底牌，执意要交由她给我一个判决结果。</p><p>“这是我的那篇文章，如果有空的话，可以看一下嘛？”我总算是迈出这一步了。这只是早或晚的问题，而不是可以回避的问题，口头语言的交流不是万能的，要进入一个人内心最深处，ta 的文字是比 ta 的语言更加深刻的入口，尤其是像我这样敏感的人。我的文字承载了我的深情，我的文字承载了我不可言说的秘密。</p><p>她不再回话，毕竟阅读需要时间，审判亦需要时间。当明日第一道阳光射入我的瞳孔，不管她的结论如何，在这段关系中，我都将成为一个全新的自己了。</p><p><strong>星期六</strong><br>或许这是我最后一次向她问好，或许来日方长，那我便只管做好当下的自己，从一句清晨的问候开始。</p><p>其实我也能够猜的到，她没有回复。接下来会发生什么，我也很熟悉了，六年前的往事，历历在目，言犹在耳。我正襟危坐，只轻轻地问了一句：“可以告诉我你的决定了吗？”</p><p>无论她告诉我能理解还是不能理解，能接受还是不能接受，我都想好了该怎么回答。但是临近中午时分，她的回复竟让我哑口无言：“我还没来得及看你的文章呢。”愣神了半晌，我才吐出一句：“不着急不着急”。难道她是真的没有看吗？我有点不敢相信。如果这是真的话，这个结局简直比我预想的两种情况都要糟糕：她不愿意接受我的文字语言沟通，不愿意走进我为她打开的我内心世界的大门。但愿只是我想多了，希望她是真的没来得及看。</p><p>前几天当我还没有像现在这番纠结时，我一直在计划着周末我们两人的约会事宜。但是从周四晚上开始持续到现在的这个糟糕样子，我是怎么也说不出口了。我们的关系就像一盏明火殆尽，余烟袅袅的蜡炬，在等待着双方谁出来表个态，吹灭最后一丝火星。可我真的不忍心就这么不明不白得了结这段关系，我真想和她把事情说清楚。我习惯于使用文字表达，但文字不是万能的，就像此时此刻，如果她不愿意接受这种沟通方式，纵有千词万句，也只剩苍白无力，还不如注视着她的眼睛，用几句话传达我想表达的一切！</p><p>“我们明天可以出来一起见一见吗？”但是消息刚一发送，我就笑了：我其实第一天就知道的，她最近每周日都有一个专业培训要参加，从早到晚。所以星期日她指定是没时间出来约会的，这是上帝不给我机会。</p><p>“我原本以为我们会周六见面的，因为周日我要参加培训。但是你一直没跟我约，我以为你周六要加班呢。”事到如今已经活脱脱演成了一部悲剧，原来她心里面一直是这么认为的。我现在算是明白了，我们两个人的思路根本就没搭在一根弦上，我发现她并没有理解我这个问题的意图：“可以告诉我你的决定了吗？”当然这也怪我，我从来就没有把我的担心，我的内心想法详细得透露给她，我只是给了她一篇文章链接，只是委婉得对她说：“这篇文章中描述的我，可能会令你感到失望，但他确实是真实的我。”也许她没意识到，这篇文章对我来说有多么重要，所以否定这篇文章就是否定我，肯定了这篇文章，我才能构筑起我们共同交往的基础。可是在她眼里，这篇文章的链接和我之前给她分享过的微信公众号文章链接，似乎没有太大的区别。</p><p>当意识形态发生了冲突，悲剧就不可避免。如果和我交往中的女孩发给我一篇她写过的文章，这对她意味着什么，对我又意味着什么，简直再清楚不过了。能感受到的，一定会牢牢把握，感受不到的，只能任凭其错过。</p><p><strong>星期日</strong><br>我之所以还在向她问好，是因为并没有谁站出来给这段摇摇欲坠的关系定一个结论，而我答应过每天早上都要和她问好。但我已经力不从心了，我只发送了文字，而不再带上任何表情。照旧，她也不会回复我的。我觉得文章她肯定是看了，只不过接近七千字的篇幅，她未必有耐心将其看完。</p><p>我来到理发店，准备了却伴随我两个月的长发，手起刀落，一地断首，好生痛快！但这也止不住我肆意增长的惆怅，剪不断、理还乱的，是我的自作多情。</p><p>我决心再给我自己最后一次机会：既然无法当面交流，那我就给她打一个电话吧。</p><p>我突然想起了美国那位心理学家的著名公式：“信息的总效果 = 7% 的语言 + 38% 的音调 + 55% 的面部表情”。按照这个结论，如果使用微信作纯文字交流，93% 的信息将会流失耗散，只有不到十分之一的信息能够传递给对方。姑且不论这三个百分比的准确性，透过数字本身，公式的提出者其实想要强调的是沟通中情感反馈的重要性。</p><p><em>“你好呀, 在忙嘛?”</em></p><p>收到礼物的惊喜，遭遇挑衅的愤怒，触景而生的愁哀，与人分享的快乐······我们一定会承认，林林总总的感觉，心情，反应，很多时候没法用准确的文字来形容，正所谓只可意会，不可言传。语言与表情，总是相辅相成，相生相伴，所以无论是曾经的 QQ，还是当下的微信，文字沟通之余，我们都离不开表情包的使用。“一图胜千言”，一旦没有了表情，我们将在光秃秃的文字之下，陷入揣摩对方情感的无尽挣扎之中。</p><p><em>“哦没有，我刚吃完晚饭，正在回去的路上。你在家吗？”</em></p><p>心灰意冷，过去的我曾一度避免在通信软件中使用表情，因为表情的滥用，也是一种奢侈，一种放纵。过度依赖表情的人，最终将不得不以表情才能证明自己的情感，文字反而成为了表情的附庸。六年前，在我告别了初恋之后，这漫长的岁月里我孑然一身，再未觅得一人足以让我放下束缚，去发送那个曾经令我陶醉，如今却令我心碎的可爱笑脸，直到上一周，我与她相见。</p><p><em>“嗯嗯我在家呢。这两天我在微信里似乎感觉到你有些不高兴，我想打个电话关心一下你的情况。” “没有啦，昨天你没有约我出来见面，下午我就找我闺蜜逛街去了。只是我不喜欢三心二意，所以和闺蜜专心逛街时我从来不看手机的，不然逛街也逛不好，和你聊天也聊不好，你说是吧。”</em></p><p>久违的声音，如一口刚哈出的暖气抚慰了寒窗上的霜花。我好像没认真听清楚她说的具体内容，我只是听出来了她的语气里并没有丝毫的冷漠。一对情侣之间的甜言蜜谈，内容本身已不是重点，只要两个人持续得让彼此感受到自己正在意 ta，这样的交谈就能持续下去，这个过程就是感情的培养。微信的表情包可以满足这样的需求，电话里语音的交流更能够抵达对方的内心。</p><p><em>“实在是不好意思，我原本在周二周三时就计划着周末和你一起出来玩的，但是这两天的事情可能引起了一些小误会，说实话我看到你一直没回话，真的心里面很焦虑很担心。” “抱歉呀，我好像觉得你的声音和之前不太一样，我感觉到你受委屈了。”</em></p><p>卸下了微信的马甲, 我的真情实感再也无处遁藏。之前被滤去的重要信息，此刻正毫无保留，毫无阻挡得向她传递：如果你愿意一层一层得剥开我的心，你将会感受到我对你的在意，感受到我的压抑和不能自已。当此时我若站在你面前，必是 “执手相看泪眼，竟无语凝噎！”</p><p><em>“如果我有哪里做的不够好，你一定要帮我指出来呀，我怕你对我的不满意，我却全然不知道。”</em></p><p>六年前失恋的教训我怎敢忘记，曾经多少次，伸出手想抓住熟悉的背影，睁眼竟是梦醒。放下所有的面子，我只想挽回一段濒临结束的关系，哪怕无法改变最终的结局，至少我也要比六年前的自己表现得更好。付出实际的行动，不仅仅是为了她，也是为了我自己。</p><p><em>“不知道那天我冲动得发给你那篇文章，是否引起了你的不适？” “哦哦，那篇文章，我只看了前面几节，说实话你的语言确实让我感觉有一点点不舒服，我觉得你文中描写你的生理反应太过真实了，你可以描写你的感受，但是这个实在是有点······”</em></p><p>就是说，我猜中了开头，却没有猜中结尾。她确实去看那篇文章了，也确实没有看完，我猜对了。但她所吐槽的内容点与角度，我着实没有预料到。我本是如实描写，并未有夸大事实以博眼球，流露的是我的真情实感。她这般反应，也许意味着她在某一方面的拘谨态度，相关的话题讨论可能触碰到了她敏感的神经。在这一 “禁忌” 领域，她还无法接受 “激进” 的理念，还需要慢慢引导，打开心结。我相信，这是生命中最神秘且最容易引起好奇心的领域，保守的人儿，只是不经意间为自己的心坎设下了屏障，只是还未发觉屏障背后的精彩与奥妙。</p><p><em>“所以说，你是觉得我可能在某些方面，太过于流露自己的情感？或者说，说话的分寸把握得不是很谨慎？” “嗯嗯，差不多是这个意思吧。”</em></p><p>如果我在意她，又有什么是无法改变的呢？一段关系，原本就是在不断的冲突与磨砺下铸成越来越契合的彼此，世间本不存在自然成珏的一对玉佩，亦未有天生合璧的两柄宝剑。双玉成珏，必先经历千凿万刻的雕琢；双剑合璧，定要承受千锤百锻的冶炼。但只要缘分足够，无论趟过多少泥沼，无论穿越多少荆棘，天下有情人终成眷属。</p><p>······</p><p>“嘟嘟” 几声忙音，她的手机没电了。</p><p><strong>星期一</strong><br>清晨阳光灿烂，似乎没有任何征兆这天傍晚将会落下久违的甘霖。</p><p>周日晚挂断电话之后直到早上我最后一次向她问好，我始终也没能在微信联系上她，我是否需要相信她的手机一直没充上电而无法开机？ </p><p>感慨是只有我一个人的感慨，而没有别人什么事。现实与梦境的距离大抵如此，就算像昨天一样，像一周前初次见面一样，每天都能同她打一个如梦一般甜蜜的电话，但梦醒的时候我是否能够抵挡冷漠，战胜孤独与绝望？在该进入梦乡的时候我是否又能够安心合上双眼？该来的终究还是要来，至少以我的方式，这一周我没有怠慢过，我努力过，珍惜过。</p><p>恋爱毕竟是一种高级的人类活动，<strong>是一场难度极高的人生游戏</strong>，要通往幸福的彼岸，有太多的学问值得研究，有太多的曲折等待历经。作为一名程序员，我当然不会忘记排查 bug 时一次一次地调试失败，又从头开始追踪；作为一名作者，我再清楚不过当前正伏案作文的自己，是怎样将写好的词句，乃至段落，一遍一遍地删去，更重新构思酝酿。没有一次编译，完美运行的程序，没有一气呵成，字字珠玉的文章，那么也不会有：一帆风顺，波澜不惊的爱情。</p><p>百感交集，万情纵融，我将此时此刻心中之所言，汇成为一篇：<a href="#释然">《释然》</a>。</p><p>正襟危坐，我把手指停放在微信消息发送键上方约莫半寸的位置，缓缓得转过屏幕背对着脸，撇开头，闭上眼，深吸一口气，猛然将手指贴在了屏幕上。心里蓦然一颤，一周之内的往事与回忆快速得在大脑中闪现，像一管不断抽出的胶卷，被时间曝光，被记忆塑封，被灵魂收藏。看呐，它被盛放在一隅静谧的角落，一格质朴的抽屉内，抽屉的外侧贴上了标识：<a href="http://zshell.cc/2018/11/11/life-thought--一位爱情初级玩家的偏见式独白">《一位爱情初级玩家的偏见式独白》</a>。</p><p>睁开眼，待我再次面对屏幕，确认早已度过了足够长的时间，这条消息已经成功发送，再也，无法撤回了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018.10.27 ~ 2018.11.05，一周多一点儿的时间，却如同历经了一岁枯荣。&lt;br&gt;在爱情这场人生游戏里，我刚迈出第一步，却又将脚缩了回来。技能的缺失，经验的空白，让我这么一位初来乍到者感到了前所未有的迷茫。&lt;br&gt;但我没有选择，逝者如斯夫，犹豫不前将导向不可逆转的败局。我只能不断摸索，凭借着本能的反应，以及单身这么多年来建立的固有认知，以自己 “独特” 的方式闯入 “这场游戏的主战场”，开启 “战斗 - 挫败 - 总结 - 提升” 的玩家晋级之路。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="情感" scheme="http://zshell.cc/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>一只猫与南师的邂逅</title>
    <link href="http://zshell.cc/2018/10/15/life-thought--%E4%B8%80%E5%8F%AA%E7%8C%AB%E4%B8%8E%E5%8D%97%E5%B8%88%E7%9A%84%E9%82%82%E9%80%85/"/>
    <id>http://zshell.cc/2018/10/15/life-thought--一只猫与南师的邂逅/</id>
    <published>2018-10-15T03:20:35.000Z</published>
    <updated>2019-01-13T09:29:44.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>教堂内沧桑墙壁上深深刻着的 “命运” 一词，令雨果读出了人性的真善美与假恶丑；实验室中模拟地球演化的系统，一个是否包含生命的参数选项，令刘慈欣窥探到了整个宇宙的游戏规则；这一次轮到了我，当一只流浪猫与南师邂逅，当它的目光与我的目光交织在一块，我将会悟出什么？</p></blockquote><a id="more"></a><hr><h3 id="自序"><a href="#自序" class="headerlink" title="自序"></a><strong>自序</strong></h3><p>这本是一封辞职信，初写于 2012 年底。在我的百度网盘私密空间尘封六年之后，我决定让其重新曝光于这个世界。</p><p>我记得 2006 年我上初中，第一节语文课，学到的第一篇课文，是赵丽宏老师的《为你打开一扇门》。开学伊始，我定然是认真得学习，可惜我天性愚钝，又或是阅历尚且，在诵读与笔记之余，并未理解赵老师想要表达的真义，无法窥见那扇大门背后的瑰丽与宏伟。那时的我像个 “标准” 的理科生, 字迹潦草，性情执拗，无法欣赏文学的美，只知道埋头解数学题。</p><p>六年过去后，我上了大学，以一名理科生的角色来到一所偏文科的院校。这看似剑走偏锋的选择，却为我呈上了一份珍贵的人生之礼：发觉艺术与审美的能力。而这篇文章所描述的，正是母校赠与我这份礼物的全过程。从事理工相关的方向，求学与职业之路无不充满了复杂的设计与缜密的逻辑，思维的高负荷运转难免为生活带来干涩与磨损，而这份精致的礼物，可相伴我一生，舒缓不顺心之事所带来的烦恼，慰藉不如意之情所添增的苦闷。</p><p>六年之后又六年，今天的我将这篇文章搬上了我的博客。错愕于触目惊心的文字，我方才惊忆起过去的我长着如何的一张面孔。尽管文中我的行为令现在的自己感到不齿，但那的的确确是过去的我，是真实的曾经。人总是在不断的改变，我们不会因为一个人糟糕的童年而否定其往后的努力人生，尤其当这个人是自己时，甚至需要反过来感到欣慰，欣慰自己的成长与蜕变：我，已经从一个懵懂无知的少年，变成了一个渴望思考、好奇世界、憧憬美好与高尚的青年人。回想起十二年前我坐在初一 (11) 班整洁明亮的教室里，朗诵着《为你打开一扇门》，我不禁热泪盈眶。纸上得来终觉浅，绝知此事要躬行，无论如何，我已经真正悟了，相比于那些还在门外徘徊不得而入的人来说。</p><p>种一棵树的最佳时间是十年前，其次是现在。感谢扬州市梅岭中学，于十二年前在我心中播下了一粒种子；感谢南京师范大学，于六年前为种子周围的土壤浇水施肥，令新生的嫩苗破土而出；感谢现在的我，继续悉心呵护着小树，令其深深扎根，茁壮成长。我相信：终了，它定会在我心中成长为一棵枝繁叶茂的参天巨木。</p><p><strong>以下为正文：</strong><br>&nbsp;</p><p>我特别喜爱南师阳光明媚的午后，尤其是在这幅精致的图景之上添置一只可爱的小猫。</p><h3 id="迷误的心"><a href="#迷误的心" class="headerlink" title="迷误的心"></a><strong>迷误的心</strong></h3><p>猫本是有灵性的动物，随遇而安，依境而存。于是，在我们宿舍楼，周遭总是窜着一只又一只的。它们日日生活在我们周围，睦邻相伴。每天都有阿姨给它们喂食，也有男生女生与它们嬉戏。就像青春的精灵，不管来自何方，它们都可以忘却曾经，尽情享受如今的温馨美好。</p><p>猫有记忆，它们能记住人。宿舍楼里的同学可以分辨出不同的猫，为它们起一个个可人的名字。猫也能辨别不同的人，尤其会记得某某对自己特别的好，于是静静往墙角一趴，专心地等待那位同学下课归来，几个小碎步迎上前去，懒懒的喵一声，像是在对自己的好朋友道声问候。</p><p>不过，猫也有自己的烦恼，因为它们遇上了我。我是一个理工科男生，也是这里所有安详与和睦的搅局者。在我这位理工男的眼中，动物与人是不一样的。人迹出没的地方，容不得动物的插足。但凡在我回宿舍的路上，看到猫的踪影，我的第一反应便是狠狠跺上一脚，看它们被吓得四散逃跑，仿佛在我心中，那是光明的火种驱散黑暗的阴霾，是人类为自己的权利而不懈斗争的胜利，我以为自己获得了一种不足为外人道的满足感，甚是好笑。自此，没有哪只猫会在看到我之后不慌不乱，甚至是隔得远远的时候，当感受到那一袭黑衣，斜跨黑包的身影急促地逼近时，所有在路口等待自己好朋友归来的猫们就仓皇而撤，连正面与我对视一眼的机会都不曾有过。我冷冷地微笑着。</p><p>我曾经就是这样以搅局者的身份自居：思维奇异，与众不同，追求极端，冷酷无情。仿佛一个理工科的男生，来到女儿王国的南师大，势必要挑起一场价值观的冲突。</p><p>虽是彻头彻尾的冷酷，但我依旧在外表上活成了一个 “有声有色” 的人：和其他同学一样，面试校学生会，面试赛扶，参与各种社团，过关斩将，悉数被录用。面对动物，我睁着邪恶的双眼；而面对人，我又展示着理性的思维与缜密的语言组织能力。道貌与岸然，将我的人格诠释的刚好。</p><p>于是，我加入了南师赛扶 “虎韵福鞋” 项目。在这里，我依旧走着我的风格：颠覆式的否定与创新。我无视了那些女生苦心孤诣地挖掘与丰富虎头鞋内涵的举动，我不懂她们也无心去了解。我一意孤行地设计着自己的战略：让传统的文化与现代的时尚去激情碰撞，我试图打开电商推广的渠道，我只相信现代科技的力量。而虎头鞋本身究竟是什么，我并不懂。虎头鞋的追根溯源与精神文化，我亦不屑。像我这么浮躁的人，怎会有耐心打磨绣花针？所以，分歧在所难免，隔阂日渐凸显。但是，我行我素，因为没有一种力量能打破僵局。</p><h3 id="梦醒而惊"><a href="#梦醒而惊" class="headerlink" title="梦醒而惊"></a><strong>梦醒而惊</strong></h3><p>但是却有一种无形的力量可以做到。</p><p>一个阳光明媚的午后，我独自一人往宿舍走。静谧无声，周遭的一切与往昔似没有任何不同之处，唯独别致的是，当我路过一个转角，经过开水机的一刹那，我瞥见了一只小猫。它是如此的大胆以至于竟敢在我面前装作不动声色，甚至还作出 “越界” 的举动：趴在人类的开水机上惬意地舔舐着上面的积水。我从来都没有机会近距离地观察一只猫的形态，于是突然就来了好奇。弯下腰，以一种不怀好意的目光打量着它：一身毛发黄白两色，渐变一般从头到脚柔和地过渡，尾巴翘着老高像是在保持平衡，两只前爪刚好抠住不锈钢的平台，尽情地享受着饮水的乐趣。它的肚腩如波浪般的一抖，显然是一口清澈的陶醉。或许是忘我的沉浸让它忽略了身边的危险，我一口呼气掠过它的发须，它漫不经心的一瞥，眼神正好在那刻与我对撞。</p><p>原来这只猫的眼珠竟是蓝色的，特别纯洁的那种蓝！惊讶之余，一股被挑衅的感觉莫名涌上心头，我竟不能让这只猫屈服？莫非它不畏惧我邪恶的眼神？难道相比于它我这庞大的身躯都不能对其构成一点压力？我在考虑要不要保持我在这栋楼里对猫群的 “尊严”，总不至于过往的惯例在今天就此打破？</p><p>有一点我敢笃定，这只猫是这栋楼的新客，它没有见识过我的凶残，在它记忆里恐怕只有南师大整体的博爱情怀！</p><p>在它蔚蓝的眼神里，似乎包涵了整个南师大的灵魂：清澈不失厚重雄浑，淡定却又锋芒敏行！没想到，从一只猫的眼里，我竟读出一种强大的气场，邪恶与正气的交锋中，我越发觉得自己已处于守势！</p><p>如果我此刻突然爆发，使用暴力手段相威胁，它一定会在瞬间仓皇而逃。但是如果剥离所有肉体与物质层面上的东西，在两个生命的对峙中，我却无论如何也无法战胜它。曾经有个寓言：在质量的天平上，蚂蚁和大象没有可比性，然而在生命的天平上，两者却是等价的！</p><p>我觉得我没有资格在这只猫面前滥用武力，因为我面对的不仅仅是一只猫，也是南师大，她是我尊敬的母校！</p><p>或许这只猫曾浪迹天涯，只是最终与南师邂逅，并在生命里注入了南师的基因，从此行走在博雅与爱的路上。南师的魅力在于她不但能感召人，同时也能将物点化为自己的精魂。而很大程度上，南师感召莘莘学子，正是靠身边不计其数的师大精灵，才让混沌而迷误的灵魂走出泥沼，获得醍醐灌顶的觉悟。</p><p>我庆幸自己最终没有对那个纯洁的生命做出卑鄙残忍的行为，从而让它保持了那份对南师无暇的爱。我也后悔自己让其它无辜的生命这些天饱受恐惧与惊吓的折磨，打碎了它们对南师这个伊甸园美好纯真的映像。我担心，这些天，我从未让这些青春的精灵正面看我一眼，它们可能会误判而刻意躲避与我衣着类似的同学，这是间接剥夺了其他同学对自然生命亲密接触的权力！这一切的后果都是我造成的！我宁愿让我暴露在光天化日之下，让所有的精灵都看清我的本貌，让所有的惩罚都冲着我一个人来吧！</p><p>就让恶贯满盈的少年发自内心地忏悔吧！就让一身污迹的浪子接受电闪雷鸣的洗礼吧！</p><p>正是这种无形的力量。</p><h3 id="忏悔与反思"><a href="#忏悔与反思" class="headerlink" title="忏悔与反思"></a><strong>忏悔与反思</strong></h3><p>对物残忍，对人傲慢。揭开我道貌与岸然的画皮，剩下的大概就是这两句话了。曾经我被赛扶吸引，是因为 “商业” 二字。然而我却忘了全句：用商业的力量改变世界，造福社会。重点在后面，而我本末倒置。我丝毫没有忖度自己的实际素养便妄图加入，还用自己的无知拖累整个团队，用赤裸的利益动机玷污了虎头鞋博大精深的文化底蕴。曾经有团队的同事告诉我，她选择虎韵福鞋是因为自己真的非常喜欢中国传统文化，因此想在这个领域做出自己的贡献。而我怎么告诉她？我选择这个项目是因为其中有诱人的利益链条，因此想大挣一把？情何以堪？</p><p>如今我再也不敢说我参悟了赛扶的真谛。真谛无情地照在我身上，反射出我惨白而嶙峋的瘦骨。我活了将近二十年，可能从小就会写 “公益”、“可持续” 这些个汉字。可悲的是，到如今我仍然还停留在小学的水平，我会写这几个字, 看得懂它们的字面意思，但是就是无法领悟它们的内涵！初中高中，学了六年的理工科，接触了大量的公式与定理，我每天忙碌地在试卷与作业上搬运成批成量的它们，我自以为能灵活运用，驾轻就熟。可是，我发现，学理工科最大的致命伤，就是我们过分强调了运用，却忽略了这些公式背后的探索验证，其实是一把饱含血泪的辛酸史。理性，正在扼封人性！我们踩着前人的肩膀向上攀登，却忘记了对先辈、对知识的敬畏与仰望！那一串串字符，是有血有肉的生灵；那一句句推理假设，当是为我们的明天，为我们的后代奠定了幸福的基础！</p><p>这些, 我曾经想过吗?</p><p>一个伟大的科学家，绝不仅仅停留在对人类在科学技术上的突出贡献。他一定也是一个悲天悯人的慈善家，他热爱生命，关心人类的疾苦，这些都是促进他在科学领域开创新时代的源动力；他一定也是一个对人类，对社会负责任的公民，他参悟了公益与可持续发展的内涵与精髓，他从骨子里焕发着对社会的使命感；他一定，也是一个心思细腻，柔情似水的诗人，在一只小猫面前，他甘心拜倒，放下他所有的身段与荣耀，只为接受自然予他的馈赠。</p><p>而一个伟大的科学家，从广义上讲更是一个执着思考的文学家。文学是这个世界上最容易被忽视而又最不容忽视的巨大力量，文学，总是与世界上最感性的事物相关联。她代表的是一种信念，一种信仰。她可以在人类面临危机时爆发出不可抗拒的能量，也可以在日常中左右人们细微的行为，并以一种滴水穿石的恒念，积聚起改变未来的倾彻。</p><p>历史上很多著名的科技巨头公司，曾经都是光芒万丈的恒星，他们也秉持着改变世界，造福社会的理念，只可惜，不可一世的辉煌麻痹了他们的双眼，资本市场的催化却加速了他们的腐化，很多人变得腰缠万贯，也变得偏执傲慢，于是离自己的初衷渐行渐远，最终堕落为天际边划过的一颗流星，燃烧殆尽。</p><p>怎样才能让自己始终不变初衷，坚定不移地前进？唯有信念与信仰！我越来越相信文学的力量，相信她对人的一生所起的指导作用。信念，只有一个终点，教人始终清醒，洞悉自己，不为眼前所迷惑，善待众生。如果一个跨国公司，在一只猫面前敢于屈膝，那么它就具有了生生不息的动力。一个能扛得起惊天伟业的人或组织，一定也能在自然面前认清自己卑微的本质。一个人当认识到自己的卑微时，他的行为便开始伟大！</p><p>所有贪图商业利益的人都是在走向终结的深渊。时间会淘尽一切，露出真金的本色。对于虎韵福鞋而言，文化即是最好的保值品。将来所有的东西都会消失，唯有文化得以生生不息。此刻，我刚好理解了为什么女生们会在加入虎韵福鞋后醉心于虎头鞋的文化内涵了。一个肤浅的人，搅浑了一捧清澈的甘露。</p><p>这些天，我突然想起来两个多月前我与杨经理第一次的电话交流。“如果将来学生会与赛扶都很忙，你必须放弃一个，你怎么选择？” “我会选择赛扶。因为我在暑假就已经规划好了我大学的目标，培养我在商业方面的职业素养。校学生会方面，我在宣传中心工作，可以理解为媒体与公关，它确实也是商业组织不可或缺的一部分，但那本质上触及不到商业的核心。”一段貌似有理的论述，现今看来，恐怕都没有一层纸的厚度。这段话暴露了我早期贪婪的本质，如果按照我 “精心设计” 的路线走下去，前方不远一定是万丈深渊。</p><p>我如今，没有能力，没有资格再在赛扶继续下去了。我向我曾经因为自己的无知而亵渎的虎韵福鞋文化，公益的精神，社会可持续的使命表示深深的歉意。在此，我也正式呈上我的辞职申请。</p><p>杨经理，请原谅我的食言。面对一个歧误的承诺，我已无力再恪守。</p><p>曾经我还抱着美好的希望，希望能在赛扶找到值得相伴一生的人。现在我只能苦笑，我的卑鄙龌龊根本就配不上那些天使般的女生，我的凑近只会反衬她们的纯洁，我不配！</p><h3 id="脱胎与换骨"><a href="#脱胎与换骨" class="headerlink" title="脱胎与换骨"></a><strong>脱胎与换骨</strong></h3><p>又是一个宁静的午后，我站在宿舍阳台的一隅。远处层叠的山峦，如同编织起温暖的摇篮，枕着南师所有的生命，孕育着未来。</p><p>我之于那只可爱的小猫，不就如同猫之于南师大吗？感化与洗礼，脱胎与换骨，一只猫被注入了南师的精魂，青春的精灵得以在世间飘洒。而我，又何尝不是一只猫呢？造化选择我与南师邂逅，选择在一个阳光明媚的午后，选择在一个静谧无声的楼道，选择与一只青春精灵的生命碰撞，来完成对我整个灵魂的重塑！</p><p>我爱上了文学，爱上了读书，爱上了写作，爱上了思考。我作为一个理工科的男生，有必要去经历一个从未体验过的生活。一人静静走在随园校区的林荫小路上，凝神尽力吮吸着那古色古香的建筑所焕发出来的韵味。人生需要放空自己，解开束缚，让所有的欲念自由飞翔，能沉淀下来的才是真正的菁华。</p><p>如果说南师代表的是女性，那么我自甘情愿接受女性化的洗礼，我爱我的母校！如果有需要，我也可以成为南师万物中被点化的精魂，去拯救更多混沌而迷误的心！</p><p>我也愿意等候下一个安详而静谧的午后，站在宿舍开水机旁，只求与那只可爱的小猫再一次邂逅······</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;教堂内沧桑墙壁上深深刻着的 “命运” 一词，令雨果读出了人性的真善美与假恶丑；实验室中模拟地球演化的系统，一个是否包含生命的参数选项，令刘慈欣窥探到了整个宇宙的游戏规则；这一次轮到了我，当一只流浪猫与南师邂逅，当它的目光与我的目光交织在一块，我将会悟出什么？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="人生" scheme="http://zshell.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>六年来我与自己的斗争</title>
    <link href="http://zshell.cc/2018/10/07/life-thought--%E5%85%AD%E5%B9%B4%E6%9D%A5%E6%88%91%E4%B8%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%97%E4%BA%89/"/>
    <id>http://zshell.cc/2018/10/07/life-thought--六年来我与自己的斗争/</id>
    <published>2018-10-07T15:44:27.000Z</published>
    <updated>2019-01-12T17:39:47.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写出这篇文章, 就意味着我的幼稚, 但若不写这篇文章, 也只不过是将幼稚藏于心底罢了. 敏感脆弱的品性, 使我固执了六年, 而不敢拾起真实的自己, 蓦然回首, 却发现我苦苦寻找的光明, 其实就是自己的影子.<br>伤痛, 迷惘, 绝望, 逃避, 再次面对, 幡然醒悟…… 值得欣慰的是, 无论这个过程多么坎坷而曲折, 这么多年来, 我心灵最深处却始终保留着通往真实自我的火种, 在历经无数的风吹雨打后重新被我拾起, 重又燎起了我内心的草原.</p></blockquote><a id="more"></a><hr><h3 id="不堪一击的我"><a href="#不堪一击的我" class="headerlink" title="不堪一击的我"></a><strong>不堪一击的我</strong></h3><p>时间回退至 2012 年, 阳光明媚的正午, 我收到了你的消息: “我们俩的关系可能真的需要考虑一下了!”<br>开学以来的这两个月我很幸福, 可惜在你眼里我最终还是令你感到失望了. 这是一个无法挽回的结局, 我不会赖着强留你. 这是我第一次失恋, 只是这终点距离起点, 只有两个月的时光. 我的内心一边对伤痛的洪流打开了闸门, 一边又在无力地安慰自己: 这只是两个月, 而不是两年, 但愿没有陷得太深.<br>可惜一语成谶, 我高估了自己的情感自愈能力, 接下来的一段时间内, 我已经不是在开闸泄洪, 而是在坠入黑洞:<br>拂晓时分, 睁开眼的一瞬, 我一次又一次得被无情的现实拽开梦中我们紧拉着的手; 之前极少梦遗的我, 每当掀开被子, 时不时会感到一片湿漉漉的下身; 我在同学朋友面前故作镇定, 每当控制不住时, 不得不闭上眼睛, 好让眼泪被瞳孔快速得吸收, 末了, 再假装睁开惺忪的睡眼, 生怕别人看穿我内心的波澜.<br>在接近一个月的炼狱之旅后, 我熬过了失恋的第一阶段, 这一阶段属于时间短而冲击猛烈, 如果我属于天生乐观的那类人, 挺过这一阶段就能恢复到正常的生活. 很遗憾我没有做到, 在此期间, 我的生理, 心理, 潜意识都不亚于经历了一场器质性的改变, 造成了难以愈合的创伤, 以致于我的身心被迫进入了失恋的第二阶段.<br>这一阶段属于文火慢炖, 学习, 作息等日常活动都与此前几无二致, 但性情却发生了大变, 仿佛我内心的某一扇门被合上了: 我关闭了 QQ 空间, 排斥在任何群里说话, 与单个人发送信息时也不会再轻易使用任何表情, 尤其是那个可爱的笑脸, 它像极了一个讽刺, 曾经它令我感到多么幸福, 现在就令我感到多么残酷. 后来普及了微信, 但于我这并不意味着一个崭新的开始, 却倒像是对 QQ 的一个延续, 我从未在朋友圈中分享过任何内容, 也未主动加过别人好友, 不认识的人一律拒绝, 临时有事需要联系的, 当事情结束后我便清空一切痕迹…… 我的学业虽不曾耽误, 但把这种孤立自我的生活称作一蹶不振也不失得当吧.<br>喜怒哀乐乃人之常情, 哀多乐少, 也勉强可以当是一种生活之态, 随着时间推移, 此消彼长, 或许于不经意之间又可以找回当初的模样. 可惜我的心境没有就此打住, 而是继续向更深处跌落, 向着扭曲与极端方向发展, 我本以为时间会为我酿制解药, 慢慢稀释我的悲痛, 但恰恰相反, 我其实每天都在服下这剂慢性毒药, 日复一日, 直至病入膏肓, 落下无可弥补的后遗症: 我不敢再谈恋爱, 不再有信心处理好两性关系, 不敢再次尝试陷入别人的世界中, 因为上一次的经历警示我, 哪怕只有两个月, 我都难保可以承担其失恋之痛. 我冷漠得回应异性对自己的表白, 尽管对方的真心也会让我内心悸动, 但我总以 “绝对的理性” 强制扑灭心中的火苗. 有时候别人的表白也会令我感到 “喜悦”, 不过这份喜悦只是拒绝别人时变态而畸形的虚荣心与优越感罢了.<br>恰逢失恋之时, 又遭遇了父母离婚, 在这样的双重打击之下, 我的三观彻底淹没在了汹涌的洪流之中, 我无可避免得陷入了第三阶段:<br>凡事有始必有终, 既然承受不了终点的痛苦, 那干脆就别给它开始的机会. 这句话传递给了我一个危险的信号, 我难以想象任我现在的状态发展下去会面临一个怎样的结局? 庆幸的是, 在这样一个节骨眼上, 我遇到了我的高中同桌, 他在隔壁南邮学的是计算机专业, 我仔细聆听他讲述他们专业的内容及特点, 并感受到了强烈的召唤: 计算机可能是助我摆脱当前危险处境的救命稻草, 我必须竭尽全力得投入其怀抱, 这是避免我生命终结的不二选择! 经过半年的努力, 我成功转到计算机学院, 真的好希望能以此为契机, 彻底告别过去!</p><h3 id="倒向另一种病态的追求"><a href="#倒向另一种病态的追求" class="headerlink" title="倒向另一种病态的追求"></a><strong>倒向另一种病态的追求</strong></h3><p>计算机给了我一个活下去的理由, 它是挽救我生命的第一张多米诺骨牌, 但要真正推倒它, 我得付出实际行动: 我需要疯狂得爱上计算机. 如若不能永恒, 那就注定要毁灭, 假设我对待计算机的态度只是为了逃避情感, 那这种三分钟热度断不可存续太久, 命运将会无可抗拒, 所以我需要打造一个被信念赐予力量, 抛开一切杂念的自己.<br>很快我就给自己找到了一个力量之源: 还是我那位南邮同学. 是他在我即将坠入万劫不复之际为我打开了一扇门, 当我踏进门内, 面对广阔无垠的新世界, 他再一次成为我撷取知识的参考系. 他是从大一开始学习计算机的, 而我属于大二开学才半路杀入, 我和他之间至少存在一年的差距, 于是我的奋斗目标被冰冷得定义为: 竭尽所能赶上他并超越他! 我开启了自己波澜壮阔的求学之旅, 每日每夜, 每时每刻. 图书馆, 教室, 宿舍, 食堂窗口, 路上…… 如果我处于一种思考的状态, 那我一定在思考与计算机相关的问题, 我进入了一种不可思议的魔怔.<br>每个周末我都要找我这位同学交流最近的学习心得, 这种事情从开始的只是令我感到愉悦, 发展到后来的令我极度渴望, 我大概意识到了我学习计算机的动机已经发生了微妙的变化, 我不是直接在为我自己学习, 我是在为我同学而学习, 我从同他的每周交流分享中获取快感, 更甚的说, 我从每周在他面前的装逼中体验高潮, 这似乎才是我学习的原始动力. 当然, 我在察觉到在我这方面的疯狂后, 其实也在有意无意地利用这一点: 如果装逼的代价是需要持续学习, 那我不介意把装逼进行到底, 不管学习的动机与姿态多么难看, 我都是在实打实得学, 最后掌握知识的人还是我自己啊!<br>一旦有多巴胺在生化级别上对我的行为作出了奖励, 我真的感觉要对过去说再见了. 自杀? 没有的事, 计算机的世界还有太多太多等着我去发现, 哪还有心思去考虑怎么死?<br>学生会, 社团, 团 (党) 支部, 这些字眼都与我无缘了, 当我不在其上倾注感情, 也就无所谓得与失. 我的追求就是计算机, 我对其倾注了所有的情感, 它也给足了令我满意的反馈, 我绝不容许自己失去它, 失去即是死亡, 即是毁灭.<br>差不多这就构成了我大学后三年的生活基调了, 我认为这三年来我已经摆脱了失恋后危险的第三阶段, 进入了一个有点唯心主义, 并带有极端色彩的第四阶段. 第四阶段与第二阶段在很多方面很类似, 我还是和以前一样社交恐惧, 内心离群索居, 与常人的生活浅行浅远.  但是第二阶段我的行为受到了主观意志的干扰, 而第四阶段的我却是自然而然, 仿佛与生俱来, 水到渠成. 另外, 第四阶段的我有强力的追求目标, 让我的学习生活充满 “活力与斗志”, 这几乎是塑造了一个全新的自己, 但我清楚这并非一种健康的状态, 就像前苏联一样高歌猛进, 最后变成了跛脚的巨人. 可是我能停下来吗? 我敢停下来吗?<br>大概每一个单纯而执着的程序员, 背后都有着自己心酸的往事. 茶余饭后的人们总是戏谑程序员的木讷与无趣, 殊不知木讷可能并非我们天生的性格, 而是后天无可奈何的选择.</p><h3 id="裂痕渐起"><a href="#裂痕渐起" class="headerlink" title="裂痕渐起"></a><strong>裂痕渐起</strong></h3><p>毕业后我去了北京工作, 而我这位同学则继续留在南京读研, 地理位置的隔阂让原本的一周一碰面, 变成了以年为单位的见面. 当然, 我这辆疾速奔跑了三年的战车, 已经拥有了足够的惯性, 使得我不再需要以大学时代的模式来维系我生活的运转.<br>但这终究还是有区别的, 学习与工作, 校园与社会. 我真心怀念学校图书馆里无忧无虑看书的日子, 相比之下, 在社会上, 毕竟拿着公司发的工资, 干活与完成任务才是第一要义. 我喜欢计算机, 但这和在互联网公司上班是两回事, 很多人倾向于用工作的忙碌程度来评估自己的价值, 把自己交给繁忙, 得到了心里的踏实, 但在 IT 行业, 这是个死亡陷阱, 是一个让人陷入原地踏步无法快速提升自己的重要原因. 我不喜欢上班的感觉, 可是哪有不上班的道理, 不上班哪有经济来源?<br>如此, 自失恋以来我又陷入了另一种痛苦之中, 工作使我不得开心颜. 即便并非天天皆如此, 但这种悲观的预期却很难摆脱, 当面临一个晴朗的周末, 如果想到下周一又得跟进一个活见鬼的项目, 这个周末还要怎么度过? 一周有七天, 五天很烦恼, 剩下两天稍微缓一缓; 一年有 365 天, 358 天都是漫长的修行, 最后七天回到家乡与亲人团聚见一面. 假期总是一晃而过, 新的修行早已在路上. 一年中的时日就像结绳, 绳子由痛苦构成, 结点则是快乐的分身, 短暂的快乐连结了一段段漫长的痛苦, 使岁月得以延续, 然明年复明年, 明年何其多?<br>淳朴的民工, 辛勤劳作了一年, 返回家乡时是快乐的. 天生焦虑的我, 只能感叹, 快乐到来之前才是真正的快乐, 假期来临之际其实刚好按下了快乐准备结束的倒计时, 一秒一秒头也不回得流逝着, 宣誓着, 下一段痛苦的降临. 佛曰: 受身无间者永远不死, 寿长乃无间地狱中之大劫, 身处人间界又何尝不是如此?<br>五年前我去过一次杭州, 欲把西湖比西子, 淡妆浓抹总相宜. 这是个令人心驰神往的城市, 同时也孕育着互联网的新时代. 我尽力地安慰身处北京的自己, 将来会有那么一天, 我挥手作别北京, 投入杭州的怀抱, 览水光潋滟, 观山色空蒙. 痛苦将会消褪, 幸福将会来敲门……<br>苦难中的人们, 热衷于编织美好的未来传说. 三大宗教长盛不衰, 因为它们所倡导的救赎, 依托于死亡. 当无法眼见为实, 我们便心甘情愿以耳听为虚来慰藉满目疮痍的生活. 所以,一个善意却不太高明的谎言, 会给被骗之人留下通往真相的尾巴, 当执着者按图索骥触及终点时, 便会意识到斐然如画的词句, 不过想象里缥缈的幻光, 乍现即逝, 正如我此刻虽已置身杭州, 只是城虽换, 心未易, 这两个月来却没有一天开心的日子. 当然在北京的两年我也不曾度过开心的时光, 可我在北京总可以安慰自己去了杭州一切便焕然一新. 那么现在身处杭州的我, 该怎么继续安慰 (欺骗) 自己, 难道说等再回了南京一切才能真正好起来了吗? 我内心到底在渴望怎样的一种生活?</p><h3 id="信念开始瓦解"><a href="#信念开始瓦解" class="headerlink" title="信念开始瓦解"></a><strong>信念开始瓦解</strong></h3><p>从我第一次接触编程到现在已经快六年了, 我心无旁骛, 一路披荆斩棘. 我以为曾经的痛苦会被我指尖的代码所肢解, 我以为程序调通的瞬间会从内心升腾起由衷的喜悦, 我笃定计算机是这世界上值得我留恋的东西, 却不曾想到它竟渐渐成为我在这世上唯一值得留恋的东西.<br>在北京的我, 无论工作压力多么大, 生活多么重复单调, 我都能忍受, 对计算机的喜爱加上对杭州的憧憬, 所有的烦恼都会烟消云散. 同大学时我不顾一切得投入计算机类似, 这种激励模式谈不上良性, 但至少也为我在一段时间内保持了比较稳定的心态, 直至我来到杭州为止, 我以为换了一座城市, 就能甩掉所有包袱, 重新开始, 如今这被证明不过是在以偏概全, 换汤不换药. 作为一个谎言, 它的确很有魅惑力, 起到了望梅止渴的效果, 可惜曹孟德最后确实找到了水源, 然对我来说只是延缓了精神崩溃的时间罢了.<br>在北京的时候, 偶然间我会再次萌生出自杀的想法, 只一闪而过, 随即便会被理智所控制, 我笑着告诉自己不值得, 我走过了黑暗的岁月, 在失恋后最绝望的第三阶段重新拾起了新的追求目标, 我何苦再踏回原先的老路. 而今在杭州的我, 被自己欺骗了自己的我, 美好憧憬破灭的我, 当再次想起自杀这个词眼时, 我竟然放下了警惕, 开始认真而专注地考虑这件事情:<br>六年来, 两千多天, 我努力超度自己, 一层又一层得剥离自己感性的一面, 我不再购买帅气的衣裤, 不再尝试原创音乐, 不再和小动物玩耍, 不再打网球,  不再与别人进行深入灵魂的交流…… 我腾出大脑的所有容积, 只为给计算机世界留下 “自由发展” 的空间. 终于, 我 “成功” 了, 当我闭上眼, 当我睁开眼, 我在意的只是代码, 其余的一切, 都毁灭了, 当我不再拥有它们, 也就不会再失去它们. 起点与终点, 如果每个人都要选择用一条线来连接, 那么我选择了直线, 所以当美好的周末来临, 除了继续研究另一个令我 “感兴趣” 的技术实现方案之外, 我已没有任何其他的 “期待”.<br>如果其余都照旧, 只是不再与小动物玩耍了, 我的生活最多少了两声欢笑; 同理, 如果只是不再打网球了, 我也可以很快找到另外一项消遣活动; 但当所有的这些都消失了, 就构成了现在的我, 一个被执念牢牢束缚的自己. 五彩的泡沫幻灭了, 我终于要看清我的真实面目了: 原来我这六年来所做的一切努力, 并不是在为自己打造一个没有失去, 没有痛苦的乌托邦, 而是恰恰在无端地制造失去, 硬生生得剥夺生活中的乐趣. 我变成了一个自虐狂, 扼杀人性于无形之中, 最后只能依赖一个莫须有的谎言, 苟延残喘, 艰难度日. 细细想来, 谎言中描绘的图景所影射出的, 不正是我一边在极尽渴望, 一边却又撒手而弃的生活吗?<br>猛然回神过来, 我正站在窗边, 凝视着十三层楼下的马路, 一辆又一辆的汽车川流不息, 越开越远, 直至消失在视野尽头……<br>这算是我失恋后历经的第五阶段吗?</p><h3 id="重新思考-重新上路"><a href="#重新思考-重新上路" class="headerlink" title="重新思考, 重新上路"></a><strong>重新思考, 重新上路</strong></h3><p>苦海无边, 回头是岸, 我既已悟了此道, 便是亡羊补牢, 为时未晚. 失恋的创伤即便谈不上痊愈, 也至少已经结痂了. 偶尔的时候, 我的内心固执地不愿意放下这段往事, 似乎我很酷嘛? 欣赏自己痛苦的状态, 以为这是一种艺术行为, 或是在顾影自怜? 可王小波很早就说过, 自己的痛苦成全不了自己, 但却会成为别人的艺术源泉. 所以我不必与自己过意不去, 如果没有这场恋爱, 也许我会走出另一种完全不同的人生, 可能迷上了网络游戏而不能自拔, 也可能错过了我这位南邮同学, 却在另外一段感情中陷入绝境. 这些都不是真实的我, 该来的总归会来, 挫折与磨炼无可回避.<br>偶尔和其他一些初高中同学交流, 我发现他们好些人现在都过得十分 “幸福”, 在老家三四线小城市里做一个公务员或国企职工, 每天朝九晚五, 不知加班为何物. 收入高的也有七八千, 进展快的已经结婚生子, 开启天伦之乐. 这种生活从某些角度讲可能叫做一眼望到路的尽头, 遭到了很多人的不屑, 但说真的如果让我选择是否向往这种生活, 我恐怕会犹豫: 如果说我不喜欢这种生活, 那是因为我不甘心如此平庸, 不希望自己一辈子只是养家糊口而无所成就; 如果说我向往这种生活, 那是因为它不会占用我的个人时间, 除了周末外每个工作日的晚上也归自己自由支配, 我可以无干扰地做我自己想做的事.<br>什么是我自己想做的事? 现在的我已经不是大学时那个不顾一切, 舍命追求计算机的自己了. 我欣慰得发现, 曾经的爱好, 阅读, 写作, 运动, 其实都没有彻底泯灭, 野火烧不尽, 春风吹又生, 它们只是躲了起来, 在暗中观察我, 期待着我的苏醒. 只要我愿意醒过来, 它们会永远追随我. 我想做的事, 就是找回曾经的那个自己, 真实而自然的自己!<br>“什么是真实? 真实是你看到什么, 听到什么, 做什么, 和谁在一起, 有一种从心灵深处满溢出来的, 不懊恼也不羞耻的平和与喜悦.” 真实是有所成就的前提条件, 不满足这一前提的所谓成就, 是违心与压迫的产物, 它将不会饱含激情与心血, 也就注定逃不出平庸的罗网.<br>而当前的我就像一个标准加工的产品, 计算机科班出生, 毕业后进入著名互联网公司工作, 两年后跳槽, 薪水大幅提升. 如果继续朝这个路线走下去, 再过两年可以考虑去阿里巴巴, 争取一个 P7 的职位. 这是一个 “理想” 的职业发展轨迹, 很多人都在冥冥中被如此安排了命运. 我可以说不吗? 这不是我想要的生活, 如果这种职业攀升路线需要耗费我过多的精力在业务内容上, 我根本不觉得这实现了我的人生价值, 我不想被计算机的世界绑票.<br>其实这并不妨碍我热爱计算机, 只是我的爱好十分广泛, 我不允许自己囿于狭窄的一隅, 却错过盎然多姿的世界! 古今中外, 文学大家的风骨; 沧海桑田, 历史车轮的磅礴; 造化诡谲, 基因破译的秘密; 算法精妙, 人工智能的潜能; 股海沉浮, 商业战场的博弈; 宏观调控, 经济运转的定律…… 说白了, 我今生今世, 发自肺腑想要做的, 想探索的, 想感悟的, 不依赖于某个企业的环境或某个个人的意志, 而是在于综合的这个世界的本身, 这是我个人的价值得以实现的唯一途径.</p><h3 id="过去与未来-愿阳光与我同在"><a href="#过去与未来-愿阳光与我同在" class="headerlink" title="过去与未来: 愿阳光与我同在"></a><strong>过去与未来: 愿阳光与我同在</strong></h3><p>2009 年我上高中, 任职班长, 沉稳自信, 深受同学好评;<br>2010 年负责学校广播台, 被评为优秀学生会干事;<br>2010 年校园合唱比赛, 任指挥, 带领班级拿下年级第一名;<br>2011 年校元旦文艺汇演, 任主持人, 同时自编自谱原创音乐, 穿插表演, 获最佳创意奖;<br>2012 年我上大学, 在学院迎新晚会上参与舞台剧 《霸王别姬》, 主演项羽, 被评为晚会最佳节目;<br>2012 年 10 月 18 日中午 11:28, 我失恋了, 阳光遁入乌云深处, 接着便发生了上述的一切!<br>你想取代我, 我就成为你. 六年一个轮回, 一段修行, 我从绝望中来, 向光明中去. 挫折曾令我沮丧, 命运曾强大到令我生不出改变它的念头. 可是过去的我如此优秀, 凭什么叫我对不堪的当下低头? 我的青春也不过只有这些日子, 还得抓紧时间赶路, 我已经听到了未来的呼唤.</p><h3 id="采月湖畔的浪漫回忆"><a href="#采月湖畔的浪漫回忆" class="headerlink" title="采月湖畔的浪漫回忆"></a><strong>采月湖畔的浪漫回忆</strong></h3><p>入学军训时你的靓影从我左肩划过, 我便知道我将邂逅一段只在文学作品中才描述过的浪漫故事. 我想陪你看书, 也想两年后带你去上海迪士尼变成白雪公主; 我想为你写诗, 也想为你亲自谱一曲专属的浪漫乐章.<br>图书馆有我们坐在一起的背影, 我认真帮你准备学生会入职后的第一份 PPT; 学校餐厅有我们面对面的甜蜜, 无需多贵, 两杯奶茶就足以营造温馨的氛围; 创行中国的答辩现场, 你流畅的思路与犀利的言辞, 无论对手是谁, 在我心中都不及你半分; 我买了你最爱吃的柚子与火龙果, 你爱吃的水果当然也是我爱吃的水果.<br>天色渐晚, 秋风宜人, 你挽着我的手臂坐在了柔软的草地上. 月光朦胧, 如轻薄的衣纱从天而降, 徐徐落在我双掌之间, 你那洁白如玉的手上. 微风拂过, 依偎在我肩上的脸蛋, 被吹乱的秀发迷离了双眼, 采月湖面上波光粼粼, 我心亦泛起阵阵涟漪. 远处旖旎的路灯下, 南师的佳人们入对出双, 而你和我, 只愿在这起霞坡的芳草地上, 同蟋蟀为友, 与蜻蜓为伴, 相与枕藉, 宁愿不觉东方之既白.<br>六年恍如隔世, 漫天的我在空中肆意飘洒, 落在火红的枫叶上, “你” 还在想我吗?</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写出这篇文章, 就意味着我的幼稚, 但若不写这篇文章, 也只不过是将幼稚藏于心底罢了. 敏感脆弱的品性, 使我固执了六年, 而不敢拾起真实的自己, 蓦然回首, 却发现我苦苦寻找的光明, 其实就是自己的影子.&lt;br&gt;伤痛, 迷惘, 绝望, 逃避, 再次面对, 幡然醒悟…… 值得欣慰的是, 无论这个过程多么坎坷而曲折, 这么多年来, 我心灵最深处却始终保留着通往真实自我的火种, 在历经无数的风吹雨打后重新被我拾起, 重又燎起了我内心的草原.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
    
      <category term="思考" scheme="http://zshell.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="人生" scheme="http://zshell.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>linux 重度使用者拿到 MacBook 后的一系列挣扎</title>
    <link href="http://zshell.cc/2018/08/26/life-pc--linux%E9%87%8D%E5%BA%A6%E4%BD%BF%E7%94%A8%E8%80%85%E6%8B%BF%E5%88%B0MacBook%E5%90%8E%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%8C%A3%E6%89%8E/"/>
    <id>http://zshell.cc/2018/08/26/life-pc--linux重度使用者拿到MacBook后的一系列挣扎/</id>
    <published>2018-08-26T07:46:05.000Z</published>
    <updated>2018-09-24T08:45:11.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>新东家发的办公笔记本是 MacBook Pro, 来之前我还觉得挺高大上, 然而真正开始用的时候发现, OS X 对于 linux 用户来说实在是太难于上手了, 甚至感觉比 Windows 系统还不习惯, Windows 好歹从前还是使用过的, OS X 简直就和初学者使用 vim 一样不知所措;</p></blockquote><a id="more"></a><hr><p>关于一些常规而必备的软件 (如 chrome, thunderbird, atom/sublime, jetbrains 系列, jdk 等等), 本文就不再赘述了;</p><h3 id="搞定-sudo-权限"><a href="#搞定-sudo-权限" class="headerlink" title="搞定 sudo 权限"></a><strong>搞定 sudo 权限</strong></h3><p>说来蛋疼的是, 即便已使用 visudo 命令开启了用户的 sudo 权限, OS X 依然不允许修改系统级的目录, 这是 OS X 在 10.11 中引入的 System Integrity Protection (SIP) 特性; 我观察了一下, 差不多除了 /usr/local 这一原本就该属于用户自己管理的目录下之外, 其余的都无法操纵, 切到 root 也不行, 可以说算是另一个阉割版的 admin;<br>所以拿到本子的第一件事就应该是关闭 SIP 特性, 否则后面的操作会显得束手束脚:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机, command + r 进入 rescue 模式</span></span><br><span class="line">csrutil <span class="built_in">disable</span></span><br></pre></td></tr></table></figure></p><p>这样就可以关闭 SIP 特性, 后面就可以以 sudo 权限操纵系统级的目录了;</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a><strong>安装 Homebrew</strong></h3><p>作为 Mac 生态下主流的包管理软件, 安装 Homebrew 是使用 Mac 的程序员必做的事情之一, 否则后面想在命令行装东西可就费劲了;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/<span class="built_in">local</span> –strip 1</span><br></pre></td></tr></table></figure></p><p>如果遇到 <code>Error: Unknown command: install</code>, 则需要更新 Homebrew:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></p><p>这时就体现了完整版 sudo 权限的重要性: <code>brew update</code> 命令需要更新 <code>/usr/local/</code> 下的文件, 如果开启了 SIP 特性, 这个操作就没权限执行了;</p><p>&nbsp;<br>有了 brew 之后, 后面安装与管理各种软件就方便多了; Homebrew 的命令是比较简洁明了的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装与卸载</span></span><br><span class="line">brew install <span class="variable">$package</span></span><br><span class="line">brew uninstall <span class="variable">$package</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">brew list</span><br><span class="line">brew search <span class="variable">$package</span></span><br><span class="line">brew info <span class="variable">$package</span></span><br></pre></td></tr></table></figure></p><h3 id="安装-showsocks-client"><a href="#安装-showsocks-client" class="headerlink" title="安装 showsocks client"></a><strong>安装 showsocks client</strong></h3><p>借助 brew 命令, Mac 下面部署梯子的操作倒还算方便:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install shadowsocks-libev</span><br></pre></td></tr></table></figure></p><p>自定义一个开机启动脚本, 让 mac 每次开机时自动运行 ss-local:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/opt/shadowsocks-libev/bin/ss-local -c /etc/shadowsocks.json &amp;</span><br></pre></td></tr></table></figure></p><h3 id="使用解放鼠标的资源定位器"><a href="#使用解放鼠标的资源定位器" class="headerlink" title="使用解放鼠标的资源定位器"></a><strong>使用解放鼠标的资源定位器</strong></h3><p>目前我了解到的, 这种通过快捷键召唤出来并能够根据关键字定位资源的工具, 大致有三类主流的代表: spotlight, alfred 以及 devonthink;</p><ul><li>mac 本身自带 spotlight, 通过 command + space 召唤出来, 其特点是增量渐进式得搜索各种类型的资源, 可能包括 app, document, image 等, 一边搜索一边展示最新的结果, 速度稍慢;</li><li>我在我的 mac 上安装的是第二个 alfred: alfred 通过 option + space 召唤出来, 并且默认优先搜索 app, 只有当多敲一个空格或单引号时才会搜索 document 等其他类型;<br>这个设计我觉得完全不冗余, 反而是很精妙, 因为它用极其微小的代价 (一个空格/单引号) 就将最频繁与非频繁的资源类型作了隔离, 让最频繁的资源类型以极高的效率被检索到, 而不是像 spotlight 那样全盘通吃却拉低了整体搜索的响应时间;</li><li>第三个是 devonthink: 这个工具的功能更加专注, 它就是一个搜索引擎, 当我们将需要被索引的文件放入 devonthink 作预处理, 往后就可以以极高的效率通过文档内容中的关键字检索到目标文档了;<br>对我来说, 需要被检索的知识与文档我都用专业的云笔记去作归档与备份, 所以我并不额外需要 devonthink 这样的工具了;</li></ul><h3 id="安装-sougoupinyin-代替默认输入法"><a href="#安装-sougoupinyin-代替默认输入法" class="headerlink" title="安装 sougoupinyin 代替默认输入法"></a><strong>安装 sougoupinyin 代替默认输入法</strong></h3><p>苹果自带的中文输入法不是很好用, 中英文切换默认使用 ctrl + space 组合, 十分不方便, 具体在哪里修改设置我也懒得看了; 此时需要下载符合国人习惯的 sougoupinyin, 当然由于搜狗对 mac 的支持比较友好, 仅需一键安装即可, 此处就不用多说了;<br>在输入法方面, 不得不承认 mac 是比 linux (至少是 fedora) 要方便不少的: fedora 上的 sougoupinyin 一直停滞更新, 目前最新版本依然有严重 bug, 我不得不去移植 ubuntu 环境下的 deb 包才能满足我在 fedora 下的使用;</p><h3 id="配置更友好的终端环境"><a href="#配置更友好的终端环境" class="headerlink" title="配置更友好的终端环境"></a><strong>配置更友好的终端环境</strong></h3><p>mac 自带的 terminal 也不是很好用, 不过有第三方强大的替代品可以选择, 我这里选择的一个终端环境的组合是 iTerm2 + oh-my-zsh, 以代替原有的 terminal + bash 的默认组合;<br>首先通过菜单栏更改 iTerm2 为 default terminal;<br>iTerm2 支持各种个性化的配置, 包括终端颜色, 快捷键等, 我这里选择的配色方案是 <a href="https://ethanschoonover.com/solarized/" target="_blank" rel="noopener">solarized</a> 中的 Solarized Dark;<br>接下来是安装 zsh 的全能管家 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># by curl</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line"><span class="comment"># by wget</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure></p><p>oh-my-zsh 的配置文件默认是 ~/.zshrc, 这个文件里有几个关键配置项:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 oh-my-zsh 的核心内容</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">"/Users/zshell/.oh-my-zsh"</span></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br></pre></td></tr></table></figure></p><p>以下为个性化定制:<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定制主题</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br><span class="line"><span class="comment"># 开启语法高亮插件</span></span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"><span class="comment"># 定制插件</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  osx</span><br><span class="line">  docker</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>一般比较漂亮顺眼的两款主题是 <a href="http://blog.ysmood.org/my-ys-terminal-theme/" target="_blank" rel="noopener">ys</a> 和 <a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">agnoster</a>, 在 ZSH_THEME 中可以更换, 如果使用 agnoster, 需要另外安装 <a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf" target="_blank" rel="noopener">Meslo</a> 字体并在 iTerm2 中启用它;<br>关于语法高亮插件, 可以使用 brew 安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p><p>然后在 .zshrc 中 source 下载的 zsh-syntax-highlighting.zsh 脚本即可;<br>&nbsp;<br>与 iTerm2 相关的软件资源我整理到了一个公共目录下, 以方便日后在新的 MacBook 上下载: <a href="https://pan.baidu.com/s/1fQrD1o-jIgkHuvybZEL8AA#list/path=%2Fapps%2Fsoftware%2Fiterm%2B&amp;parentPath=%2Fapps" target="_blank" rel="noopener">software / iterm+</a>;</p><h3 id="熟悉-mac-的按键及其标识"><a href="#熟悉-mac-的按键及其标识" class="headerlink" title="熟悉 mac 的按键及其标识"></a><strong>熟悉 mac 的按键及其标识</strong></h3><p>这其实是个很扯淡的事情: mac 的按键体系与其他传统的笔记本不一致, 它多了一个 command 键, 更改了 delete 键的含义, 少了一些诸如 backspace, page up/down, home/end 等按键, 如此迥异以致很多传统的快捷键在 mac 下都有很大的不同, 有些功能需要依靠按键组合来实现, 让初次接触的人很不习惯;<br>另外 mac 的各个按键有着独特的图像标识, 在一些软件的快捷键设置面板上会频繁出现, 如果不稍作了解, 有很多标识是不太看得懂其象形含义的,  这里我对所有 MacBooK 基础按键的标识作一个整理:</p><table><thead><tr><th style="text-align:center">按键标识</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">⌘</td><td style="text-align:center">Command</td></tr><tr><td style="text-align:center">⇧</td><td style="text-align:center">Shift</td></tr><tr><td style="text-align:center">⌥</td><td style="text-align:center">Option, Alt</td></tr><tr><td style="text-align:center">⌃</td><td style="text-align:center">Control</td></tr><tr><td style="text-align:center">↩</td><td style="text-align:center">Return/Enter</td></tr><tr><td style="text-align:center">⌫</td><td style="text-align:center">Delete</td></tr><tr><td style="text-align:center">⌦</td><td style="text-align:center">向前删除键 (Fn + Delete)</td></tr><tr><td style="text-align:center">↑ / ↓ / ← / →</td><td style="text-align:center">上下左右 箭头</td></tr><tr><td style="text-align:center">⇞ / ⇟</td><td style="text-align:center">Page Up/Down (Fn + ↑/↓)</td></tr><tr><td style="text-align:center">Home / End</td><td style="text-align:center">Fn + ←/→</td></tr><tr><td style="text-align:center">⇥</td><td style="text-align:center">右制表符 (Tab键)</td></tr><tr><td style="text-align:center">⇤</td><td style="text-align:center">左制表符 (Shift+Tab)</td></tr><tr><td style="text-align:center">⎋</td><td style="text-align:center">Escape (Esc)</td></tr></tbody></table><h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a><strong>使用总结</strong></h3><p>我相信从 Windows 迁移到 mac 环境是一件阻力不大的事情, 这也是大部分人的模式, 而且这部分人群的行业分布十分广泛, 软件工程师只是其中一个子集而已; 然而对于一个长期使用 linux PC 的程序员来说, 事情就没那么富有吸引力了: mac 所能给予的生产力与效率, linux 也不遑多让, 另外对于开源软件有信仰的人来说, 这事甚至没有任何商量的余地;<br>但其实我很清楚, 这本质上不过是一个人内心深处的偏见与执念, 长期使用 mac 的人, 让他们转投 linux 阵营也是不可能的事; 即便在 linux 业界之内, 关于 fedora, arch 与 ubuntu 的争论也是从未休止过; 关于 OS X 其实有大量的优点在本文中完全没有被提及, 可能是我觉得不值得花费时间去探索这些东西, 我在工作中所创造的价值完全依托于 linux 主机, 所以我亦使用 linux 作为我个人笔记本的操作系统, 借用这种方式以熟悉, 并更好得理解我的作品在生产环境下的工作原理: 兴许这就是我无可救药的执念……<br>我听说阿里巴巴的办公笔记本发放的是 MacBook Pro 15’, 并且强烈不建议使用自己的笔记本办公, 非要使用的话必须安装各种安全监视与审计软件, 毕竟信息安全是上市公司的头等大事; 这么说无论如何, 我都得慢慢得去适应 mac 环境下的办公模式了, 否则将来因为强烈排斥使用公司统一发放的 MacBook Pro 而拒绝了某公司的 offer, 就有点扯淡了;</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://blog.csdn.net/qq_24283329/article/details/77896380" target="_blank" rel="noopener">ios brew安装记录</a></li><li><a href="https://blog.csdn.net/buyueliuying/article/details/74634712" target="_blank" rel="noopener">OS X 执行命令加了sudo还是提示Operation not permitted</a></li><li><a href="https://blog.csdn.net/qq_24283329/article/details/77896380" target="_blank" rel="noopener">MAC 电脑如何启用root用户</a></li><li><a href="https://www.cr173.com/apple/126928_1.html" target="_blank" rel="noopener">mac sip关闭教程 苹果MAC10.11系统关闭SIP教程</a></li><li><a href="http://www.cnblogs.com/weixuqin/p/7029177.html" target="_blank" rel="noopener">Mac下终端配置(item2 + oh-my-zsh + solarized配色方案)</a></li><li><a href="https://blog.csdn.net/HaoDaWang/article/details/78731098" target="_blank" rel="noopener">Mac 按键标识</a></li><li><a href="http://xclient.info/s/alfred.html?t=ff3019e26174ceb44f3725cfb2282663e6a53526" target="_blank" rel="noopener">Alfred 3.7(938) 效率神器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;新东家发的办公笔记本是 MacBook Pro, 来之前我还觉得挺高大上, 然而真正开始用的时候发现, OS X 对于 linux 用户来说实在是太难于上手了, 甚至感觉比 Windows 系统还不习惯, Windows 好歹从前还是使用过的, OS X 简直就和初学者使用 vim 一样不知所措;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://zshell.cc/categories/life/"/>
    
      <category term="pc" scheme="http://zshell.cc/categories/life/pc/"/>
    
    
      <category term="life:pc" scheme="http://zshell.cc/tags/life-pc/"/>
    
      <category term="MacBook" scheme="http://zshell.cc/tags/MacBook/"/>
    
  </entry>
  
  <entry>
    <title>berkeley db 7.x 压力测试报告</title>
    <link href="http://zshell.cc/2018/08/12/linux-other--berkeley_db7.x%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
    <id>http://zshell.cc/2018/08/12/linux-other--berkeley_db7.x压力测试报告/</id>
    <published>2018-08-12T15:10:04.000Z</published>
    <updated>2018-08-18T06:40:48.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前写过一篇文章 <a href="http://zshell.cc/2018/01/22/linux-other--apache_benchmark_使用笔记">apache benchmark 使用笔记</a>, 介绍了 apache benchmark 的使用及注意事项, 当时我确实是使用 ab 作了一个系统的压力测试; 可惜不够重视, 我在博客里只作了关于 ab 的使用笔记, 却没有将当时压测的结果输出为一份详细报告;<br>这次被我逮到机会了: 最近我在调研一个 KV 数据库 <code>oracle berkeley db</code>, 需要测试其新版本 (7.4.5) 引入堆外内存作为辅助缓存的实际性能; 我详细得记录了本次压力测试的各种细节 (已经对所有涉及公司内部的信息作了脱敏处理), 希望能以此为模板, 当以后有相关的压力测试需要时, 可以从中获得参考价值;</p></blockquote><a id="more"></a><hr><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a><strong>测试环境</strong></h2><p>测试机器的物理配置如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24C</span><br><span class="line">64G</span><br><span class="line">2.7T</span><br></pre></td></tr></table></figure></p><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a><strong>测试内容</strong></h2><p>为了构造大量的随机数据以模拟服务的真实场景, mock 了三个接口如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机写, key 在 (0, xxx] 范围内随机生成, valueSize 指定 key 的大小</span></span><br><span class="line">http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=xxx&amp;valueSize=xxx</span><br><span class="line"><span class="comment"># 随机读, key 在 (0, xxx] 范围内随机生成</span></span><br><span class="line">http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=xxx</span><br><span class="line"><span class="comment"># 随机批量读, key 在 (0, xxx] 范围内随机生成, keyNum 指定批量个数</span></span><br><span class="line">http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=xxx&amp;keyNum=yyy</span><br></pre></td></tr></table></figure></p><p>在各接口中使用当前时间作为随机数发生的 seed, 确保真实随机, 然后使用 apache benchmark 作压力测试:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次总请求, 250 并发, 5s timeout</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 http://<span class="variable">$&#123;remote_url&#125;</span>/random_get</span><br></pre></td></tr></table></figure></p><h3 id="基础指标分析"><a href="#基础指标分析" class="headerlink" title="基础指标分析"></a><strong>基础指标分析</strong></h3><p>使用 ab 收集基础数据:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rt</span></span><br><span class="line">min, mean, median, P90, P99, max</span><br><span class="line"><span class="comment"># 标准差/乖离率</span></span><br><span class="line">stdev</span><br><span class="line"><span class="comment"># failure stat</span></span><br><span class="line">error/exception/timeout</span><br></pre></td></tr></table></figure></p><h3 id="jvm-指标分析"><a href="#jvm-指标分析" class="headerlink" title="jvm 指标分析"></a><strong>jvm 指标分析</strong></h3><p>使用 jstat 采样 jvm gc 状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample</span></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">5.67   0.00  48.74  70.68  98.24     -  15588  1199.695    20   2.865   1202.561</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收集关键 gc 状态指标</span></span><br><span class="line">YGC, YGCT, FGC, FGCT</span><br></pre></td></tr></table></figure><h3 id="堆外内存分析"><a href="#堆外内存分析" class="headerlink" title="堆外内存分析"></a><strong>堆外内存分析</strong></h3><p>堆外内存无法使用 jmap / jstat 观察, 只能用 top 观察;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 100 -H -p <span class="variable">$&#123;vmid&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="控制变量测试计划"><a href="#控制变量测试计划" class="headerlink" title="控制变量测试计划"></a><strong>控制变量测试计划</strong></h2><p>除了计划 E 是专门对比收集器效果的, 其余的测试计划内均使用 ParNew + CMS 的收集器组合, 配置如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=<span class="variable">$&#123;CPU_COUNT&#125;</span></span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSMaxAbortablePrecleanTime=5000</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=80</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure></p><h3 id="计划-A-in-heap-缓存大小控制"><a href="#计划-A-in-heap-缓存大小控制" class="headerlink" title="计划 A: in-heap 缓存大小控制"></a><strong>计划 A: in-heap 缓存大小控制</strong></h3><p>测试环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms=25g</span><br><span class="line">-Xmx=25g</span><br><span class="line">-Xmn=10g</span><br><span class="line">-XX:MaxDirectMemorySize=10g</span><br><span class="line">-Dje.maxOffHeapMemory=10g</span><br></pre></td></tr></table></figure></p><p><strong>A-1: 测试 set</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=9999999&amp;valueSize=5000"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/A-1_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/122/316/1461</td><td style="text-align:center">6/128/352/1708</td><td style="text-align:center">6/125/365/3354</td><td style="text-align:center">ab timeout</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">85/73</td><td style="text-align:center">87/75</td><td style="text-align:center">88/75</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">68.2</td><td style="text-align:center">72.0</td><td style="text-align:center">77.0</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">14/2.998</td><td style="text-align:center">14/4.397</td><td style="text-align:center">16/6.278</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">2/0.589</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>A-2: 测试 get</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=9999999"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/A-2_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">9/32/29/1030</td><td style="text-align:center">8/26/29/1038</td><td style="text-align:center">8/27/29/1218</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">24/24</td><td style="text-align:center">23/24</td><td style="text-align:center">22/21</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">15.8</td><td style="text-align:center">17.8</td><td style="text-align:center">27.8</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">7/1.442</td><td style="text-align:center">6/0.963</td><td style="text-align:center">6/0.907</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>A-3: 测试 mget</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=9999999&amp;keyNum=20"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/A-3_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">8/28/34/4529</td><td style="text-align:center">6/28/31/4804</td><td style="text-align:center">6/27/33/1073</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">34/26</td><td style="text-align:center">32/25</td><td style="text-align:center">25/23</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">2006</td><td style="text-align:center">10907</td><td style="text-align:center">14300</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">139.5</td><td style="text-align:center">29.8</td><td style="text-align:center">24.3</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">26/31.157</td><td style="text-align:center">23/22.947</td><td style="text-align:center">24/4.687</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">2/1.689</td><td style="text-align:center">1/4.243</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>测试小结</strong><br>在当前的测试机器上, 共有 30g 的存量数据; 根据现有的状况, 在计划 A 中选取的几个测试条件, 分别代表了:</p><ul><li>5%: 占用较少的 jvm 堆内存资源;</li><li>10%: 比较充分得使用 jvm 堆内存资源;</li><li>20%: 比较拥挤得争用 jvm 堆内存资源;</li><li>30%: 十分拥挤得争用 jvm 堆内存资源;</li></ul><p>当然, 根据不同机器上的不同数据分布情况, 相应的测试条件也需要调整;<br>从以上测试结果中可以得知: 当各分片 bdb 实例的 in-heap 大小控制在比较高的水平 (20%) 时, 由于数据的 overflow, 将会对整体请求的稳定性造成影响, 产生比较大的乖离率, timeout/error 概率也相应增大; 而当 in-heap 大小控制到更高水平 (30%) 时, 甚至在 250 并发强度下无法正常提供服务, 发生大量 timeout 以及 connection error;<br>综合来说, 这里建议比较充分得使用 jvm 堆内存, 对应测试中的第二项条件 10%;</p><h3 id="计划-B-off-heap-缓存大小控制"><a href="#计划-B-off-heap-缓存大小控制" class="headerlink" title="计划 B: off-heap 缓存大小控制"></a><strong>计划 B: off-heap 缓存大小控制</strong></h3><p>测试环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms=25g</span><br><span class="line">-Xmx=25g</span><br><span class="line">-Xmn=10g</span><br><span class="line">-Dje.maxMemoryPercent=10</span><br></pre></td></tr></table></figure></p><p><strong>B-1: 测试 set</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">    ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=9999999&amp;valueSize=5000"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/B-1_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/122/339/3173</td><td style="text-align:center">7/117/318/1714</td><td style="text-align:center">6/128/352/1708</td><td style="text-align:center">6/131/153/3074</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">85/73</td><td style="text-align:center">83/72</td><td style="text-align:center">87/75</td><td style="text-align:center">89/76</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">71.6</td><td style="text-align:center">69.0</td><td style="text-align:center">78.0</td><td style="text-align:center">75.3</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">14/4.398</td><td style="text-align:center">15/5.051</td><td style="text-align:center">14/4.397</td><td style="text-align:center">15/4.954</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">1/4.243</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>B-2: 测试 get</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=9999999"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/B-2_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">9/25/29/1030</td><td style="text-align:center">8/25/28/1225</td><td style="text-align:center">8/26/29/1038</td><td style="text-align:center">823/28/29/441</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">23/22</td><td style="text-align:center">23/22</td><td style="text-align:center">23/24</td><td style="text-align:center">23/26</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">11</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">371</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">22.5</td><td style="text-align:center">25.8</td><td style="text-align:center">17.8</td><td style="text-align:center">11.6</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">8/1.222</td><td style="text-align:center">7/1.214</td><td style="text-align:center">6/0.963</td><td style="text-align:center">8/1.602</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>B-3: 测试 mget</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=9999999&amp;keyNum=20"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/B-3_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/28/162/1029</td><td style="text-align:center">6/27/145/1342</td><td style="text-align:center">6/28/31/4804</td><td style="text-align:center">6/27/67/1431</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">26/24</td><td style="text-align:center">26/24</td><td style="text-align:center">32/25</td><td style="text-align:center">26/23</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">9011</td><td style="text-align:center">9467</td><td style="text-align:center">10907</td><td style="text-align:center">10875</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">29.1</td><td style="text-align:center">35.5</td><td style="text-align:center">29.8</td><td style="text-align:center">36.8</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">27/3.758</td><td style="text-align:center">26/3.535</td><td style="text-align:center">23/22.947</td><td style="text-align:center">23/3.05</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">2/0.236</td><td style="text-align:center">2/0.236</td><td style="text-align:center">2/1.689</td><td style="text-align:center">2/0.245</td></tr></tbody></table><p><strong>测试小结</strong><br>berkeley db 使用堆外内存作为堆内存 overflow 后 spill to disk 之间的缓冲区; 计划 B 分别选取了四个差异较大的测试条件; 从测试结果中可以得知:<br>分配相对充分的 off-heap 比例作为 disk 缓冲区是有一定的效果的, 在 get 测试和 mget 测试中, 10g 与 20g 的测试组都在 gc 次数与 gc 时间上比 512m 和 1g 的测试组占有优势; 在乖离率方面, 10g 与 20g 的测试组也较 512m 和 1g 测试组较低, 稳定性更加;<br>综合来说, 这里建议分配相对充分的堆外内存 (10g ~ 20g) 作为 disk buffer;</p><h3 id="计划-C-Xmx-Xms-大小控制"><a href="#计划-C-Xmx-Xms-大小控制" class="headerlink" title="计划 C: -Xmx / -Xms 大小控制"></a><strong>计划 C: -Xmx / -Xms 大小控制</strong></h3><p>一般控制 -Xmx 与 -Xms 相同, 同时这里设置 -XX:NewRatio=2;<br>需要注意的是, 在 64 位机器上, 当 jvm 内存超过 32g, 指针压缩 (CompressedOops) 功能将无法生效, 内存使用效率将会降低; 所以无论机器的物理内存有多大, 每个 jvm 实例的 Xmx 都不建议超过 31g;<br>测试环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dje.maxMemoryPercent=10</span><br><span class="line">-XX:MaxDirectMemorySize=10g</span><br><span class="line">-Dje.maxOffHeapMemory=10g</span><br></pre></td></tr></table></figure></p><p><strong>C-1: 测试 set</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=9999999&amp;valueSize=5000"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/C-1_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/123/324/3092</td><td style="text-align:center">6/123/343/3140</td><td style="text-align:center">6/128/352/1708</td><td style="text-align:center">6/138/324/3101</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">83/70</td><td style="text-align:center">86/74</td><td style="text-align:center">87/75</td><td style="text-align:center">94/80</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">26</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">69.0</td><td style="text-align:center">76.1</td><td style="text-align:center">72.0</td><td style="text-align:center">82.3</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">38/4.035</td><td style="text-align:center">19/11.268</td><td style="text-align:center">6/0.963</td><td style="text-align:center">12/6.99</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">2/0.202</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>C-2: 测试 get</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=9999999"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/C-2_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">9/25/28/2819</td><td style="text-align:center">8/25/28/1077</td><td style="text-align:center">8/26/29/1038</td><td style="text-align:center">10/25/28/1429</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">22/22</td><td style="text-align:center">22/22</td><td style="text-align:center">23/24</td><td style="text-align:center">22/22</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">368</td><td style="text-align:center">539</td><td style="text-align:center">112</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">45.1</td><td style="text-align:center">17.7</td><td style="text-align:center">17.8</td><td style="text-align:center">18.8</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">17/1.912</td><td style="text-align:center">12/1.154</td><td style="text-align:center">14/4.397</td><td style="text-align:center">5/1.206</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">1/1.934</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>C-3: 测试 mget</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=9999999&amp;keyNum=20"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/C-3_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ je.maxMemoryPercent</th><th style="text-align:center">5%</th><th style="text-align:center">10%</th><th style="text-align:center">20%</th><th style="text-align:center">30%</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/28/102/1195</td><td style="text-align:center">6/29/140/1264</td><td style="text-align:center">6/28/31/4804</td><td style="text-align:center">6/28/159/1344</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">27/25</td><td style="text-align:center">27/25</td><td style="text-align:center">32/25</td><td style="text-align:center">28/25</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">6125</td><td style="text-align:center">9410</td><td style="text-align:center">1090</td><td style="text-align:center">7670</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">28.8</td><td style="text-align:center">28.7</td><td style="text-align:center">29.8</td><td style="text-align:center">38.1</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">66/4.818</td><td style="text-align:center">32/3.579</td><td style="text-align:center">23/22.947</td><td style="text-align:center">20/5.442</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">4/0.197</td><td style="text-align:center">2/0.202</td><td style="text-align:center">2/1.689</td><td style="text-align:center">2/0.469</td></tr></tbody></table><p><strong>测试小结</strong><br>此次升级 bdb 版本的重要目的就是使用堆外内存, 降低堆内存, 从而降低 gc 的压力; 在计划 C 中选取了不同的 Xmx, 从测试结果中可以得知:<br>较高的堆内存 (30g) 虽然没有明显的 gc 压力, 但是在乖离率, max rt 等方面相比中等内存 (20g, 25g) 有增加; 另外, 较低的堆内存 (10g) 由于可用内存太少, 可以看出存在频繁的 gc, 无论是 young gc 还是 old gc, 都明显高于其他测试组;<br>综合来说, 这里建议分配适当的堆内存空间 (20g ~ 25g) 作为 Xmx;</p><h3 id="计划-D-bdb-版本对比"><a href="#计划-D-bdb-版本对比" class="headerlink" title="计划 D: bdb 版本对比"></a><strong>计划 D: bdb 版本对比</strong></h3><p>选取对比的两个目标版本为: 6.4.25 vs 7.4.5;<br>测试环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms=25g</span><br><span class="line">-Xmx=25g</span><br><span class="line">-Xmn=10g</span><br><span class="line">-Dje.maxMemoryPercent=10</span><br><span class="line">-XX:MaxDirectMemorySize=30g</span><br><span class="line">-Dje.maxOffHeapMemory=10g</span><br></pre></td></tr></table></figure></p><p><strong>注意: 当 bdb 版本降为 6.4.25 时, 其性能已支撑不了前面三个测试计划中的 250 并发量, 频繁超时, 无法收集到有效数据; 经过多次调节, 确定将并发数降低到 50 方可收集到有效数据;</strong></p><p><strong>D-1: 测试 set</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 50 万次请求, 50 个并发</span></span><br><span class="line">ab -n 1000000 -c 50 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=9999999&amp;valueSize=5000"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/D-1_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ version</th><th style="text-align:center">6.4.25</th><th style="text-align:center">7.4.5</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/24/40/755</td><td style="text-align:center">6/24/40/1015</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">17/15</td><td style="text-align:center">17/15</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">13.5</td><td style="text-align:center">13.4</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">7/2.739</td><td style="text-align:center">7/2.621</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>D-2: 测试 get</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 50 万次请求, 50 个并发</span></span><br><span class="line">ab -n 500000 -c 50 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=9999999"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/D-2_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ version</th><th style="text-align:center">6.4.25</th><th style="text-align:center">7.4.5</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/8/8/1077</td><td style="text-align:center">6/8/8/1130</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">7/7</td><td style="text-align:center">7/7</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">12.6</td><td style="text-align:center">10.9</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">3/0.604</td><td style="text-align:center">4/0.849</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>D-3: 测试 mget</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 50 万次请求, 50 个并发</span></span><br><span class="line">ab -n 500000 -c 50 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=9999999&amp;keyNum=20"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/D-3_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ version</th><th style="text-align:center">6.4.25</th><th style="text-align:center">7.4.5</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/8/9/510</td><td style="text-align:center">6/8/9/1068</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">8/7</td><td style="text-align:center">8/7</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">9.2</td><td style="text-align:center">12.0</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">8/1.561</td><td style="text-align:center">8/1.049</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">0/0</td></tr></tbody></table><p><strong>测试小结</strong><br>从测试结果来看, 50 并发量的请求压力下, 6.4.25 与 7.4.5 版本没有存在明显的差距; 但是在更高的并发量下, 6.4.25 版本的 berkeley db 根本扛不住;<br>所以这里毫无疑问, 7.4.5 版本的 berkeley db 是优于 6.4.25 版本的;</p><h3 id="计划-E-收集器对比"><a href="#计划-E-收集器对比" class="headerlink" title="计划 E: 收集器对比"></a><strong>计划 E: 收集器对比</strong></h3><p>最后是关于收集器的对比; 考虑到 G1 对于大内存 (大于 16g) 的延时管理较其他收集器有优势, 这里也需要就收集器作一些对比测试;<br>两个收集器的选项对比如下:<br>ParNew + CMS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=<span class="variable">$&#123;CPU_COUNT&#125;</span></span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:+CMSClassUnloadingEnabled</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=80</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure></p><p>G1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:+G1SummarizeConcMark</span><br></pre></td></tr></table></figure></p><p>测试环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms=25g</span><br><span class="line">-Xmx=25g</span><br><span class="line">-Xmn=10g</span><br><span class="line">-Dje.maxMemoryPercent=10</span><br><span class="line">-XX:MaxDirectMemorySize=30g</span><br><span class="line">-Dje.maxOffHeapMemory=10g</span><br></pre></td></tr></table></figure></p><p><strong>E-1: 测试 set</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_set?keyRange=9999999&amp;valueSize=5000"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/E-1_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ collector</th><th style="text-align:center">CMS</th><th style="text-align:center">G1</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/128/352/1708</td><td style="text-align:center">ab timeout</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">87/75</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">0</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">72.0</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">14/4.397</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>E-2: 测试 get</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_get?keyRange=9999999"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/E-2_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ collector</th><th style="text-align:center">CMS</th><th style="text-align:center">G1</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">8/26/29/1038</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">23/24</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">2</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">17.8</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">6/0.963</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">0/0</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>E-3: 测试 mget</strong><br>测试命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 万次请求, 250 个并发</span></span><br><span class="line">ab -n 1000000 -c 250 -s 5 <span class="string">"http://<span class="variable">$&#123;remote_url&#125;</span>/random_mget?keyRange=9999999&amp;keyNum=20"</span></span><br><span class="line">sudo -u www jstat -gcutil -h 10 <span class="variable">$&#123;vmid&#125;</span> 1000 | tee /tmp/jstat_collect/E-3_X</span><br></pre></td></tr></table></figure></p><p>测试结果:</p><table><thead><tr><th style="text-align:center">metrics \ collector</th><th style="text-align:center">CMS</th><th style="text-align:center">G1</th></tr></thead><tbody><tr><td style="text-align:center">RT (min/P90/P99/max) (ms)</td><td style="text-align:center">6/28/31/4804</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">RT (mean/median) (ms)</td><td style="text-align:center">32/25</td><td style="text-align:center">8/7</td></tr><tr><td style="text-align:center">error/timeout</td><td style="text-align:center">10907</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">stdev/bias</td><td style="text-align:center">29.8</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">YGC/YGCT (s)</td><td style="text-align:center">23/22.947</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">FGC/FGCT (s)</td><td style="text-align:center">2/1.689</td><td style="text-align:center">/</td></tr></tbody></table><p><strong>测试小结</strong><br>可惜了, 我 retry 了几次, 使用 G1 gc, ab 都在途中 timeout 了; jstat 显示 G1 的 young gc 经历了一个非常长的时间:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT  </span><br><span class="line">0.00 100.00  94.87  47.44  98.45  96.54     12    6.923     0    0.000    6.923</span><br><span class="line">0.00 100.00  94.87  47.44  98.45  96.54     12    6.923     0    0.000    6.923</span><br><span class="line">0.00 100.00   2.89  50.92  98.46  96.54     12   14.315     0    0.000   14.315</span><br><span class="line">0.00 100.00   2.97  50.92  98.46  96.54     12   14.315     0    0.000   14.315</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT  </span><br><span class="line">0.00 100.00  94.87  50.92  98.46  96.54     13   14.315     0    0.000   14.315</span><br><span class="line">0.00 100.00  94.87  50.92  98.46  96.54     13   14.315     0    0.000   14.315</span><br><span class="line">0.00 100.00   2.14  55.58  98.29  96.54     13   25.692     0    0.000   25.692</span><br><span class="line">0.00 100.00   2.21  55.58  98.29  96.54     13   25.692     0    0.000   25.692</span><br></pre></td></tr></table></figure><p>我对 G1 的了解还是不够深入, 可能当前的场景比较特殊, 需要作定制化的调参, 之前使用 G1 都是只加 <code>-XX:+UseG1GC</code> 和 <code>-XX:+G1SummarizeConcMark</code> 两个参数, 其余的优化都交给 jvm 了, 然而对于今天的场景这可能不够用了, 这个需要另行研究了;</p><h2 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a><strong>测试总结</strong></h2><p>本次测试采用 ab + jstat 组合的方式同时采集测试数据, ab 用于反映系统表面的性能指标, jstat 用于反映系统的 gc 状态, 并进而反映隐藏在表面之下的系统性能问题或者服务潜力;<br>本次测试并没有作极限测量 (不断增大并发直至压挂为止), 而是根据当前的调用状况取了一个留有适当 buffer 的并发量, 从测试结果中可以间接得计算当前服务能承载的 TPS;<br>根据测试的结果, 7.4.5 版本的 berkeley db 优于 6.4.25 版本的 berkeley db, 其在并发承受能力上存在明显优势;<br>在收集器选择上, 暂时还是使用 CMS 比较稳妥, G1 可能遇到了特殊的情况, 需要后续研究调优的方法;<br>在使用 7.4.5 版本的 berkeley db 时, 建议作如下内存配置组合, 以达到较好的使用效果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms= 20g ~ 30g</span><br><span class="line">-Xmx= 20g ~ 30g</span><br><span class="line"></span><br><span class="line">-Dje.maxMemoryPercent= <span class="variable">$&#123;Xmx&#125;</span> * 80% / <span class="variable">$&#123;bdb_shard_number&#125;</span></span><br><span class="line">-XX:MaxDirectMemorySize= (<span class="variable">$&#123;machine_total_memory&#125;</span> - <span class="variable">$&#123;Xmx&#125;</span>) * 80%</span><br><span class="line">-Dje.maxOffHeapMemory= <span class="variable">$&#123;MaxDirectMemorySize&#125;</span> / <span class="variable">$&#123;bdb_shard_number&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前写过一篇文章 &lt;a href=&quot;http://zshell.cc/2018/01/22/linux-other--apache_benchmark_使用笔记&quot;&gt;apache benchmark 使用笔记&lt;/a&gt;, 介绍了 apache benchmark 的使用及注意事项, 当时我确实是使用 ab 作了一个系统的压力测试; 可惜不够重视, 我在博客里只作了关于 ab 的使用笔记, 却没有将当时压测的结果输出为一份详细报告;&lt;br&gt;这次被我逮到机会了: 最近我在调研一个 KV 数据库 &lt;code&gt;oracle berkeley db&lt;/code&gt;, 需要测试其新版本 (7.4.5) 引入堆外内存作为辅助缓存的实际性能; 我详细得记录了本次压力测试的各种细节 (已经对所有涉及公司内部的信息作了脱敏处理), 希望能以此为模板, 当以后有相关的压力测试需要时, 可以从中获得参考价值;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zshell.cc/categories/linux/"/>
    
      <category term="other" scheme="http://zshell.cc/categories/linux/other/"/>
    
    
      <category term="jvm:gc" scheme="http://zshell.cc/tags/jvm-gc/"/>
    
      <category term="linux:other" scheme="http://zshell.cc/tags/linux-other/"/>
    
      <category term="linux:perf" scheme="http://zshell.cc/tags/linux-perf/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 相关知识全梳理</title>
    <link href="http://zshell.cc/2018/08/03/jdk--ThreadLocal%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%85%A8%E6%A2%B3%E7%90%86/"/>
    <id>http://zshell.cc/2018/08/03/jdk--ThreadLocal相关知识全梳理/</id>
    <published>2018-08-03T09:30:03.000Z</published>
    <updated>2018-08-05T09:32:13.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两年前在老东家, 我于 InheritableThreadLocal 上踩过一次坑, 可惜当时坑不算深, 就没有把相关的知识点总结下来; 结果两年后的今天我在新东家又遇到了类似问题, 似曾相识却又记不太清楚具体的情况了; 所以这一次一定要认真总结一下 (本文代码基于 jdk 1.8);</p></blockquote><a id="more"></a><hr><h2 id="原生-ThreadLocal-的使用注意点"><a href="#原生-ThreadLocal-的使用注意点" class="headerlink" title="原生 ThreadLocal 的使用注意点"></a><strong>原生 ThreadLocal 的使用注意点</strong></h2><h3 id="线程关联的原理"><a href="#线程关联的原理" class="headerlink" title="线程关联的原理"></a><strong>线程关联的原理</strong></h3><p>ThreadLocal 并不是一个独立的存在, 它与 Thread 类是存在耦合的, java.lang.Thread 类针对 ThreadLocal 提供了如下支持:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>每个线程都将自己维护一个 <code>ThreadLocal.ThreadLocalMap</code> 类在上下文中; 所以, ThreadLocal 的 set 方法其实是将 target value 放到当前线程的 ThreadLocalMap 中, 而 ThreadLocal 类自己仅仅作为该 target value 所对应的 key:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法也是类似的道理, 从线程的 ThreadLocalMap 中获取以当前 ThreadLocal 为 key 对应的 value:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123; </span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是, 如果没有 set 过 value, 此处 get() 将返回 null, 不过 initialValue() 方法是一个 protected 方法, 所以子类可以重写逻辑实现自定义的初始默认值;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述: ThreadLocal 实现线程关联的原理是与 Thread 类绑定, 将数据存储在对应 Thread 的上下文中;</p><h3 id="使用中的注意点"><a href="#使用中的注意点" class="headerlink" title="使用中的注意点"></a><strong>使用中的注意点</strong></h3><p>ThreadLocal 中主要有两个使用中需要注意的地方;</p><h4 id="1-谨防-ThreadLocal-导致的内存泄露和-OOM"><a href="#1-谨防-ThreadLocal-导致的内存泄露和-OOM" class="headerlink" title="(1) 谨防 ThreadLocal 导致的内存泄露和 OOM"></a><strong>(1) 谨防 ThreadLocal 导致的内存泄露和 OOM</strong></h4><p>讨论这个问题之前, 需要先介绍一下 ThreadLocal.ThreadLocalMap 类中维护了的一个自定义数据结构 Entry, 其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    </span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是, Entry 类继承了弱引用 <code>WeakReference</code>, 更具体的说, Entry 中的 key (ThreadLocal 类型) 使用弱引用, value 依旧使用强引用;</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for <code>keys</code>. </p></blockquote><p><strong>这其实是一个令初学者感到困惑的设计</strong>:<br>假设 Entry 不继承 WeakReference, 令 key 也使用强引用, 那么结合上一节的内容, 只要该 thread 不退出, 通过 Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; key 这条引用链, 该 key 就可以一直与 gc root 保持连通; 这时即便在外部这个 key 对应的 threadLocal 已经没有有效引用链了, 但只要该 thread 不退出, jvm 依旧会判定该 threadlocal 不可回收;<br>于是尴尬的事情发生了: 由于 ThreadLocal.ThreadLocalMap 这个内部类没有对外暴露 public 方法, 在 Thread 类里面 ThreadLocal.ThreadLocalMap 也是 package accessible 的, 这意味着我们已经没有任何方法访问到该 key 对应的 value 了, 可它就是无法被回收, 这便是一个典型的内存泄露;<br>而如果使用 WeakReference 这个问题就解决了: 当该 key 对应的 threadlocal 在外部已经失效后, 便仅存在 thread 里的 weak reference 指向它, 下次 gc 时这个 key 就会被回收掉;<br>针对这一特性, ThreadLocal.ThreadLocalMap 也配套了与之相适应的内部清理方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>; </span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>; </span><br><span class="line">    size--; </span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e; </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123; </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123; </span><br><span class="line">            e.value = <span class="keyword">null</span>; </span><br><span class="line">            tab[i] = <span class="keyword">null</span>; </span><br><span class="line">            size--; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123; </span><br><span class="line">                tab[i] = <span class="keyword">null</span>; </span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该方法里, 除了清理指定下标 staleSlot 的 entry 外, 还会遍历整个 entry table, 当发现有 key 为 null 时, 就会触发 rehash 压缩整个 table, 以达到清理的作用;<br>下面就要提到这里的一个隐藏的坑, ThreadLocal 并没有配合使用 ReferenceQueue 来监听已经回收的 key 以实现自动回调 expungeStaleEntry 方法清理空间的功能; 所以 threadlocal 实例是回收了, 但是引用本身还在, 其所对应的 value 也就还在:</p><blockquote><p>However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p></blockquote><p>实际上, expungeStaleEntry 方法是被安插到了 ThreadLocal.ThreadLocalMap 中的 get, set, remove 等方法中, 并被 ThreadLocal 的 get, set, remove 方法间接调用, 必须显式得调用这些方法, 才能主动式地清理空间;<br>在某些极端场景下, 如果某些 threadlocal 设置的 value 是大对象, 而所涉及的 thread 却没来得及在 threadlocal 被 gc 前作 remove, 再加上之后也没有什么其他 threadlocal 去作 get / set 操作, 那这些大对象是没机会被回收的, 这将造成严重的内存泄露甚至是 OOM; <strong>所以使用 ThreadLocal 要谨记一点: 用完主动 remove, 主动释放内存, 而且是放在 finally 块里面 remove, 以确保执行;</strong><br>在很多系统中, 我们会定义一个 static final 的全局 ThreadLocal, 这样其实就不存在 threadlocal 被回收的情况了, 上面说的 WeakReference 机制也将效用有限, 这种环境下我们就更加需要用完后主动作 remove 了;</p><h4 id="2-谨防线程复用组件下的-value-串位"><a href="#2-谨防线程复用组件下的-value-串位" class="headerlink" title="(2) 谨防线程复用组件下的 value 串位"></a><strong>(2) 谨防线程复用组件下的 value 串位</strong></h4><p>在下一节中我还会继续讲到 value 串位的问题; 这一节所讲的串位与下一节相比, 有相似之处也有不同的问题场景; 与此同时, 这一节的串位与上一小节的内容也有一丝关联;<br>通常而言, 我们的代码总是跑在应用容器里, 如 tomcat, jetty, 或者是 dubbo 这样的服务框架内; 这些基础组件都有一个共性: 线程池化复用; 在这种场景下, 线程被线程池托管, 在整个应用的生命周期中, 这些 worker 线程往往是不会轻易退出的;<br>试想一种极端场景: 在一个处理线程内, 我们条件性得 (并非每次都会) 使用 ThreadLocal.set 方法设置一个 value, 然后在后续逻辑中又使用 ThreadLocal.get 方法获取该值; 一个处理线程在上一个任务执行结束之前未作 ThreadLocal.remove 清理 value, 刚巧这个线程在接手下一个任务时未满足条件, 没有调用 ThreadLocal.set 方法设置 value, 此时它所绑定的是上一个任务的 value, 在后面调用 ThreadLocal.get 时, 拿到的就是串位的数据了;<br><strong>这也再一次提醒我们: 使用 ThreadLocal, 在逻辑处理完后, 一定要作 remove</strong>;</p><h2 id="InheritableThreadLocal-的特点及其使用问题"><a href="#InheritableThreadLocal-的特点及其使用问题" class="headerlink" title="InheritableThreadLocal 的特点及其使用问题"></a><strong>InheritableThreadLocal 的特点及其使用问题</strong></h2><p>首先要说的是, 上文所讲的 ThreadLocal 的问题与注意点, 对 InheritableThreadLocal 都是成立的, 这里便不再赘述;<br>与 ThreadLocal 类似, InheritableThreadLocal 类也不是独立存在的, Thread 类针对 InheritableThreadLocal 作了如下支持:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>只是, InheritableThreadLocal 要额外实现子线程传递 threadlocal 的任务, 所以 Thread 类在构造方法中还提供了额外的支持以将父线程的 ThreadLocalMap 传递给子线程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要说的是 InheritableThreadLocal 在线程复用组件下的串位问题;<br>上一小节所讲的 ThreadLocal 的 value 串位问题, 对于 InheritableThreadLocal 来说也是存在的, 这点自不必说; 然对于 InheritableThreadLocal 所提供的额外功能 父子线程传递 value 来说, 还有一种线程复用场景, 会遇到类似的坑;<br>在 jdk 1.5 之前我们没有线程池的时候, 子线程的创建都是手工及时完成的, 那种场景下父子线程的关系是唯一绑定的, 绝对不会出现 value 串位的问题; 然而 Doug Lea 大神开发了 ThreadPoolExecutor, 这彻底改变了我们使用多线程的习惯, 它不仅仅在各种容器中出现, 我们的日常代码中凡涉及多线程的地方, 大多也会采用线程池的方式实现;<br>那么问题来了: 在线程池中, worker 线程是被复用的, worker 线程的父线程是谁并没有人关心, 反正 worker 线程的父线程大多数都比 worker 线程本身要短命许多; 而线程的初始化只发生在其创建的时候, 根据上面的内容, InheritableThreadLocal 传递 value 只发生在子线程初始化的时候, 也就是线程刚创建的时候; 所以, 往线程池中提交任务的时候, 除非是线程池刚好创建了一个新线程, 才能顺利得将 value 传递下去, 否则大多数时候都只是复用已经存在的线程, 那线程中的 value 早已不是当前线程想要传递的值;</p><h3 id="改进-InheritableThreadLocal-的方案"><a href="#改进-InheritableThreadLocal-的方案" class="headerlink" title="改进 InheritableThreadLocal 的方案"></a><strong>改进 InheritableThreadLocal 的方案</strong></h3><p>InheritableThreadLocal value 串位问题的根本原因在于它依赖 Thread 类本身的机制传递 value, 而 Thread 类由于其于线程池内 “复用存在” 的形式而导致 InheritableThreadLocal 的机制失效; 所以针对 InheritableThreadLocal 的改进, 突破点就在于如何摆脱对 Thread 类的依赖;<br>现在业界内比较好的解决思路是将对 Thread 类的依赖转移为对 Runnable / Callable 的依赖, 因为提交任务时 Runnable / Callable 是实时构造出来的, 父线程可以在其构造之时将 value 植入其中;</p><p>下面以阿里为例, 介绍一种典型的实现; 阿里巴巴开源了其对 InheritableThreadLocal 的改进方案: <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">alibaba/transmittable-thread-local</a>;<br>纵观其源码, TransmittableThreadLocal 的核心设计之一在于其自己维护了一个静态全局的 holder, 存储了所有的 TransmittableThreadLocal 实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里的一个设计细节是, 其使用 WeakHashMap 作为存储 TransmittableThreadLocal 实例的容器; 这里与上文所讲的 ThreadLocal.ThreadLocalMap.Entry 使用 WeakReference 作为 key 的原理是类似的, 可以便捷得发现已经无效的 threadlocal, 而且 WeakHashMap 使用了 ReferenceQueue 去监听 key 的 gc 情况, 不用像 ThreadLocal 那样每次需要遍历全表以寻找 stale entries;<br>同时, TransmittableThreadLocal 提供一个 copy() 方法实时复制所有 TransmittableThreadLocal 实例及其在当前线程的 value:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copy() &#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copy = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">        copy.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TransmittableThreadLocal 的另一个核心设计是它封装了自己的 Runnable 和 Callable; 以其封装的 TtlRunnable 为例, 其提供了一个 private 类型的构造器:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.copiedRef = <span class="keyword">new</span> AtomicReference&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;&gt;(TransmittableThreadLocal.copy());</span><br><span class="line">    <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现, 在 TtlRunnable 构造之初, 除了包装原始的 Runnable 之外, 其复制了当前线程下所有的 TransmittableThreadLocal 实例及其对应的 value, 放到了一个 AtomicReference 包装的 map 之中, 这样就完成了由父线程向 Runnable 的 value 传递;<br>下面是最关键的 run() 方法的处理:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copied = copiedRef.get();</span><br><span class="line">    <span class="comment">// 非核心逻辑已省略</span></span><br><span class="line">    ......</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = TransmittableThreadLocal.backupAndSetToCopied(copied);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TransmittableThreadLocal.restoreBackup(backup);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到父线程所有的 threadlocal -&gt; value 键值对后, 需要将其一一设置到自己的 ThreadLocal 中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupAndSetToCopied(Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; copied) &#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();</span><br><span class="line">         iterator.hasNext(); ) &#123; </span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line">        backup.put(threadLocal, threadLocal.get());</span><br><span class="line">        <span class="keyword">if</span> (!copied.containsKey(threadLocal)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 将 runnable 携带的父线程 threadlocal -&gt; value 键值对, 真正用 ThreadLocal.set 将 value 设置到子线程中去</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; entry : copied.entrySet()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal&lt;Object&gt;) entry.getKey();</span><br><span class="line">        threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;   </span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来在调用原始 Runnable 的 run() 方法时, 便能够顺利 get 到父线程的 value 了;</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul><li><a href="https://majiaji.coding.me/2017/03/27/threadLocal-WeakReference和内存泄漏的思考" target="_blank" rel="noopener">ThreadLocal WeakReference和内存泄漏的思考</a></li><li><a href="https://hongjiang.info/java-referencequeue/" target="_blank" rel="noopener">话说ReferenceQueue</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;两年前在老东家, 我于 InheritableThreadLocal 上踩过一次坑, 可惜当时坑不算深, 就没有把相关的知识点总结下来; 结果两年后的今天我在新东家又遇到了类似问题, 似曾相识却又记不太清楚具体的情况了; 所以这一次一定要认真总结一下 (本文代码基于 jdk 1.8);&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://zshell.cc/categories/jdk/"/>
    
    
      <category term="jdk" scheme="http://zshell.cc/tags/jdk/"/>
    
      <category term="面试考点" scheme="http://zshell.cc/tags/%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>openssh-client 相关内容梳理</title>
    <link href="http://zshell.cc/2018/07/17/linux-ssh--openssh-client%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://zshell.cc/2018/07/17/linux-ssh--openssh-client相关内容梳理/</id>
    <published>2018-07-17T05:13:43.000Z</published>
    <updated>2018-08-05T11:58:39.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ssh 相关的命令是日常开发中基础中的基础, 乃是登陆机器操作必不可少的过程; 但是越是寻常, 可能越容易疏于整理总结; 本文就从 openssh-client 着手, 总结一下 .ssh 目录, ssh 相关命令, 以及相关配置文件的使用;</p></blockquote><a id="more"></a><hr><h2 id="ssh-目录"><a href="#ssh-目录" class="headerlink" title=".ssh 目录"></a><strong>.ssh 目录</strong></h2><p>.ssh 目录对权限的要求是比较苛刻的, 毕竟涉及到了私密信息的安全问题; 一般来说, .ssh 下各目录的权限要求如下 (这里只考虑使用 rsa 算法而不考虑 dsa, ecdsa 等其他非主流的加密算法):</p><ol><li>.ssh 目录自己的权限是 700;</li><li>id_rsa 的目录权限是 600 (强制要求);</li><li>id_rsa.pub 的目录权限一般为 644 (这个没有特殊要求);</li><li>authorized_keys 的目录权限是 600 (强制要求);</li><li>known_hosts 的目录权限一般为 644 (这个没有特殊要求);</li></ol><p>以下是一个直观的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -al .ssh/</span><br><span class="line">drwx------ 2 zshell.zhang qunarops    76 Dec 25 13:27 .</span><br><span class="line">drwx------ 4 zshell.zhang qunarops    94 Dec 25 14:50 ..</span><br><span class="line">-rw------- 1 zshell.zhang qunarops 12997 Dec 25 15:38 authorized_keys</span><br><span class="line">-rw------- 1 zshell.zhang qunarops  1679 Dec 25 11:55 id_rsa</span><br><span class="line">-rw-r--r-- 1 zshell.zhang qunarops   407 Dec 25 11:55 id_rsa.pub</span><br><span class="line">-rw-r--r-- 1 zshell.zhang qunarops  7931 Dec 25 14:02 known_hosts</span><br></pre></td></tr></table></figure></p><p>一般来说, id_rsa 是私钥, id_rsa.pub 是公钥, 公钥与私钥的命名只是约定俗成, 没有强制规定, 可以自定义; 但自定义之后要使用特定的私钥登陆就需要在命令中使用参数指定, 具体请见下一小节;<br>还有一点需要说明的是, 这四类文件虽然都默认存在于用户家目录下的 .ssh/ 目录中, 但对于同一台主机上的同一个用户, 这四个文件并不都会同时出现,  如果真的同时出现了, authorized_keys 与 id_rsa, known_hosts 中的内容也不会有什么关联; 关于 authorized_keys 和 known_hosts 的具体说明, 请见下文;</p><h3 id="authorized-keys"><a href="#authorized-keys" class="headerlink" title="authorized_keys"></a><strong>authorized_keys</strong></h3><p>authorized_keys 记录了允许以当前用户登陆该主机的所有公钥, 但凡一个登陆请求的私钥与 authorized_keys 中的公钥相匹配, 则此次登陆成功; 所以, authorized_keys 并非用于 openssh-client, 而是 server 端的 sshd, 这也是上文所说的: 即便 authorized_keys 与 id_rsa 共存于一个 .ssh 目录下, 两者在内容上也是独立的, 前者是校验别人登陆到本机器的, 而后者是用于从本机器登陆其他主机的;<br>在日常运维值班中, 有一个比较频繁的事情便是机器权限申请的审核与开通, 这里面的操作就涉及到 authorized_keys 的更新; 通常我们会使用自动化运维工具 (例如 saltstack, ansible) 在目标主机上执行相关的逻辑:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">useradd -g <span class="variable">$&#123;user_group&#125;</span> -d <span class="variable">$&#123;user_dir&#125;</span>/<span class="variable">$&#123;user_name&#125;</span> <span class="variable">$user_name</span></span><br><span class="line"><span class="comment"># 将公钥写入目标主机对应用户的 authorized_keys 文件</span></span><br><span class="line">wget -O <span class="variable">$&#123;user_dir&#125;</span>/<span class="variable">$&#123;user_name&#125;</span>/.ssh/authorized_keys http://user_query_service_url/<span class="variable">$&#123;user_name&#125;</span>/id_rsa.pub</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="known-hosts"><a href="#known-hosts" class="headerlink" title="known_hosts"></a><strong>known_hosts</strong></h3><p>对于最后一个 known_hosts, 其主要用于 openssh-client 对每次登陆的主机的 host key 作校验; 主机 host key 的构成在 <code>man sshd</code> 中有如下介绍:</p><blockquote><p>Each line in these files contains the following fields: hostnames, bits, exponent, modulus, comment.  The fields are separated by spaces.</p></blockquote><p>host key 中存储了 hostname, ip 等内容, 并作了哈希编码; 当 openssh-client 试图连接一个主机时:</p><ul><li>如果在 known_hosts 中不存在该主机的 host key 信息, 则会告知使用者从未连接过该主机, 并确认是否要连接:</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host '10.64.0.11 (10.64.0.11)' can't be established.</span><br><span class="line">RSA key fingerprint is SHA256:<span class="number">3</span>O+bKYBXKHcYLBbltbuzu8dJbWaX42QHvkKeyABTyqU.</span><br><span class="line">RSA key fingerprint is MD5:ff:<span class="number">3f</span>:<span class="number">57</span>:<span class="number">5</span>c:<span class="number">54</span>:<span class="number">39</span>:<span class="number">8</span>c:<span class="number">71</span>:<span class="number">50</span>:<span class="number">71</span>:aa:bf:<span class="number">1</span>a:<span class="number">6</span>e:a1:<span class="number">0f</span>.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ul><li>如果在 known_hosts 中存在该主机, 并且 ip 等信息并未发生变化, 则校验通过;</li><li>如果在 known_hosts 中存在该主机, 但是 ip 等信息发生了变化, 则会打印类似如下的 <code>中间人攻击</code> 告警信息:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is</span><br><span class="line">ad:12:0a:af:77:09:af:b0:65:16:9a:0a:04:57:2e:f1.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key <span class="keyword">in</span> /home/zshell.zhang/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending key <span class="keyword">in</span> /home/zshell.zhang/.ssh/known_hosts:96</span><br><span class="line">Password authentication is disabled to avoid man-in-the-middle attacks.</span><br><span class="line">Keyboard-interactive authentication is disabled to avoid man-in-the-middle attacks.</span><br><span class="line">Agent forwarding is disabled to avoid man-in-the-middle attacks.</span><br><span class="line">X11 forwarding is disabled to avoid man-in-the-middle attacks.</span><br></pre></td></tr></table></figure><p>其实, 在公司的内网环境中, 大可不必考虑中间人攻击的可能, 倒是日常运维操作致使主机 ip 地址改变的情况时有发生, 所以对于这种提示, 只需要更新 known_hosts 文件, 删除对应的 host key 即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f <span class="string">"/home/zshell.zhang/.ssh/known_hosts"</span> -R l-xx1.ops.cn1</span><br></pre></td></tr></table></figure></p><p>重新 ssh 连接, 经过询问与确认之后, 新的 host key 便会写入 known_hosts 文件;</p><p>最后回过头来总结一下:<br>像 id_rsa 以及 authorized_keys 这类涉及到私人信息安全的文件一定是要对其余用户不可访问的: 如果私钥文件对其余用户可读, openssh-client 会直接拒绝并提示文件权限设置过宽, 如果 authorized_keys 对其余用户可读, 则用户无法登陆, 会提示需要输入密码; 而类似 id_rsa.pub 公钥这种原本设计就是要公开的信息, 设置成 644, 对其余用户只读即可;</p><h2 id="ssh-相关命令"><a href="#ssh-相关命令" class="headerlink" title="ssh 相关命令"></a><strong>ssh 相关命令</strong></h2><p>ssh 命令常用的选项如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i:   identity, 指定私钥文件, 适用于文件名自定义的私钥文件</span></span><br><span class="line"><span class="comment"># -p:   port, 指定连接 openssh-server 的端口号</span></span><br><span class="line"><span class="comment"># -X:   开启 openssh 的 Forwarding X11 图形界面功能</span></span><br><span class="line">ssh -p 22 -i .ssh/id_rsa_xxx zshell.zhang@l-xx1.ops.cn1</span><br></pre></td></tr></table></figure></p><p>scp 命令常用的选项如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -r:   recursive, 传输整个目录下的子文件</span></span><br><span class="line"><span class="comment"># -l:   limit, 限制传输带宽, 单位是 kb/s</span></span><br><span class="line"><span class="comment"># -i:   identity, 指定私钥文件</span></span><br><span class="line"><span class="comment"># -P:   port, 指定端口</span></span><br><span class="line">scp -r zshell.zhang@l-xx1.ops.cn2:/tmp/xxx ~/Downloads</span><br></pre></td></tr></table></figure></p><p>与 openssh-client 相关的命令, 还有一个 sftp, 在本文中不作详细讨论, 本站另一篇文章中单独讨论了 sftp 相关的内容: <a href="">sftp 相关知识梳理</a>;</p><h2 id="openssh-client-配置文件"><a href="#openssh-client-配置文件" class="headerlink" title="openssh-client 配置文件"></a><strong>openssh-client 配置文件</strong></h2><p>openssh-client 的配置文件主要有两方面, 全局配置和个人家目录下的私有配置; 在可配置的内容选项上, 全局配置与私有配置其实没有差别, 只不过习惯上会将一些比较通用的配置放在全局配置里;</p><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a><strong>全局配置文件</strong></h3><p>openssh 的全局配置文件的路径: <code>/etc/ssh/ssh_config</code>;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Host *  <span class="comment"># 对所有的 host 适用的配置</span></span><br><span class="line">ForwardAgent no</span><br><span class="line">ForwardX11 no   <span class="comment"># 允许开启图形界面支持</span></span><br><span class="line">RhostsAuthentication no</span><br><span class="line">RhostsRSAAuthentication no</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">FallBackToRsh no</span><br><span class="line">UseRsh no</span><br><span class="line">BatchMode no</span><br><span class="line">CheckHostIP yes</span><br><span class="line">StrictHostKeyChecking no</span><br><span class="line"><span class="comment"># 默认的私钥文件, 按先后顺序依次获取</span></span><br><span class="line">IdentityFile ~/.ssh/identity</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 22</span><br><span class="line">Cipher 3des</span><br><span class="line">EscapeChar ~</span><br></pre></td></tr></table></figure></p><h3 id="私有配置文件"><a href="#私有配置文件" class="headerlink" title="私有配置文件"></a><strong>私有配置文件</strong></h3><p>openssh 的私有配置文件的路径: <code>$HOME/.ssh/config</code>;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Host *  <span class="comment"># 对所有的 host 适用的配置</span></span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">ControlPersist yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/tmp/ssh/master-%r@%h:%p</span><br><span class="line"></span><br><span class="line">ConnectTimeout 30</span><br><span class="line">TCPKeepAlive yes</span><br><span class="line">StrictHostKeyChecking no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有匹配到 *.cn0 的主机, 均使用以下配置连接</span></span><br><span class="line">Host *.cn0</span><br><span class="line">Port 22</span><br><span class="line">User zshell.zhang   <span class="comment"># 使用 zshell.zhang 用户登陆目标主机</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa  <span class="comment"># 使用指定的私钥文件</span></span><br><span class="line">ProxyCommand ssh zshell.zhang@l-rtools1. -W %h:%p   <span class="comment"># 具体的 ssh 命令</span></span><br></pre></td></tr></table></figure></p><h2 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h2><ul><li><a href="">sftp 相关知识梳理</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul><li><a href="https://www.cnblogs.com/snowbook/p/5671406.html" target="_blank" rel="noopener">ssh配置authorized_keys后仍然需要输入密码的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ssh 相关的命令是日常开发中基础中的基础, 乃是登陆机器操作必不可少的过程; 但是越是寻常, 可能越容易疏于整理总结; 本文就从 openssh-client 着手, 总结一下 .ssh 目录, ssh 相关命令, 以及相关配置文件的使用;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zshell.cc/categories/linux/"/>
    
      <category term="ssh" scheme="http://zshell.cc/categories/linux/ssh/"/>
    
    
      <category term="linux:ssh" scheme="http://zshell.cc/tags/linux-ssh/"/>
    
      <category term="security" scheme="http://zshell.cc/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>nginx module 使用总结: ngx_http_geo_module</title>
    <link href="http://zshell.cc/2018/05/13/nginx-module--nginx_module_%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93_ngx_http_geo_module/"/>
    <id>http://zshell.cc/2018/05/13/nginx-module--nginx_module_使用总结_ngx_http_geo_module/</id>
    <published>2018-05-13T07:45:02.000Z</published>
    <updated>2018-05-13T08:05:13.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在处理与 ip 地址相关的 nginx 逻辑上, ngx_http_geo_module 往往能发挥一些有力的作用; 其封装了大量与 ip 地址相关的匹配逻辑, 使得处理问题更加便捷高效;</p></blockquote><a id="more"></a><hr><p>ngx_http_geo_module 最主要的事情是作了一个 ip 地址到其他变量的映射; 一说到映射, 我们便会想起另一个模块: ngx_http_map_module; 从抽象上讲, geo 模块确实像是 map 模块在 ip (geography) 细分领域内的针对性功能实现;</p><h3 id="geo-模块的安装"><a href="#geo-模块的安装" class="headerlink" title="geo 模块的安装"></a><strong>geo 模块的安装</strong></h3><p>ngx_http_geo_module 编译默认安装, 无需额外操作;</p><h3 id="geo-模块的配置"><a href="#geo-模块的配置" class="headerlink" title="geo 模块的配置"></a><strong>geo 模块的配置</strong></h3><p>geo 模块的配置只能在 nginx.conf 中的 http 指令下, 这与 ngx_http_map_module 模块是一致的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span>  ngx_http_geo_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123; ngx_string(<span class="string">"geo"</span>),</span><br><span class="line">      NGX_HTTP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE12,</span><br><span class="line">      ngx_http_geo_block,</span><br><span class="line">      NGX_HTTP_MAIN_CONF_OFFSET,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">      ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>geo 模块的配置模式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geo [<span class="variable">$address</span>] <span class="variable">$variable</span> &#123;</span><br><span class="line">    default     0;</span><br><span class="line">    127.0.0.1   1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中, \$address 可选, 默认从 <code>$remote_addr</code> 变量中获取目标 client ip address; 如果使用其他变量作为 ip 地址, 该变量须要是一个合法的 ip 地址, 否则将以 “255.255.255.255” 作为代替;<br>以下是一个典型的 geo 模块配置, \$address 已缺省默认为 <code>$remote_addr</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$flag</span> &#123;</span><br><span class="line">    <span class="comment"># 以下是一些设置项</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义可信地址, 若 $remote_addr 匹配了其中之一, 将从 request header X-Forwarded-For 获得目标 client ip address</span></span><br><span class="line">    proxy           192.168.100.0/24;</span><br><span class="line">    delete          127.0.0.0/16;</span><br><span class="line">    <span class="comment"># 默认兜底逻辑</span></span><br><span class="line">    default         -1;</span><br><span class="line">    <span class="comment"># 定义外部的映射内容</span></span><br><span class="line">    include         conf/geo.conf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 以下是具体的映射内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可以使用 CIDR 匹配</span></span><br><span class="line">    192.168.1.0/24  0;</span><br><span class="line">    <span class="comment"># 精确匹配</span></span><br><span class="line">    10.64.0.5       1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了以上的典型用法之外, geo 模块还有一种地址段范围的匹配模式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$flag</span> &#123;</span><br><span class="line">    <span class="comment"># 需放在第一行</span></span><br><span class="line">    ranges;</span><br><span class="line">    192.168.1.0-192.168.1.100       0;</span><br><span class="line">    192.168.1.100-192.168.1.200     1;</span><br><span class="line">    192.168.1.201-192.168.1.255     2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html" target="_blank" rel="noopener">Module ngx_http_geo_module</a></li><li><a href="http://www.ttlsa.com/nginx/using-nginx-geo-method/" target="_blank" rel="noopener">nginx geo 使用方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在处理与 ip 地址相关的 nginx 逻辑上, ngx_http_geo_module 往往能发挥一些有力的作用; 其封装了大量与 ip 地址相关的匹配逻辑, 使得处理问题更加便捷高效;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://zshell.cc/categories/nginx/"/>
    
      <category term="module" scheme="http://zshell.cc/categories/nginx/module/"/>
    
    
      <category term="nginx" scheme="http://zshell.cc/tags/nginx/"/>
    
      <category term="nginx:module" scheme="http://zshell.cc/tags/nginx-module/"/>
    
  </entry>
  
  <entry>
    <title>chattr / lsattr 使用总结</title>
    <link href="http://zshell.cc/2018/04/06/linux-disk--chattr_lsattr%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://zshell.cc/2018/04/06/linux-disk--chattr_lsattr使用总结/</id>
    <published>2018-04-06T13:23:22.000Z</published>
    <updated>2018-04-07T10:08:56.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;<br>对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;</p></blockquote><a id="more"></a><hr><h3 id="chattr-命令"><a href="#chattr-命令" class="headerlink" title="chattr 命令"></a><strong>chattr 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># + 在原有参数基础上追加设置</span></span><br><span class="line"><span class="comment"># - 在原有参数基础上移除设置</span></span><br><span class="line"><span class="comment"># = 将设置更改为指定的参数</span></span><br><span class="line"><span class="comment"># mode 指定的设置项</span></span><br><span class="line">sudo chattr +|-|=mode file_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归设置指定目录下的所有文件</span></span><br><span class="line">sudo chattr -R +|-|=mode file_path</span><br></pre></td></tr></table></figure><p>其中, mode 中常用的设置项如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a   设置只能向指定文件中追加内容, 不能删除</span><br><span class="line">i   设置文件不能修改, 删除, 不能被设置链接关系, 是最常用的 mode</span><br><span class="line">s   security, 当 rm 该文件时, 从磁盘上彻底删除它;</span><br></pre></td></tr></table></figure></p><p>chattr 并非万能, 以下几个目录 chattr 并不能干预:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">/dev</span><br><span class="line">/tmp</span><br><span class="line">/var</span><br></pre></td></tr></table></figure></p><h3 id="lsattr-命令"><a href="#lsattr-命令" class="headerlink" title="lsattr 命令"></a><strong>lsattr 命令</strong></h3><p>lsattr 命令用于查看文件被 chattr 设置的情况;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsattr file_path</span><br><span class="line">----i--------e- file_path</span><br></pre></td></tr></table></figure></p><p>可以发现, 有的时候 lsattr 所展示的文件属性掩码中, 有一个 <code>e</code>, 这在 chattr 的 manual 文档里是这么说的:</p><blockquote><p>The <code>e</code> attribute indicates that the file is using extents for mapping the blocks on disk. It may not be removed using chattr(1).</p></blockquote><p>所以说, 对 chattr 来说, 这个掩码并不意味着什么;</p><h3 id="常用的情景"><a href="#常用的情景" class="headerlink" title="常用的情景"></a><strong>常用的情景</strong></h3><p>对于生产环境中的机器, 有如下一些重要文件一般会将其用 chattr 设为不可修改, 不可删除:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chattr +i /etc/resolv.conf</span><br><span class="line">sudo chattr +i /etc/hosts.allow</span><br><span class="line">sudo chattr +i /etc/hosts.deny</span><br></pre></td></tr></table></figure></p><p>其中, /etc/hosts.allow 与 /etc/hosts.deny 是关于 ssh 的登陆白名单/黑名单信息, 安全考虑, 正常只允许跳板机 ssh 到本机, 而禁止其他所有的机器; 这两个文件绝不允许被无故修改;<br>而 /etc/resolv.conf 则是关于 dns 解析的文件, 一旦被修改, 会导致一些网络请求中的域名无法正常解析, 所以也需要被 chattr 锁定防止无故修改;</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="http://www.ha97.com/5172.html" target="_blank" rel="noopener">Linux的chattr与lsattr命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于在机器上操作的人来说, 如果有 sudo 权限, 那 chattr 根本就不是事, 这也不是 chattr 的意义所在;&lt;br&gt;对 chattr 来说, 其所要阻止的, 是那些有意无意想要修改机器上重要文件的程序, 从而保证机器上重要的文件不会因非人为因素而遭到非预期的操作;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zshell.cc/categories/linux/"/>
    
      <category term="disk" scheme="http://zshell.cc/categories/linux/disk/"/>
    
    
      <category term="linux:disk" scheme="http://zshell.cc/tags/linux-disk/"/>
    
      <category term="系统安全" scheme="http://zshell.cc/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch 6.x 升级调研报告</title>
    <link href="http://zshell.cc/2018/03/24/elasticsearch--elasticsearch6.x%E5%8D%87%E7%BA%A7%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"/>
    <id>http://zshell.cc/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/</id>
    <published>2018-03-24T14:11:48.000Z</published>
    <updated>2018-09-06T12:02:34.803Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;<br>在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;<br>希望能给各位读者带来工作上的帮助!</p></blockquote><a id="more"></a><hr><p><strong>万字长文, 高能预警! 如只希望了解最终结论, 请点击:</strong> <em><a href="#本文总结">#本文总结</a>;</em><br>&nbsp;<br>戊戌年春, 历时余月, 本文终于迎来了收尾;<br>这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: <a href="https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402" target="_blank" rel="noopener">ES consume high cpu with threadlocal</a>; 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文即是该升级调研的一个总结报告;<br>相比于公司内部发表的版本, 本篇博客对所有涉及公司内部的信息作了脱敏处理, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;</p><h2 id="客户端兼容性问题"><a href="#客户端兼容性问题" class="headerlink" title="客户端兼容性问题"></a><strong>客户端兼容性问题</strong></h2><p>在这篇文章的编排结构中, 我将客户端兼容性问题摆在了第一的位置: 因为不管 rest api 如何变化, 或者如何不变, 都只能算是 “术”; 我们真正跑在生产环境中的系统, 使用的是 elasticsearch java client; client 端的基础兼容性问题才是根本之 “道”;</p><h3 id="巨轮转向的前提-es-adapter"><a href="#巨轮转向的前提-es-adapter" class="headerlink" title="巨轮转向的前提: es-adapter"></a><strong>巨轮转向的前提: es-adapter</strong></h3><p>我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;<br>如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 “无效” 工作量, 他们一定不会积极配合, 我们将无法推动进展;<br>还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优; 其余的系统必须通过调用其暴露出去的 dubbo 接口间接访问 elasticsearch; 这个系统被命名为 es-adapter;<br>当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: <a href="">apache httpclient 初始化参数设置总结</a>; 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;<br>有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;<br>不得不说, 当系统规模与复杂度发展到了一个 “船大难掉头” 的程度时, es-adapter 就像是《三体》中描述的 “水滴” 一样, 带领整个体系从一个更高的维度完成 “平滑” 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: <a href="#search-api-的兼容性">#search api 的兼容性</a>;</p><h3 id="升级过渡期-client-端的技术选型"><a href="#升级过渡期-client-端的技术选型" class="headerlink" title="升级过渡期 client 端的技术选型"></a><strong>升级过渡期 client 端的技术选型</strong></h3><p>关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:</p><blockquote><p>We plan on deprecating the <code>TransportClient</code> in Elasticsearch 7.0 and removing it completely in 8.0.</p></blockquote><p>所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;<br>值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;<br>要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- elasticsearch core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- low level rest client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- high level rest client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;<br>之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: <a href="https://github.com/searchbox-io/Jest" target="_blank" rel="noopener">searchbox-io/Jest</a>), 基本囊括了 elasticsearch 各种类别的请求功能;<br>但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score, aggregations 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;<br>这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;<br>我们经过 demo 快速测试验证, 初步得出了结论:<br>&nbsp;<br><strong>6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;</strong><br>&nbsp;<br>这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html" target="_blank" rel="noopener">Compatibility</a>;<br>所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;</p><h3 id="HighLevelClient-的使用注意事项"><a href="#HighLevelClient-的使用注意事项" class="headerlink" title="HighLevelClient 的使用注意事项"></a><strong>HighLevelClient 的使用注意事项</strong></h3><p><strong>(1) 初始化的重要选项</strong><br>HighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:</p><ol><li><code>CONNECTION_REQUEST_TIMEOUT</code></li><li><code>CONNECT_TIMEOUT</code></li><li><code>SOCKET_TIMEOUT</code></li><li><code>MAX_CONN_TOTAL</code></li><li><code>MAX_CONN_PER_ROUTE</code></li></ol><p>不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;HttpHost&gt; httpHosts = Lists.newArrayListWithExpectedSize(serverNum);</span><br><span class="line">serverAddressList.forEach((server) -&gt; httpHosts.add(<span class="keyword">new</span> HttpHost(server.getAddr(), server.getPort(), <span class="string">"http"</span>)));</span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient highLevelClient = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">        RestClient.builder(httpHosts.toArray(<span class="keyword">new</span> HttpHost[<span class="number">0</span>]))</span><br><span class="line">        <span class="comment">// timeout settings</span></span><br><span class="line">        .setRequestConfigCallback((callback) -&gt; callback</span><br><span class="line">                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)</span><br><span class="line">                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)</span><br><span class="line">                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))</span><br><span class="line">        <span class="comment">// connections total and connections per host</span></span><br><span class="line">        .setHttpClientConfigCallback((callback) -&gt; callback</span><br><span class="line">                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)</span><br><span class="line">                .setMaxConnTotal(MAX_CONN_TOTAL)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>(2) request timeout 的设置</strong><br>对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;<br>这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;<br>那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;<br>首先需要定义一个 response 容器来盛装异步回调里拿到的 result:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T response;</span><br><span class="line">    <span class="keyword">private</span> Exception exception;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getResponse</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> response; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(T response)</span> </span>&#123; <span class="keyword">this</span>.response = response; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exception <span class="title">getException</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> exception; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Exception exception)</span> </span>&#123; <span class="keyword">this</span>.exception = exception;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get request with timeout */</span></span><br><span class="line"><span class="keyword">final</span> ResponseWrapper&lt;GetResponse&gt; wrapper = <span class="keyword">new</span> ResponseWrapper&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">highLevelClient.getAsync(request, <span class="keyword">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(GetResponse documentFields)</span> </span>&#123;</span><br><span class="line">        wrapper.setResponse(documentFields);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        wrapper.setException(e);</span><br><span class="line">        wrapper.setResponse(<span class="keyword">null</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchTimeoutException(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wrapper.getResponse() == <span class="keyword">null</span>) &#123; <span class="comment">// 异常处理 &#125; </span></span><br><span class="line"><span class="keyword">else</span> &#123; 处理 wrapper.getResponse() 的返回结果 &#125;</span><br></pre></td></tr></table></figure></p><p><strong>(3) query 请求 dsl 的传参问题</strong><br>es-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="string">"_source"</span>: &#123;</span><br><span class="line">        <span class="string">"include"</span>: [ ... ],</span><br><span class="line">        <span class="string">"exclude"</span>: [ ... ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"from"</span>: xxx,</span><br><span class="line">    <span class="string">"size"</span>: yyy,</span><br><span class="line">    <span class="string">"sort"</span>: [ ... ],</span><br><span class="line">    <span class="string">"aggs"</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象;<br>这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;<br>权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String dslStr = <span class="string">"..."</span>;</span><br><span class="line">SearchModule searchModule = <span class="keyword">new</span> SearchModule(Settings.EMPTY, <span class="keyword">false</span>, Collections.emptyList());</span><br><span class="line">XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(</span><br><span class="line">        <span class="keyword">new</span> NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);</span><br><span class="line"></span><br><span class="line">SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);</span><br></pre></td></tr></table></figure></p><p><strong>(4) 无厘头的 <code>adjust_pure_negative</code></strong><br>整个 HighLevelClient 中, 最让人感到费解的一个东西就是一个神秘的属性:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* org.elasticsearch.index.query.BoolQueryBuilder */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ParseField ADJUST_PURE_NEGATIVE = <span class="keyword">new</span> ParseField(<span class="string">"adjust_pure_negative"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> adjustPureNegative = ADJUST_PURE_NEGATIVE_DEFAULT;</span><br></pre></td></tr></table></figure></p><p>先是看官方文档, 搜不到;<br>然后搜 google, 就找到这么一个稍微相关一点的帖子: <a href="https://discuss.elastic.co/t/what-does-adjust-pure-negative-flag-do/92348" target="_blank" rel="noopener">What does “adjust_pure_negative” flag do?</a>, 而其给出的唯一回复是 “<strong>You can ignore it</strong>“;<br>实在搜不到有效的信息, 我只好去扒源码; 然而, 除了如上所述的 BoolQueryBuilder 中的这坨, 再加上一些测试类, 就再也没在其他地方看到与 <code>adjust_pure_negative</code> 相关的逻辑了;<br>也许真的如 elastic 讨论组中所说的 <em>You can ignore it?</em> 但是现在有一个问题让我无法忽略它: 这个属性无法被 2.4.2 的 elasticsearch 识别, 但在 6.2.2 的 elasticsearch 中, 各个 QueryBuilder 的 toString() 方法会自动将其带上:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"should"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"must_not"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"adjust_pure_negative"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"boost"</span>: <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上一节中提到, es-adapter 接受业务线传来的 query dsl str, 使用 6.2.2 的 elasticsearch 便会将上述语句传给 es-adapter; 如果其访问的索引已经迁移到 6.2.2 新集群, 那么该语句没问题; 但如果其访问的索引还未来得及迁移到新集群, es-adapter 会将该请求路由到旧的 2.4.2 集群, 接着便会发生语法解析异常;<br>&nbsp;<br><em>这意味着, 在某个系统所需要访问的所有索引迁移到 6.2.2 新集群之前, 其 maven 依赖的 elasticsearch 版本, 不能提前升级到 6.2.2, 以阻止 adjust_pure_negative 的生成;</em><br><em>当然考虑到 major 版本升级所带来的语法规则的巨变已被 es-adapter 缓冲掉了绝大部分, 我相信各业务线也不希望把 elasticsearch 的 maven 版本给直接升上去的; 毕竟那意味着代码将红成一大片, 要花费大量的精力修改代码, 这等于把 es-adapter 原本要替其做的事, 提前自己给办了;</em></p><p><strong>(5) 其他小众的需求</strong><br>以上展示的是业务线普遍会遇到的情况, 然后还有两个比较小众的需求, 在个别系统中会使用到,  也是上面所提到的 nested_filter 和 aggregations;<br>关于 nested_filter 还稍顺利些, api 有一些变化但是新的 api 有新的解决方案:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.2.2 版本: 构造一个 携带 nested_filter 的 sort</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SortBuilder <span class="title">buildNestedSort</span><span class="params">(NestedSort nestedSort)</span> </span>&#123;</span><br><span class="line">    QueryBuilder termFilter = QueryBuilders.termsQuery(nestedSort.getTermField(), nestedSort.getTermValue());</span><br><span class="line">    <span class="keyword">return</span> SortBuilders.fieldSort(nestedSort.getSortName())</span><br><span class="line">            .setNestedSort(<span class="keyword">new</span> NestedSortBuilder(nestedSort.getNestedPath()).setFilter(termFilter))</span><br><span class="line">            .order(nestedSort.getOrder())</span><br><span class="line">            .sortMode(SortMode.fromString(nestedSort.getSortMode()))</span><br><span class="line">            .missing(nestedSort.getMissing());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只不过这种顺利是建立在之前的不顺利基础上的: org.elasticsearch.search.sort.SortBuilders 没有实现 java.io.Serializable 接口, 各业务线的系统没法通过 dubbo 接口把参数传给我, 所以不得不自定义了上面的 NestedSort 类用于盛装 nested sort filter 的相关参数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedSort</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sortName; <span class="comment">// 排序用的字段名</span></span><br><span class="line">    <span class="keyword">private</span> SortOrder order = SortOrder.ASC;</span><br><span class="line">    <span class="keyword">private</span> String missing; <span class="comment">// _first/_last,如果指定的字段不存在的排序逻辑</span></span><br><span class="line">    <span class="keyword">private</span> String sortMode; <span class="comment">// max/min/sum/avg</span></span><br><span class="line">    <span class="keyword">private</span> String nestedPath;</span><br><span class="line">    <span class="keyword">private</span> String termField; <span class="comment">// filter对应的 term 的field,现在只支持terms;</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;String&gt; termValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好在 nested_filter 相关参数类别可以固化, 比较稳定, 自定义类也算是个解决方案了;<br>&nbsp;<br>但是另一个小众需求就没那么省事了: aggregations; 之前 2.4.2 的 agg api 中, 有一个通用的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SearchRequestBuilder <span class="title">setAggregations</span><span class="params">(<span class="keyword">byte</span>[] aggregations)</span> </span>&#123;</span><br><span class="line">    sourceBuilder().aggregations(aggregations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>elasticsearch 聚合的 api 比较丰富自由, 而上面方法中的 aggregations 参数是以字节的形式传过来的, 所以业务线可以自由发挥, 不受 es-adapter 的约束, 但可惜这个方法在 6.2.2 版本中取消了;<br>这样一来不得不回到束缚之中, 针对不同的聚合类型作各自的处理了; 可惜各个聚合类型依然没有实现 java.io.Serializable 接口, 所以还是得自定义类型去盛装参数了; 比如以下是针对分位数的聚合:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercentileAggregation</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String aggName;</span><br><span class="line">    <span class="keyword">private</span> String aggField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] percents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PercentilesAggregationBuilder percentileAggBuilder = AggregationBuilders.percentiles(param.getPercentileAggregation().getAggName())</span><br><span class="line">        .field(param.getPercentileAggregation().getAggField())</span><br><span class="line">        .percentiles(param.getPercentileAggregation().getPercents());</span><br><span class="line">searchSourceBuilder.aggregation(percentileAggBuilder)</span><br></pre></td></tr></table></figure><p>其他的聚合类型不再一一列举; 关于 aggregations 的 api 变化着实比较大, 好在使用它的系统比较少, 推动其修改逻辑阻力亦不是很大;<br>&nbsp;<br>HighLevelClient 的使用基本上要解决的就是以上几个问题了; 解决了客户端的问题, 就是解决了 “道” 的问题, 剩下的 “术” 的问题, 都已不是主要矛盾了;</p><h2 id="语法兼容性问题"><a href="#语法兼容性问题" class="headerlink" title="语法兼容性问题"></a><strong>语法兼容性问题</strong></h2><p>语法兼容性问题便是上文所提及 “术” 的问题的主要表现形式; 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;</p><h3 id="索引创建的兼容性"><a href="#索引创建的兼容性" class="headerlink" title="索引创建的兼容性"></a><strong>索引创建的兼容性</strong></h3><p>es 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:<br>&nbsp;<br><strong>首先是 settings 中的区别;</strong><br>&nbsp;<br>部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"index"</span>:&#123;</span><br><span class="line">        <span class="comment">// creation_date 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"creation_date"</span>: <span class="string">"1502713848656"</span>,</span><br><span class="line">        <span class="string">"number_of_shards"</span>:<span class="string">"2"</span>,</span><br><span class="line">        <span class="string">"analysis"</span>:&#123;</span><br><span class="line">            <span class="string">"analyzer"</span>:&#123;</span><br><span class="line">                <span class="string">"comma_analyzer"</span>:&#123;</span><br><span class="line">                    <span class="string">"type"</span>:<span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"tokenizer"</span>:<span class="string">"comma_tk"</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;,  </span><br><span class="line">            <span class="string">"tokenizer"</span>:&#123;</span><br><span class="line">                <span class="string">"comma_tk"</span>:&#123;</span><br><span class="line">                    <span class="string">"pattern"</span>:<span class="string">","</span>,</span><br><span class="line">                    <span class="string">"type"</span>:<span class="string">"pattern"</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"number_of_replicas"</span>:<span class="string">"1"</span>,</span><br><span class="line">        <span class="comment">// uuid 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"uuid"</span>:<span class="string">"Oa0tz0x-SpSfuC591_ASIQ"</span>,</span><br><span class="line">        <span class="comment">// version.create, version.update 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"version"</span>:&#123;</span><br><span class="line">            <span class="string">"created"</span>:<span class="string">"1070399"</span>,</span><br><span class="line">            <span class="string">"upgraded"</span>:<span class="string">"2040299"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;</em><br>&nbsp;<br><strong>然后是 mappings 中的区别;</strong><br>&nbsp;<br><strong>(1) 布尔类型的取值内容规范化</strong><br>elasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elasticsearch 2.4.2</span></span><br><span class="line"><span class="comment">// xxx_idx/_mapping/field/xxx_field</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"xxx_idx"</span>:&#123;</span><br><span class="line">        <span class="string">"mappings"</span>:&#123;</span><br><span class="line">            <span class="string">"xxx_type"</span>:&#123;</span><br><span class="line">                <span class="string">"xxx_field"</span>:&#123;</span><br><span class="line">                    <span class="string">"full_name"</span>:<span class="string">"xxx_field"</span>,</span><br><span class="line">                    <span class="string">"mapping"</span>:&#123;</span><br><span class="line">                        <span class="string">"xxx_field"</span>:&#123;</span><br><span class="line">                            <span class="string">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                            <span class="string">"index_name"</span>:<span class="string">"xxx_field"</span>,</span><br><span class="line">                            <span class="comment">// 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义</span></span><br><span class="line">                            <span class="string">"index"</span>:<span class="string">"not_analyzed"</span>, </span><br><span class="line">                            <span class="string">"store"</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="string">"doc_values"</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="string">"term_vector"</span>:<span class="string">"no"</span>,</span><br><span class="line">                            <span class="string">"norms"</span>:&#123;</span><br><span class="line">                                <span class="string">"enabled"</span>:<span class="literal">false</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">"null_value"</span>:<span class="literal">null</span>,</span><br><span class="line">                            <span class="string">"include_in_all"</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: <code>true</code> 或 <code>false</code>;<br><em>从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 <code>index</code> 属性可能会经常用到;</em></p><p><strong>(2) _timestamp 字段被废弃</strong><br><em>这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;</em><br>&nbsp;<br>况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"_timestamp"</span>: &#123;</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;</p><p><strong>(3) _all 字段被 deprecated, include_in_all 属性被废弃</strong><br>在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;<br>之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"_all"</span>: &#123;</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;<br>与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;<br>elasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 <code>copy_to</code> 属性:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"first_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"copy_to"</span>: <span class="string">"full_name"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"last_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"copy_to"</span>: <span class="string">"full_name"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"full_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;<br>&nbsp;<br><em>无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;</em></p><p><strong>(4) 史诗级大改变: string 类型被废弃</strong><br>string 类型被废弃, 代替者是分词的 <code>text</code> 类型和不分词的 <code>keyword</code> 类型;<br>当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;<br>&nbsp;<br><em>不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;</em><br>&nbsp;<br>经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: <a href="https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst" target="_blank" rel="noopener">Changelog</a>;<br>仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;<br>比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"xxx"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"not_analyzed"</span> <span class="comment">// 不需要分词, 但要索引</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"yyy"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"no"</span> <span class="comment">// 不需要分词, 也不需要索引</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"zzz"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span> <span class="comment">// 默认情况, 需要索引, 也需要分词</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index</code> 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 <code>not_analyzed</code>, <code>analyzed</code>, <code>no</code> 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 <code>not_analyzed</code>, <code>no</code> 中作出选择; 不得不说这非常混乱;<br>要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;<br>至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;<br>现在逻辑理清楚了, <code>index</code> 的取值类型, 也就如上一节所说的, 必须要在 <code>true</code> 或 <code>false</code> 中选择, 非常清晰;</p><p><strong>(5) mapping 中取消 multi types</strong><br>从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html" target="_blank" rel="noopener">Removal of mapping types</a>;<br>由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:</p><blockquote><p>In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.</p></blockquote><p>&nbsp;<br><em>这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;</em></p><h3 id="query-dsl-的兼容性"><a href="#query-dsl-的兼容性" class="headerlink" title="query dsl 的兼容性"></a><strong>query dsl 的兼容性</strong></h3><p>索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;</p><p><strong>(1) filtered query 被废弃</strong><br>其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;<br>filtered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: </p><blockquote><p>Exclude as many document as you can with a filter, then query just the documents that remain.</p></blockquote><p>然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;<br>&nbsp;<br><em>从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 在 es-adapter 中删除 filtered</span></span><br><span class="line">  <span class="string">"filtered"</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果有 filter, 将其移动到 query -&gt; bool 中</span></span><br><span class="line">    <span class="string">"filter"</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"bool"</span>: &#123;</span><br><span class="line">        <span class="string">"must"</span>: &#123; ... &#125;,</span><br><span class="line">        <span class="string">"should"</span>: &#123; ... &#125;,</span><br><span class="line">        <span class="string">"must_not"</span>: &#123; ... &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(2) filter context 被限定在 bool query 中使用</strong><br>如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="comment">// 引入 filter context 作前置过滤</span></span><br><span class="line">      <span class="string">"filter"</span>: &#123; ... &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="string">"must"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"should"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"must_not"</span>: &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br><em>由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;</em></p><p><strong>(3) and/or/not query 被废弃</strong><br>与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;<br>可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;<br>现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;<br>但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;<br>&nbsp;<br><em>从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;</em></p><p><strong>(4) missing query 被废弃</strong><br>要实现 missing 语义的 query, 现在必须统一使用 must_not exists:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must_not"</span>: &#123;</span><br><span class="line">                <span class="string">"exists"</span>: &#123;</span><br><span class="line">                    <span class="string">"field"</span>: <span class="string">"xxx"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;<br>&nbsp;<br><em>这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;</em><br><em>另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;</em><br><em>所以, 关于 missing , 必须由业务线自己来修改相关代码了;</em></p><h3 id="search-api-的兼容性"><a href="#search-api-的兼容性" class="headerlink" title="search api 的兼容性"></a><strong>search api 的兼容性</strong></h3><p>相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;</p><p><strong>(1) search_type <code>scan</code> 被废弃</strong><br>关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);<br>从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num * target_size 数量的结果集大小; 除此之外, 没有其他什么区别;<br>&nbsp;<br><em>然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* es-adapter 的查询服务 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseContent <span class="title">query</span><span class="params">(RequestParam param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> scroll(param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.getSearchType().equals(SearchType.COUNT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> count(param);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> normallyQuery(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;</em><br><em>这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;</em></p><p><strong>(2) search_type <code>count</code> 被废弃</strong><br>count 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only counts the results, will still execute aggregations and the like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> does not any improvements compared to &#123;<span class="doctag">@link</span> #QUERY_THEN_FETCH&#125; with a `size` of &#123;<span class="doctag">@code</span> 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">COUNT((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;<br>&nbsp;<br><em>可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;</em></p><p><strong>(3) search_type <code>query_and_fetch</code> 被 deprecated, <code>dfs_query_and_fetch</code> 被废弃</strong><br>这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;<br>&nbsp;<br><em>所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;</em></p><h2 id="底层索引数据兼容性问题"><a href="#底层索引数据兼容性问题" class="headerlink" title="底层索引数据兼容性问题"></a><strong>底层索引数据兼容性问题</strong></h2><p>根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;<br>背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;</p><ul><li>由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;<br>但是看了官方文档, 这个想法是不可行的: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html" target="_blank" rel="noopener">Reindex before upgrading</a>; elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;</li><li><p>其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">Snapshot And Restore</a>):</p><blockquote><p>A snapshot of an index created in 5.x can be restored to 6.x.<br>A snapshot of an index created in 2.x can be restored to 5.x.<br>A snapshot of an index created in 1.x can be restored to 2.x.</p></blockquote></li><li><p>接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: <code>reindex.remote.whitelist: oldhost:port</code> 以允许连接远程主机作 reindex;<br>以下是 _reindex api 的使用方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"source"</span>: &#123;</span><br><span class="line">    <span class="string">"remote"</span>: &#123;</span><br><span class="line">      <span class="string">"host"</span>: <span class="string">"http://oldhost:9273"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"source_idx"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"source_type"</span>,</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dest"</span>: &#123;</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"dest_idx"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"dest_type"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;</p></li></ul><h2 id="工具兼容性问题"><a href="#工具兼容性问题" class="headerlink" title="工具兼容性问题"></a><strong>工具兼容性问题</strong></h2><h3 id="http-访问工具兼容性"><a href="#http-访问工具兼容性" class="headerlink" title="http 访问工具兼容性"></a><strong>http 访问工具兼容性</strong></h3><p>目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;<br>关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: <a href="https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests" target="_blank" rel="noopener">Strict Content-Type Checking for Elasticsearch REST Requests</a>;<br>现在所有带 body 的请求都必须要加上 <code>Content-Type</code> 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;<br>&nbsp;<br>目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: <a href="https://github.com/yannart/docker-cerebro" target="_blank" rel="noopener">yannart/docker-cerebro</a>; 经过部署测试, 完全兼容 elasticsearch 6.2.2;<br>不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;<br>&nbsp;<br>没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;<br>首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 <code>Content-Type</code>, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;<br>然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 <code>Content-Type</code> 的时候, 那就指定为 <code>application/json</code> 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;<br>如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name esxxx.xxx.com;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">      proxy_pass http://xxx.yyy.com;</span><br><span class="line"></span><br><span class="line">      proxy_set_header X-Real-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 统一加上 application/json 的 Content-Type</span></span><br><span class="line">      proxy_set_header Content-Type application/json;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;<br>其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;</p><h3 id="插件兼容性"><a href="#插件兼容性" class="headerlink" title="插件兼容性"></a><strong>插件兼容性</strong></h3><p>笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;<br><strong>(1) elasticfence</strong><br>这个插件追踪溯源的话是这个项目: <a href="https://github.com/elasticfence/elasticsearch-http-user-auth" target="_blank" rel="noopener">elasticfence</a>; 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;<br>当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;<br>首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;<br>当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A filter allowing to filter rest operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFilter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(RestRequest request, RestChannel channel, RestFilterChain filterChain)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;<br>经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public interface ActionPlugin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a function used to wrap each rest request before handling the request.</span></span><br><span class="line"><span class="comment"> * Note: Only one installed plugin may implement a rest wrapper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> UnaryOperator&lt;RestHandler&gt; <span class="title">getRestHandlerWrapper</span><span class="params">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class ElasticfencePlugin extends Plugin implements ActionPlugin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UnaryOperator&lt;RestHandler&gt; <span class="title">getRestHandlerWrapper</span><span class="params">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPluginDisabled()) &#123;</span><br><span class="line">        <span class="comment">// 透传请求</span></span><br><span class="line">        <span class="keyword">return</span> (originRestHandler) -&gt; authRestFilter.wrapNone(originRestHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 权限控制</span></span><br><span class="line">        <span class="keyword">return</span> (originRestHandler) -&gt; authRestFilter.wrap(originRestHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;<br>换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制…… 要想使用, 就必须申请权限!<br>当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;<br>然而实际上, 申请权限却不是那么顺利: 我按照官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions" target="_blank" rel="noopener">Help for plugin authors</a> 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;<br>&nbsp;<br>根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!<br>想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;<br>不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;<br>在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;<br>源码中与 java security manager 相关的代码主要有以下几个地方:<br>首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.Elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// we want the JVM to think there is a security manager installed so that if internal policy </span></span><br><span class="line">    <span class="comment">// decisions that would be based on the presence of a security manager</span></span><br><span class="line">    <span class="comment">// or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> SecurityManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    LogConfigurator.registerErrorListener();</span><br><span class="line">    <span class="keyword">final</span> Elasticsearch elasticsearch = <span class="keyword">new</span> Elasticsearch();</span><br><span class="line">    <span class="keyword">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (status != ExitCodes.OK) &#123;</span><br><span class="line">        exit(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着是 Bootstrap 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.Bootstrap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">boolean</span> addShutdownHook, Environment environment)</span> <span class="keyword">throws</span> BootstrapException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// install SM after natives, shutdown hooks, etc.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是 BootstrapChecks 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.BootstrapChecks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the list of checks to execute</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;BootstrapCheck&gt; <span class="title">checks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;BootstrapCheck&gt; checks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ......</span><br><span class="line">    checks.add(<span class="keyword">new</span> AllPermissionCheck());</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(checks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AllPermissionCheck</span> <span class="keyword">implements</span> <span class="title">BootstrapCheck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BootstrapCheckResult <span class="title">check</span><span class="params">(BootstrapContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAllPermissionGranted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> BootstrapCheck.BootstrapCheckResult.failure(<span class="string">"granting the all permission effectively disables security"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BootstrapCheckResult.success();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAllPermissionGranted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">assert</span> sm != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> AllPermission());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;<br>重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动; 尽管这个问题暂时解决了, 但总是 “不太光彩”; 如果有人知道如何通过常规方法解决 security manager 的问题, 还请不吝赐教;</p><p><strong>(2) elasticsearch-analysis-ik</strong><br>这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, <a href="https://github.com/medcl" target="_blank" rel="noopener">medcl</a> 一定会在新版本发布第一时间更新 <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">elasticsearch-analysis-ik</a>, 与公司共进退;<br>安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;</p><p><strong>(3) 其余插件</strong><br>在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;</p><h2 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a><strong>监控体系</strong></h2><h3 id="基于-rest-api-graphite-grafana-的方案"><a href="#基于-rest-api-graphite-grafana-的方案" class="headerlink" title="基于 rest api + graphite + grafana 的方案"></a><strong>基于 rest api + graphite + grafana 的方案</strong></h3><p>基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们监控 elasticsearch 集群健康状况的主力工具 (这篇文章详细介绍了 elasticsearch 各种 rest api 收集到的指标以及将其可视化的方法: <a href="">使用 rest api 可视化监控 elasticsearch 集群</a>);<br>将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现 rest api 有了一些变化;<br>首先是 rest api 调用的参数的细微变化:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数</span></span><br><span class="line">_nodes/stats?all=<span class="literal">true</span></span><br><span class="line">_stats?all=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>all 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;<br>其余的 api 在调用的路径和参数上都没有什么变化, 比较顺利;<br>然后是调用 api 返回的内容有一些细微的变化:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.4.2 的 load 指标</span></span><br><span class="line"><span class="variable">$node_name</span>.os.load_avergae</span><br><span class="line"><span class="comment"># 6.2.2 的 load 指标</span></span><br><span class="line"><span class="variable">$node_name</span>.os.cpu.load_average.1m</span><br><span class="line"><span class="variable">$node_name</span>.os.cpu.load_average.5m</span><br><span class="line"><span class="variable">$node_name</span>.os.cpu.load_average.15m</span><br></pre></td></tr></table></figure></p><p>6.2.2 的机器 load 指标收集, 随系统细分为了 1min, 5min 和 15min 三种, 也算是更精致了;</p><h3 id="elastic-官方组件-x-pack"><a href="#elastic-官方组件-x-pack" class="headerlink" title="elastic 官方组件 x-pack"></a><strong>elastic 官方组件 x-pack</strong></h3><p>在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;<br>从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png" alt="x-pack-fee-table" title="">                </div>                <div class="image-caption">x-pack-fee-table</div>            </figure><br>对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;<br>我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;<br>可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png" alt="x-pack-monitor" title="">                </div>                <div class="image-caption">x-pack-monitor</div>            </figure><br>另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png" alt="x-pack-search-profiler" title="">                </div>                <div class="image-caption">x-pack-search-profiler</div>            </figure><br>除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;<br>以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;</p><h2 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a><strong>本文总结</strong></h2><p>本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级到 6.2.2 的可行性与兼容性问题;<br><strong>首先是客户端兼容性问题:</strong><br>elastic 公司新推出的 <code>RestHighLevelClient</code> 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 <code>RestHighLevelClient</code> 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利; 对各业务线而言, 只有有限的 (诸如 aggregations) api 被迫需要修改, 其余的都可以延续下去;<br><strong>其次是语法兼容性问题:</strong><br>此处仍需细分为三个方面: <strong>create index</strong>, <strong>query dsl</strong> 和 <strong>search api</strong> ;<br><strong>create index</strong> 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 <code>string</code> 类型, 改而细分出两个司职更明确的类型: <code>text</code> 与 <code>keyword</code>, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;<br><strong>query dsl</strong> 方面, 对我们的影响也在控制范围之内: 只有 <code>missing</code> 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;<br><strong>search api</strong> 方面, 可能影响就比较大了: <code>scan</code> 和 <code>count</code> 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;<br><strong>然后是索引数据迁移兼容性问题:</strong><br>经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;<br><strong>接着是工具兼容性问题:</strong><br>经过不断探索与变通, 最后 <code>cerebro</code>, <code>elasticsearch-head</code>, <code>elasticfence</code>, <code>elasticsearch-analysis-ik</code>, <code>curator</code> 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 “顺利” 实现了对 6.2.2 版本的兼容;<br>这其中, <code>elasticfence</code> 实现兼容的过程比较坎坷, 甚至还重新编译了 elasticsearch 的源码才解决了 security manager 的问题; 如果以后能通过常规方式解决安全的问题, 一定还得弄回去;<br><strong>最后是监控体系兼容性问题:</strong><br>得益于 6.x 版本 rest api 对先前的延续 (除了极个别 api 有细微调整之外), 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;<br>另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;</p><p>&nbsp;<br><strong>以上便是本文的全部内容;</strong></p><h2 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h2><ul><li><a href="">apache httpclient 初始化参数设置总结</a></li><li><a href="">使用 rest api 可视化监控 elasticsearch 集群</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul><li><a href="https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst" target="_blank" rel="noopener">Changelog</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html" target="_blank" rel="noopener">Removal of mapping types</a></li><li><a href="https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests" target="_blank" rel="noopener">Strict Content-Type Checking for Elasticsearch REST Requests</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html" target="_blank" rel="noopener">Compatibility</a></li><li><a href="https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients" target="_blank" rel="noopener">State of the official Elasticsearch Java clients</a></li><li><a href="http://blog.csdn.net/napoay/article/details/79135136" target="_blank" rel="noopener">Elasticsearch 6 新特性与重要变更解读</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions" target="_blank" rel="noopener">Help for plugin authors</a></li><li><a href="https://elasticsearch.cn/article/338" target="_blank" rel="noopener">Intellij Idea 编译 Elasticsearch 源码</a></li><li><a href="https://github.com/elastic/elasticsearch#building-from-source" target="_blank" rel="noopener">elasticsearch: Building from Source</a></li><li><a href="https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0" target="_blank" rel="noopener">Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You</a></li><li><a href="https://www.cnblogs.com/Leo_wl/p/6181563.html" target="_blank" rel="noopener">Kibana+X-Pack</a></li><li><a href="https://www.elastic.co/subscriptions" target="_blank" rel="noopener">Subscriptions that Go to Work for You</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将部署在生产环境中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 作者所在部门专门抽调人力资源作前期调研, 故为此文以记之;&lt;br&gt;在这篇文章中, 我将从 client 端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;&lt;br&gt;希望能给各位读者带来工作上的帮助!&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://zshell.cc/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://zshell.cc/tags/elasticsearch/"/>
    
      <category term="httpcomponents" scheme="http://zshell.cc/tags/httpcomponents/"/>
    
  </entry>
  
  <entry>
    <title>java gc 日志学习笔记</title>
    <link href="http://zshell.cc/2018/03/06/jvm-gc--java_gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zshell.cc/2018/03/06/jvm-gc--java_gc日志学习笔记/</id>
    <published>2018-03-06T10:04:22.000Z</published>
    <updated>2018-05-20T12:12:36.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 gc 日志, 网上有丰富的资料, 另外周志明的《深入理解 Java 虚拟机: JVM 高级特性与最佳实践》一书, 在第二版中的第 3.5.8 小节也补充了关于 gc 日志的介绍;<br>但是真等拿到一个具体的 gc log, 才发现网上很多的内容都停留在一个比较初级的层次, 只是介绍了最基本的情况; 其对于生产环境中正在使用的 CMS, G1 收集器涉及很少, 对各种 gc 相关的 jvm 参数, 它们在 gc 日志中的具体作用, 也少见一个详细的整理; 另外, 对 gc 日志的管理运维, 我也很难看到一篇好文章来认真讨论;<br>基于以上状况, 我决定在这里写下这篇文章, 从我自己的角度去对 java gc 作一个全面的总结;<br>补充说明: 本文所述内容涉及的 jvm 版本是: Java HotSpot(TM) 64-Bit Server VM (25.60-b23) for linux-amd64 JRE (1.8.0_60-b27);</p></blockquote><a id="more"></a><hr><h3 id="与-gc-相关的-jvm-选项"><a href="#与-gc-相关的-jvm-选项" class="headerlink" title="与 gc 相关的 jvm 选项"></a><strong>与 gc 相关的 jvm 选项</strong></h3><p>以下选项可以开启 gc 日志:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印 gc 的基本信息</span></span><br><span class="line">-verbose:gc</span><br><span class="line"><span class="comment"># 与 -verbose:gc 功能相同</span></span><br><span class="line">-XX:+PrintGC</span><br><span class="line"><span class="comment"># 打印 gc 的详细信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure></p><p>-verbose:gc 与 -XX:+PrintGC 在功能上是一样的; 其区别在于 -verbose 是 jvm 的标准选项, 而 -XX 是 jvm 的非稳定选项; 另外, -XX:+PrintGCDetails 在启动脚本中可以自动开启 PrintGC 选项;</p><p>以下选项可以控制 gc 打印的内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 gc 发生的时间, 形如: yyyy-MM-dd'T'HH:mm:ss.SSSZ +0800</span></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 输出 gc 发生时, 从进程启动到当前时刻总共经历的时间长度, 单位为秒</span></span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 gc 的原因, jdk7 以上支持, 从 jdk8 开始默认打印 gc 原因</span></span><br><span class="line">-XX:+PrintGCCause</span><br><span class="line"><span class="comment"># 打印 jvm 进入 safepoint 时的状态统计</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line"><span class="comment"># 打印每次 "stop the world" 持续的时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># gc 发生前打印堆的状态</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># gc 发生时打印每一个岁数上对象存活数量分布图</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure></p><h3 id="gc-日志开头的元信息输出"><a href="#gc-日志开头的元信息输出" class="headerlink" title="gc 日志开头的元信息输出"></a><strong>gc 日志开头的元信息输出</strong></h3><p>一般在 jvm 启动时, gc.log 都会在开头打印出与当前 jvm 相关的一些元信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jvm 版本信息</span></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (25.60-b23) <span class="keyword">for</span> linux-amd64 JRE (1.8.0_60-b27), built on Aug  4 2015 12:19:40 by <span class="string">"java_re"</span> with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)</span><br><span class="line"><span class="comment"># 内存信息</span></span><br><span class="line">Memory: 4k page, physical 65859796k(37547692k free), swap 0k(0k free)</span><br><span class="line"><span class="comment"># jvm 选项</span></span><br><span class="line">CommandLine flags: -XX:+DisableExplicitGC -XX:+FlightRecorder -XX:+G1SummarizeConcMark -XX:+HeapDumpOnOutOfMemoryError -XX:InitialHeapSize=33285996544 -XX:MaxHeapSize=33285996544 -XX:+PrintClassHistogram -XX:+Pr</span><br><span class="line">intGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintTenuringDistribution -XX:+UnlockCommercialFeatures -XX:+UnlockDiagnosticVMOptions -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br></pre></td></tr></table></figure></p><p>在 jvm 选项中使用不同的收集器, 所输出的 gc 日志格式会有所不同, 尤其是 G1, CMS 等实现复杂的收集器; 不过, 在一些细节的区别之外, 大部分收集器在整体结构上都会维持一定的共性, 以方便使用者阅读;</p><h3 id="gc-日志内容分析"><a href="#gc-日志内容分析" class="headerlink" title="gc 日志内容分析"></a><strong>gc 日志内容分析</strong></h3><p>我选取了几段有代表性的 gc 日志, 包括 ParNew, PS, CMS, G1, 其中相同或相似的内容我作了合并, 内容不同的部分则单独整理; 同时我也选取了一些有代表性的 gc 日志选项所打印的内容, 作重点介绍;</p><p><strong>(1) 打印 gc 发生的时间点, 与 jvm 启动后经历的时间长度</strong><br>对应的 jvm 选项是 PrintGCDateStamps 和 PrintGCTimeStamps; 其中, gc timestamp 是从 jvm 启动至日志打印当时所经历的秒数;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCDateStamps</span></span><br><span class="line"><span class="comment"># -XX:+PrintGCTimeStamps</span></span><br><span class="line">2018-02-06T11:46:09.444+0800: 30.455: [...]</span><br></pre></td></tr></table></figure></p><p><strong>(2) 打印 gc 发生的原因及类型</strong><br>对应的 jvm 选项是 PrintGCCause; 当然, 在 jdk8 之后, 默认会打印 gc cause;<br>这里 G1 和其他的收集器在格式上稍有区别, 因为它的设计与其他收集器差异较大, gc 的条件及类型都不尽相同;<br>G1 收集器的格式, 第一个括号内是 gc 原因, 第二个括号内为 gc 类型:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCCause</span></span><br><span class="line"><span class="comment"># G1 收集器的四种基本 gc 原因</span></span><br><span class="line">GC pause (G1 Evacuation Pause) (mixed)</span><br><span class="line">GC pause (GCLocker Initiated GC) (young)</span><br><span class="line">GC pause (G1 Humongous Allocation) (young)</span><br><span class="line">GC pause (Metadata GC Threshold) (young)</span><br></pre></td></tr></table></figure></p><p>其他收集器的格式, 括号内是 gc 原因, 括号之前是 gc 类型:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCCause</span></span><br><span class="line">GC (Allocation Failure)</span><br><span class="line">Full GC (Metadata GC Threshold)</span><br></pre></td></tr></table></figure></p><p>其中 gc 类型是这样界定的: 没有 STW 则为 GC, 若发生了 STW, 则为 Full GC;</p><p><strong>(3) 打印 gc 发生时每一个岁数上对象存活量分布图</strong><br>对应的 jvm 选项是 PrintTenuringDistribution, 这是一个十分有用的性能调参选项;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"># from / to survivor 的大小为 104857600 bytes, 所以 survivor 区的总大小需要 * 2</span></span><br><span class="line">Desired survivor size 104857600 bytes, new threshold 15 (max 15) <span class="comment"># -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment">#            |--当前 age 的对象大小--|  |--各 age 累积总大小--|</span></span><br><span class="line">- age   1:   38129576 bytes,            38129576 total</span><br><span class="line">- age   2:   34724160 bytes,            72853736 total</span><br><span class="line">- age   3:    4290896 bytes,            77144632 total</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是, 最后一列 “各 age 累积总大小”, 是将从 age 1 到当前 age 的所有 size 累积相加而成的; 它们驻留在 survivor 区中, 如果其累积 size 超过了 “Desired survivor size”, 将会有部分装不下 survivor 的对象晋升至年老代;<br>与此同时, 即便没有超过 “Desired survivor size”, 达到 “MaxTenuringThreshold” 的对象也将进入年老代; 为了避免数据频繁地从年轻代晋升至年老代, MaxTenuringThreshold 的合理值应该在 15 左右;<br>如果 survivor 区的 size 设置过小, 则每次达到 “Desired survivor size” 时的最大 age 都将远小于 15, 这同样会造成数据频繁地从年轻代晋升至年老代, 此时就需要考虑是否要调大 survivor 区的大小了;</p><p><strong>(4) 打印 jvm 运行时间与 STW 的时间</strong><br>对应的 jvm 选项是 PrintGCApplicationStoppedTime 和 PrintGCApplicationConcurrentTime;<br>当发生 “stop the world”, jvm 便会在 gc 日志里记录应用运行的时间:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCApplicationConcurrentTime</span></span><br><span class="line">2018-02-14T21:35:19.896+0800: 9.433: Application time: 0.0000892 seconds</span><br></pre></td></tr></table></figure></p><p>而当 gc 结束时, jvm 便会在 gc 日志中记录停顿的时间:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCApplicationStoppedTime</span></span><br><span class="line">2018-02-14T17:45:06.305+0800: 4.189: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.0553667 seconds, Stopping threads took: 0.0000412 seconds</span><br></pre></td></tr></table></figure></p><p><strong>(5) 打印 jvm 进入 safepoint 的统计信息</strong><br>对应的 jvm 选项是 PrintSafepointStatistics; 除了 gc pause 之外, 还有很多因素会导致 jvm STW 进入 safepoint, 例如: 反优化(deoptimize), 偏向锁生成(enable biased locking) 与偏向锁撤销(revoke bias), thread dump 等;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintSafepointStatistics  –XX:PrintSafepointStatisticsCount=1</span></span><br><span class="line">        vmop                [threads: total initially_running wait_to_block][time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">0.169:  Deoptimize              [      11          0              0    ]       [     0     0     0     0     0    ]  0</span><br><span class="line">        vmop                [threads: total initially_running wait_to_block][time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">9.933:  RevokeBias              [      52          0              0    ]       [     0     0     0     0     0    ]  0</span><br><span class="line">        vmop                [threads: total initially_running wait_to_block][time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">49.785: BulkRevokeBias          [      52          1              1    ]       [     0     0     0     0     0    ]  0</span><br><span class="line">        vmop                [threads: total initially_running wait_to_block][time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">49.821: GenCollectForAllocation [      52          2              2    ]       [     0     0     0     0    22    ]  0</span><br></pre></td></tr></table></figure></p><p>其中:<br>第一列 vmop 是 vm operation, 本次 stw 要做的事情;<br>total 是 stw 发生时, jvm 的总线程数;<br>initially_running 是正在运行, 尚未进入 safepoint 的线程数, 对应后面的时间是 spin;<br>wait_to_block 是进入 safepoint 后尚未阻塞的线程数, 对应后面的时间是 block;<br>所以, sync = spin + block + cleanup;<br>最后一列 vmop 则是 jvm 进入 safepoint 实际动作所消耗的时间;</p><p>&nbsp;<br>以上就是一些典型的与 gc 相关的 jvm 选项; 下面要说的是各典型的收集器日志;</p><p><strong>(6) ParNew 收集器的日志</strong><br>这种是最标准的 gc 日志格式, 也是各种资料上介绍得最多的内容, 日志的含义我已标注在注释上:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># |--gc 前后该区域的 size 变化---|  |--gc 的时间--|  |--gc 前后整个堆的 size 变化--|  |--gc 总耗时--|</span></span><br><span class="line">  [275184K-&gt;1998K(306688K),         0.0151232 secs]  598728K-&gt;325543K(2063104K),      0.0152605 secs] [Times: user=0.05 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure></p><p><strong>(7) Paravel Scavenge 收集器的日志</strong><br>PS 虽然也不是按照标准框架实现的收集器, 但是其 gc 日志与 ParNew 等相比几乎是一脉相承, 几无二致, 此处便不再赘述;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCDetails</span></span><br><span class="line">[PSYoungGen: 585755K-&gt;2888K(640000K)] 1625561K-&gt;1042703K(2038272K), 0.0278206 secs] [Times: user=0.03 sys=0.02, real=0.03 secs]</span><br></pre></td></tr></table></figure></p><p><strong>(8) CMS 收集器的日志</strong><br>CMS 的 gc 日志基本上是按照 CMS 收集算法的执行过程详细记录的;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># CMS-initial-mark</span></span><br><span class="line">2018-02-14T17:45:06.250+0800: 4.134: [GC (CMS Initial Mark) [1 CMS-initial-mark: 0K(1756416K)] 190272K(2063104K), 0.0550579 secs] [Times: user=0.18 sys=0.00, real=0.05 secs]</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS-concurrent-mark-start</span></span><br><span class="line">2018-02-14T17:45:06.305+0800: 4.189: [CMS-concurrent-mark-start]</span><br><span class="line">2018-02-14T17:45:06.320+0800: 4.203: [CMS-concurrent-mark: 0.014/0.014 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] </span><br><span class="line"><span class="comment"># CMS-concurrent-preclean</span></span><br><span class="line">2018-02-14T17:45:06.320+0800: 4.203: [CMS-concurrent-preclean-start]</span><br><span class="line">2018-02-14T17:45:06.324+0800: 4.208: [CMS-concurrent-preclean: 0.004/0.004 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">2018-02-14T17:45:06.325+0800: 4.208: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.0009297 seconds, Stopping threads took: 0.0000444 seconds</span><br><span class="line">2018-02-14T17:45:06.325+0800: 4.209: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time 2018-02-14T17:45:11.592+0800: 9.475: [CMS-concurrent-abortable-preclean: 4.211/5.267 secs] [Times: user=10.30 sys=0.27, real=5.27 secs] </span><br><span class="line">2018-02-14T17:45:11.592+0800: 9.476: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.0001745 seconds, Stopping threads took: 0.0000389 seconds</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS-final-remark</span></span><br><span class="line">2018-02-14T17:45:11.592+0800: 9.476: [GC (CMS Final Remark) [YG occupancy: 173321 K (306688 K)]2018-02-14T17:45:11.592+0800: 9.476: [Rescan (parallel) , 0.0380948 secs]2018-02-14T17:45:11.630+0800: 9.514: [weak </span><br><span class="line">refs processing, 0.0001539 secs]2018-02-14T17:45:11.630+0800: 9.514: [class unloading, 0.0082249 secs]2018-02-14T17:45:11.639+0800: 9.522: [scrub symbol table, 0.0051294 secs]2018-02-14T17:45:11.644+0800: 9.528:</span><br><span class="line"> [scrub string table, 0.0010024 secs][1 CMS-remark: 19239K(1756416K)] 192561K(2063104K), 0.0549428 secs] [Times: user=0.17 sys=0.00, real=0.05 secs] </span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line"><span class="comment"># CMS-concurrent-sweep</span></span><br><span class="line">2018-02-14T17:45:11.647+0800: 9.531: [CMS-concurrent-sweep-start]</span><br><span class="line">2018-02-14T17:45:11.651+0800: 9.535: [CMS-concurrent-sweep: 0.004/0.004 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line"><span class="comment"># CMS-concurrent-reset</span></span><br><span class="line">2018-02-14T17:45:11.651+0800: 9.535: [CMS-concurrent-reset-start]</span><br><span class="line">2018-02-14T17:45:11.668+0800: 9.552: [CMS-concurrent-reset: 0.015/0.017 secs] [Times: user=0.05 sys=0.02, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>关于 CMS 收集算法的流程逻辑, 请参见另一篇文章: <a href="">CMS 收集算法学习与整理</a>;</p><p><strong>(9) G1 收集器的日志</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># 老生代的 gc 时间状况</span></span><br><span class="line">   [Parallel Time: 107.6 ms, GC Workers: 23]</span><br><span class="line">      [GC Worker Start (ms): Min: 30455.3, Avg: 30455.6, Max: 30455.8, Diff: 0.5]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.7, Avg: 1.6, Max: 16.4, Diff: 15.7, Sum: 37.8]</span><br><span class="line">      [Update RS (ms): Min: 0.0, Avg: 0.5, Max: 0.9, Diff: 0.9, Sum: 12.6]</span><br><span class="line">         [Processed Buffers: Min: 0, Avg: 0.9, Max: 2, Diff: 2, Sum: 21]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 1.3]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 2.3, Max: 26.9, Diff: 26.9, Sum: 52.4]</span><br><span class="line">      [Object Copy (ms): Min: 78.3, Avg: 102.5, Max: 105.7, Diff: 27.4, Sum: 2357.9]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 1.3]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 63.0, Max: 79, Diff: 78, Sum: 1448]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 1.5]</span><br><span class="line">      [GC Worker Total (ms): Min: 106.9, Avg: 107.2, Max: 107.5, Diff: 0.6, Sum: 2464.8]</span><br><span class="line">      [GC Worker End (ms): Min: 30562.7, Avg: 30562.7, Max: 30562.8, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 3.2 ms]</span><br><span class="line">   [Code Root Purge: 0.1 ms]</span><br><span class="line">   [Clear CT: 0.6 ms]</span><br><span class="line">   [Other: 4.4 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 1.6 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.4 ms]</span><br><span class="line">      [Humongous Register: 0.2 ms]</span><br><span class="line">      [Humongous Reclaim: 0.1 ms]</span><br><span class="line">      [Free CSet: 1.0 ms]</span><br><span class="line"><span class="comment"># 新生代的 gc 状况</span></span><br><span class="line">   [Eden: 1472.0M(1464.0M)-&gt;0.0B(1384.0M) Survivors: 120.0M-&gt;200.0M Heap: 1781.0M(31.0G)-&gt;682.3M(31.0G)]</span><br><span class="line"><span class="comment"># gc 时间统计</span></span><br><span class="line"> [Times: user=2.36 sys=0.06, real=0.11 secs]</span><br></pre></td></tr></table></figure></p><p>关于 CMS 收集算法的流程逻辑, 请参见另一篇文章: <a href="">G1 收集算法学习与整理</a>;</p><h3 id="gc-日志文件的运维最佳实践"><a href="#gc-日志文件的运维最佳实践" class="headerlink" title="gc 日志文件的运维最佳实践"></a><strong>gc 日志文件的运维最佳实践</strong></h3><p>关于 gc 日志文件本身的管理运维, 也是存在一些经验的, 错误的运维方法将为性能排查甚至系统运行带来麻烦与阻碍;<br><strong>(1) 避免新的 gc 日志覆盖旧的 gc 日志</strong><br>使用 -Xloggc 可以指定 gc 日志的输出路径, 错误的经验会引导我们作如下设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:<span class="variable">$&#123;CATALINA_BASE&#125;</span>/logs/gc.log</span><br></pre></td></tr></table></figure></p><p>这种设置带来的问题是: 当系统重启后, 新的 gc 日志的路径与老的 gc 日志路径相同, 新日志便会将旧日志覆盖;<br>系统一般不会随便重启, 如果重启, 很可能是出现了故障, 或者性能问题; 在这种设置下, 如果重启前忘了备份当前的 gc 日志, 那重启后就没有性能诊断的依据了 (当然也可能事先使用 jstack, jmap 等工具作了部分现场的保留, 并非完全无法作诊断, 这里只是单从 gc 的角度讨论);<br>所以, 最佳的方法是为 gc 日志的命名带上时间戳:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:<span class="variable">$&#123;CATALINA_BASE&#125;</span>/logs/gc.log-$(date +%Y-%m-%d-%H-%M)</span><br></pre></td></tr></table></figure></p><p>这样只要不是在同一分钟内两次重启, gc 日志都不会被覆盖;</p><p><strong>(2) gc 日志的 rolling 滚动</strong><br>如果系统一直在健康运行, 那么 gc 日志的大小就会稳定地增长, 占用磁盘空间, 最后导致磁盘空间报警; 显然我们需要对 gc 日志作 rolling, 主流的方式是使用 jvm 自己的选项作控制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 gc 日志 rolling</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 设置 gc 日志的最大 size, 一旦触发该条件就滚动切分</span></span><br><span class="line">-XX:GCLogFileSize=10M</span><br><span class="line"><span class="comment"># 设置保留滚动 gc 日志的最大文件数量</span></span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br></pre></td></tr></table></figure></p><p>最后日志目录下的内容类似于下面这个样子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gc.log-2018-03-01-17-58.0</span><br><span class="line">gc.log-2018-03-01-17-58.1</span><br><span class="line">gc.log-2018-03-01-17-58.2</span><br><span class="line">gc.log-2018-03-01-17-58.3</span><br><span class="line">gc.log-2018-03-01-17-58.4.current</span><br></pre></td></tr></table></figure></p><p>最后一个带 “.current” 后缀的就是当前正在写的 gc 日志;<br>但这种方式有个问题, 日志文件名没有规范 当达到最大文件数量后, jvm 会选择回头覆盖最老的那个日志文件, 并把 “.current” 后缀也挪过去, 这种模式对日志收集相当得不友好, <a href="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml" target="_blank" rel="noopener">我们很难定位当前正在写入的 log 文件</a>;<br>于是有另外一种思路想来解决 gc 日志收集的问题, 其采用了挪走并写空的方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按天作 rolling</span></span><br><span class="line">cp /home/q/www/<span class="variable">$i</span>/logs/gc.log /home/q/www/<span class="variable">$i</span>/logs/gc.log.$(date -d <span class="string">"yesterday"</span> +%F)</span><br><span class="line"><span class="built_in">echo</span> &gt; /home/q/www/<span class="variable">$i</span>/logs/gc.log</span><br><span class="line">gzip /home/q/www/<span class="variable">$i</span>/logs/gc.log.$(date -d <span class="string">"yesterday"</span> +%F)</span><br></pre></td></tr></table></figure></p><p>这种方法看似可行, 但忽略了一个问题: cp 和 echo 写空这两步并非原子操作, 在这个处理过程中, jvm 依然在试图往日志里写内容, 这就造成了写空后的 gc.log 接不上被 rolling 的老日志了, 甚至在字节层面上都不是完整的编码了, 打开看一下就报了这种错:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"gc.log"</span> may be a binary file.  See it anyway?</span><br></pre></td></tr></table></figure></p><p>即便是使用 strings 命令搜索文本内容, 也只能得到一些残缺的内容, 完全无法分析问题了;<br>说到底, gc 日志的收集陷入这样的困境, 其实是 jvm 自己的支持度不够好; 像 nginx, 使用 <code>kill -USER1</code> 便可以作到原子切割日志; logback 的 RollingFileAppender 也是自身提供了完整的支持; 可惜 jvm gc log 没有走类似的路线, 而是采用了一种古怪的类似于 rrd 的环状模式, 直接造成了收集日志的困难;</p><h3 id="gc-日志的辅助分析工具"><a href="#gc-日志的辅助分析工具" class="headerlink" title="gc 日志的辅助分析工具"></a><strong>gc 日志的辅助分析工具</strong></h3><p>其实拿到一个冗长的 gc 日志文件, 对着枯燥的数字, 我们很难对 待诊断的系统建立起一个直观而感性的性能健康状态的认识;<br>这里有一个十分出色的 gc 日志可视化分析工具: <a href="http://gceasy.io/" target="_blank" rel="noopener">gceasy</a>, 其对于 gc 问题的诊断可谓是如虎添翼;<br>上传 gc 日志并分析诊断, gceasy 可以给出多维度的可视化分析报告, 以友好的交互自动诊断系统的问题所在:</p><ul><li>Heap Statistics (堆状态统计)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/jvm/gc/gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/heap_statistics.png" alt="heap_statistics" title="">                </div>                <div class="image-caption">heap_statistics</div>            </figure></li><li>GC Phases Statistics (gc 算法流程各阶段的时间统计)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/jvm/gc/gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/gc_phase_statistics.png" alt="gc_phase_statistics" title="">                </div>                <div class="image-caption">gc_phase_statistics</div>            </figure></li><li>GC Time (gc 时间统计)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/jvm/gc/gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/gc_time_statistics.png" alt="gc_time_statistics" title="">                </div>                <div class="image-caption">gc_time_statistics</div>            </figure></li><li>GC Cause (gc 原因分布统计)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/jvm/gc/gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/gc_cause_statistics.png" alt="gc_cause_statistics" title="">                </div>                <div class="image-caption">gc_cause_statistics</div>            </figure></li><li>tenuring summary (survivor 区每一个岁数上存活对象 szie 统计)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/jvm/gc/gc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tenuring_summary.png" alt="tenuring_summary" title="">                </div>                <div class="image-caption">tenuring_summary</div>            </figure></li></ul><h3 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h3><ul><li><a href="">CMS 收集算法学习与整理</a></li><li><a href="">G1 收集算法学习与整理</a></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://blog.csdn.net/dac55300424/article/details/19124831" target="_blank" rel="noopener">深入理解 Java 虚拟机: JVM 高级特性与最佳实践 (第2版) 3.5.8 理解 GC 日志</a></li><li><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">Understanding G1 GC Logs</a></li><li><a href="http://chenzhou123520.iteye.com/blog/1582163" target="_blank" rel="noopener">Java -verbose:gc 命令</a></li><li><a href="https://yq.aliyun.com/ask/11545" target="_blank" rel="noopener">jvm参数-verbose:gc和-XX:+PrintGC有区别? (阿里云)</a></li><li><a href="https://segmentfault.com/q/1010000004348215/a-1020000004351714" target="_blank" rel="noopener">jvm参数-verbose:gc和-XX:+PrintGC有区别? (segmentfault)</a></li><li><a href="https://developer.jboss.org/thread/148848?tstart=0&amp;_sscc=t" target="_blank" rel="noopener">Some junk characters displaying at start of jboss gc log file</a></li><li><a href="https://blog.csdn.net/zero__007/article/details/53842099" target="_blank" rel="noopener">GC日志中的 stop-the-world</a></li><li><a href="https://www.zhihu.com/question/57722838/answer/156390795" target="_blank" rel="noopener">java GC进入safepoint的时间为什么会这么长</a></li><li><a href="https://blog.gceasy.io/2016/11/15/rotating-gc-log-files/" target="_blank" rel="noopener">ROTATING GC LOG FILES</a></li><li><a href="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml" target="_blank" rel="noopener">Forwarding JVM Garbage Collector Logs</a></li><li><a href="https://www.jianshu.com/p/e634955f3bbb" target="_blank" rel="noopener">jvm-对象年龄(-XX:+PrintTenuringDistribution)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于 gc 日志, 网上有丰富的资料, 另外周志明的《深入理解 Java 虚拟机: JVM 高级特性与最佳实践》一书, 在第二版中的第 3.5.8 小节也补充了关于 gc 日志的介绍;&lt;br&gt;但是真等拿到一个具体的 gc log, 才发现网上很多的内容都停留在一个比较初级的层次, 只是介绍了最基本的情况; 其对于生产环境中正在使用的 CMS, G1 收集器涉及很少, 对各种 gc 相关的 jvm 参数, 它们在 gc 日志中的具体作用, 也少见一个详细的整理; 另外, 对 gc 日志的管理运维, 我也很难看到一篇好文章来认真讨论;&lt;br&gt;基于以上状况, 我决定在这里写下这篇文章, 从我自己的角度去对 java gc 作一个全面的总结;&lt;br&gt;补充说明: 本文所述内容涉及的 jvm 版本是: Java HotSpot(TM) 64-Bit Server VM (25.60-b23) for linux-amd64 JRE (1.8.0_60-b27);&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://zshell.cc/categories/jvm/"/>
    
      <category term="gc" scheme="http://zshell.cc/categories/jvm/gc/"/>
    
    
      <category term="jvm:gc" scheme="http://zshell.cc/tags/jvm-gc/"/>
    
      <category term="jvm 选项" scheme="http://zshell.cc/tags/jvm-%E9%80%89%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>python module 使用总结: 定时调度器</title>
    <link href="http://zshell.cc/2018/02/23/python-module--python_module_%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93_%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>http://zshell.cc/2018/02/23/python-module--python_module_使用总结_定时调度器/</id>
    <published>2018-02-23T15:23:21.000Z</published>
    <updated>2018-03-24T07:08:34.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;<br>我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:</p><ol><li>简单的实现: sched 与 schedule;</li><li>功能增强版: apscheduler;</li><li>分布式调度器: celery;</li></ol></blockquote><a id="more"></a><hr><h2 id="sched"><a href="#sched" class="headerlink" title="sched"></a><strong>sched</strong></h2><p>sched 是 python 官方提供的定时调度模块, 其实现非常的简单, sched.py 的代码量只有一百多行, 且只有一个类: scheduler;<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sched.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scheduler</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        @param timefunc     能够返回时间戳的计时函数, 要求该函数是一个无参函数</span></span><br><span class="line"><span class="string">        @param delayfunc    能够阻塞给定时间的阻塞函数, 要求该函数能接收一个数值类型的参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    def __init__(self, timefunc, delayfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        @param delay        需要延迟的时间</span></span><br><span class="line"><span class="string">        @param priority     当多个任务需要在同一个时间调度时的优先级</span></span><br><span class="line"><span class="string">        @param action       需要调度的函数</span></span><br><span class="line"><span class="string">        @param argument     需要调度函数的参数列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    def enter(self, delay, priority, action, argument);</span><br></pre></td></tr></table></figure></p><p>如上所示, scheduler 是使用构造器传进来的计时函数与阻塞函数去实现调度逻辑的;</p><h3 id="sched-的局限性与解决方案"><a href="#sched-的局限性与解决方案" class="headerlink" title="sched 的局限性与解决方案"></a><strong>sched 的局限性与解决方案</strong></h3><p>不过说真的, 把 sched 定义为定时调度模块真的很牵强:<br>常规意义上, 我们所理解的定时调度器, 应该是能够像 cron 那样, 按给定的时间间隔或在指定的时间点上循环执行指定的任务; 但是 sched 并不能做到这一点, sched 所做的, 只是从某一个时间点开始, delay 一段我们给定的延时时间, 然后执行给定方法, 仅执行这一次;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sched <span class="keyword">import</span> scheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task</span><span class="params">(time_str)</span>:</span></span><br><span class="line">    print(<span class="string">'task run: %s'</span> % time_str)</span><br><span class="line"></span><br><span class="line">s = scheduler(time.time, time.sleep)</span><br><span class="line"><span class="comment"># delay 5 秒后执行 do_task 函数, 仅执行一次</span></span><br><span class="line">s.enter(<span class="number">5</span>, <span class="number">0</span>, do_task, (time.time(),))</span><br><span class="line">s.run()</span><br></pre></td></tr></table></figure></p><p>要想 sched 做到循环执行, 还需要在其基础上包装上一层类似’递归’的概念:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = scheduler(time.time, time.sleep)</span><br><span class="line"><span class="comment"># 在任务函数中将自己再次用 sched 调度以实现循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task</span><span class="params">(time_str)</span>:</span></span><br><span class="line">    s.enter(<span class="number">5</span>, <span class="number">0</span>, do_task, (time.time(),))</span><br><span class="line">    print(<span class="string">'task run: %s'</span> % time_str)</span><br><span class="line">    </span><br><span class="line">s.enter(<span class="number">5</span>, <span class="number">0</span>, do_task, (time.time(),))</span><br><span class="line">s.run()</span><br></pre></td></tr></table></figure></p><p>当然, 这只是将函数自己的引用传给了 scheduler, 神似递归但并非递归, 所以也就不存在找不到递归出口而爆栈的问题了;<br>很明显, 采用这种方式才能实现真正的定时调度, 可谓非常麻烦而蹩脚;</p><h3 id="sched-的调度原理"><a href="#sched-的调度原理" class="headerlink" title="sched 的调度原理"></a><strong>sched 的调度原理</strong></h3><p>sched 使用 <code>heapq</code> 优先队列来管理需要调度的任务(关于 heapq 的详细内容请参考: <a href="">python module 使用总结: heapq</a>); 在调用了 scheduler 类的 enter 方法后, 其实是生成了一个任务的快照, 并放入了优先队列里:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event = Event(time, priority, action, argument)</span><br><span class="line">heapq.heappush(self._queue, event)</span><br></pre></td></tr></table></figure></p><p>在调用 scheduler.run() 方法后, sched 在一个死循环里, 不断得从优先队列里取出任务执行, 计算最近的下一个任务的等待时间并阻塞:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">q = self._queue</span><br><span class="line"> <span class="keyword">while</span> q:</span><br><span class="line">    time, priority, action, argument = checked_event = q[<span class="number">0</span>]</span><br><span class="line">    now = timefunc()</span><br><span class="line">    <span class="keyword">if</span> now &lt; time:</span><br><span class="line">        delayfunc(time - now)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        event = pop(q)</span><br><span class="line">        <span class="keyword">if</span> event <span class="keyword">is</span> checked_event:</span><br><span class="line">            action(*argument)</span><br><span class="line">            delayfunc(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(q, event)</span><br></pre></td></tr></table></figure></p><p>总体来说, sched 的设计还是比较紧凑清晰的, 轻量化; 但是由于其固有的缺陷, 在复杂的场景中, 往往不能胜任, 我们需要功能更强大的调度框架;</p><h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a><strong>schedule</strong></h2><p>schedule 是一个广泛使用的 python 定时调度框架, 其 github 地址如下: <a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">https://github.com/dbader/schedule</a>, 目前 4k 多个 stars;<br>和 python 官方的 sched 相比, schedule 的 API 要人性化得多, 而且它基本实现了真正意义上的定时调度:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task</span><span class="params">(time_str=time.time<span class="params">()</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'task run: %s'</span> % time_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每 10 分钟执行一次任务</span></span><br><span class="line">schedule.every(<span class="number">10</span>).minutes.do(do_task)</span><br><span class="line"><span class="comment"># 每隔 5 到 10 分钟之间的任意一个时间执行一次任务</span></span><br><span class="line">schedule.every(<span class="number">5</span>).to(<span class="number">10</span>).days.do(do_task)</span><br><span class="line"><span class="comment"># 每 1 小时执行一次任务</span></span><br><span class="line">schedule.every().hour.do(do_task, time_str=<span class="string">'1519351479.19554'</span>)</span><br><span class="line"><span class="comment"># 每天 10:30 执行一次任务</span></span><br><span class="line">schedule.every().day.at(<span class="string">"10:30"</span>).do(do_task)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="schedule-模块的-Scheduler-类"><a href="#schedule-模块的-Scheduler-类" class="headerlink" title="schedule 模块的 Scheduler 类"></a><strong>schedule 模块的 Scheduler 类</strong></h3><p>其实, schedule 模块的整体设计, 是把任务的自我管理部分做的很详细, 而把上层的调度做的很轻很薄, 关键逻辑点采用回调的方式, 依赖任务的自我管理去实现;<br>而上一节所讲的 sched 模块, 则是在上层调度部分使用了复杂的逻辑 (优先队列) 去统一管理, 而任务本身携带的信息很少; sched 与 schedule 两个模块, 在整体设计上, 形成了鲜明的对比;<br>Scheduler 类的实例中, 维护了一个列表: jobs, 专门存储注册进来的任务快照;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Scheduler(object):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.jobs = []</span><br></pre></td></tr></table></figure></p><p>Scheduler 类最重要的方法是 <code>run_pending(self)</code>, 其主要逻辑是遍历 jobs 列表中的所有 job, 从中找出当前时间点需要调度的 job, 并执行;<br>这其中最重要的逻辑是判断一个 job 当前时间点是否需要被调度, 而这个过程是一个回调, 具体的逻辑则封装在 job.should_run 方法里, 下一小节将会详细介绍;<br>可以发现, 总共只用了三行代码, 以此可见其轻量化;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_pending</span><span class="params">(self)</span>:</span></span><br><span class="line">    _jobs = (job <span class="keyword">for</span> job <span class="keyword">in</span> self.jobs <span class="keyword">if</span> job.should_run)</span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> sorted(runnable_jobs):</span><br><span class="line">        self._run_job(job)</span><br></pre></td></tr></table></figure></p><p>值得注意的是, schedule 模块中并没有专门的逻辑去定时执行 run_pending 方法, 要想让定时调度持续跑起来, 需要自己实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>相比 sched 模块的 ‘伪递归’ 而言, 这样的设计算是比较人性化的了, 可以认为它基本实现了真正意义上的定时调度;</p><h3 id="schedule-模块的-Job-类"><a href="#schedule-模块的-Job-类" class="headerlink" title="schedule 模块的 Job 类"></a><strong>schedule 模块的 Job 类</strong></h3><p>正如上一节所述, schedule 模块实现了非常详细的任务自我管理逻辑; 相比 sched 的 <code>Event</code> 类, schedule 定义了一个控制参数更丰富的 <code>Job</code> 类:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval, scheduler=None)</span>:</span></span><br><span class="line">        self.interval = interval  <span class="comment"># pause interval * unit between runs</span></span><br><span class="line">        self.latest = <span class="keyword">None</span>  <span class="comment"># upper limit to the interval</span></span><br><span class="line">        self.job_func = <span class="keyword">None</span>  <span class="comment"># the job job_func to run</span></span><br><span class="line">        self.unit = <span class="keyword">None</span>  <span class="comment"># time units, e.g. 'minutes', 'hours', ...</span></span><br><span class="line">        self.at_time = <span class="keyword">None</span>  <span class="comment"># optional time at which this job runs</span></span><br><span class="line">        self.last_run = <span class="keyword">None</span>  <span class="comment"># datetime of the last run</span></span><br><span class="line">        self.next_run = <span class="keyword">None</span>  <span class="comment"># datetime of the next run</span></span><br><span class="line">        self.period = <span class="keyword">None</span>  <span class="comment"># timedelta between runs, only valid for</span></span><br><span class="line">        self.start_day = <span class="keyword">None</span>  <span class="comment"># Specific day of the week to start on</span></span><br><span class="line">        self.tags = set()  <span class="comment"># unique set of tags for the job</span></span><br><span class="line">        self.scheduler = scheduler  <span class="comment"># scheduler to register with</span></span><br></pre></td></tr></table></figure></p><p>Job 类的参数众多, 单个任务的调度肯定不可能涉及到所有的参数, 这些参数往往是以局部几个为组合, 控制调度节奏的; 但是无论什么组合, 往往都会以 <code>scheduler.every(interval=1)</code> 方法开始, 以 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法结束:<br>(1) schedule.every 方法构造出一个 <code>Job</code> 实例, 并设置该实例的第一个参数 interval;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default_scheduler = Scheduler()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">every</span><span class="params">(interval=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> default_scheduler.every(interval)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">every</span><span class="params">(self, interval=<span class="number">1</span>)</span>:</span></span><br><span class="line">        job = Job(interval, self)</span><br><span class="line">        <span class="keyword">return</span> job</span><br></pre></td></tr></table></figure></p><p>这里想吐槽的是, 这个方法出现在 Scheduler 类中有点突兀, 而且方法名叫 every, 只体现了设置 interval 参数的含义, 但并不能从中看出其新构造一个 Job 实例的意图;<br>(2) Job.do 方法包装了传递进来的任务函数, 将其设置为自己的 job_func 参数, 并将自己作为一个任务快照放进 scheduler 的任务列表里;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Job(object):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, job_func, *args, **kwargs)</span>:</span></span><br><span class="line">        self.job_func = functools.partial(job_func, *args, **kwargs)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            functools.update_wrapper(self.job_func, job_func)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 计算下一次调度的时间</span></span><br><span class="line">        self._schedule_next_run()</span><br><span class="line">        self.scheduler.jobs.append(self)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>在这两个方法之间, 就是通过建造者模式, 构造出其他控制参数的组合, 以实现各种各样的调度节奏;<br>下面来重点讲一下各参数组合如何实现调度节奏的控制;<br>从上一节关于 Scheduler 类的描述中可以看到, 上层调度中最关键的逻辑, 判断每一个注册的 job 是否应该被调度, 其实是 Job 类的一个回调方法 <code>should_run</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">should_run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> datetime.datetime.now() &gt;= self.next_run</span><br></pre></td></tr></table></figure></p><p>而 should_run 方法中的判断的依据, 是当前时间有没有到达 <code>next_run</code> 这个实例字段给出的时间点;<br>next_run 字段的设置则通过在 <code>Job.do(self, job_func, *args, **kwargs)</code> 方法 (上文已给出) 和 <code>Job.run(self)</code> 方法中调用 <code>__schedule_next_run()</code> 方法来实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    logger.info(<span class="string">'Running job %s'</span>, self)</span><br><span class="line">    ret = self.job_func()</span><br><span class="line">    self.last_run = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 计算下一次调度的时间</span></span><br><span class="line">    self._schedule_next_run()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p><p>所以, 所有的秘密就存在于 <code>_schedule_next_run()</code> 方法里了; 下面将结合几大类参数组合的设置, 拆开来分析 _schedule_next_run() 方法的逻辑;<br>这些 Job 类的参数组合, 大致可分为这几类:</p><h4 id="总基调-指定调度的周期"><a href="#总基调-指定调度的周期" class="headerlink" title="总基调: 指定调度的周期"></a><strong>总基调: 指定调度的周期</strong></h4><p>以下方法将会设置 unit 参数, 与 interval 参数结合, 定义调度区间间隔:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self)</span>:</span>   <span class="function"><span class="keyword">def</span> <span class="title">seconds</span><span class="params">(self)</span>:</span>  <span class="comment"># self.unit = 'seconds'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minute</span><span class="params">(self)</span>:</span>   <span class="function"><span class="keyword">def</span> <span class="title">minutes</span><span class="params">(self)</span>:</span>  <span class="comment"># self.unit = 'minutes'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hour</span><span class="params">(self)</span>:</span>     <span class="function"><span class="keyword">def</span> <span class="title">hours</span><span class="params">(self)</span>:</span>    <span class="comment"># self.unit = 'hours'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span>      <span class="function"><span class="keyword">def</span> <span class="title">days</span><span class="params">(self)</span>:</span>     <span class="comment"># self.unit = 'days'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">week</span><span class="params">(self)</span>:</span>     <span class="function"><span class="keyword">def</span> <span class="title">weeks</span><span class="params">(self)</span>:</span>    <span class="comment"># self.unit = 'weeks'</span></span><br></pre></td></tr></table></figure></p><p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def _schedule_next_run(self)</span></span><br><span class="line">    <span class="keyword">assert</span> self.unit <span class="keyword">in</span> (<span class="string">'seconds'</span>, <span class="string">'minutes'</span>, <span class="string">'hours'</span>, <span class="string">'days'</span>, <span class="string">'weeks'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.latest <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.latest &gt;= self.interval</span><br><span class="line">        interval = random.randint(self.interval, self.latest)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        interval = self.interval</span><br><span class="line"></span><br><span class="line">    self.period = datetime.timedelta(**&#123;self.unit: interval&#125;)</span><br><span class="line">    self.next_run = datetime.datetime.now() + self.period</span><br></pre></td></tr></table></figure></p><p>先不管其中涉及到的 latest 字段 (下文描述), 其他的逻辑清晰可见: 使用 unit 和 interval 构造出一个指定的 timedelta, 加上当前时间得到下次调度的时间;<br>&nbsp;<br>这是最简单的一类, 定下了整个调度的总体节奏; 而下面几个类别的参数并不能单独决定调度周期, 而是在第一类参数的基础之上实施局部调整, 以达到综合控制;</p><h4 id="局部调整1-指定调度的起始-weekday"><a href="#局部调整1-指定调度的起始-weekday" class="headerlink" title="局部调整1: 指定调度的起始 weekday"></a><strong>局部调整1: 指定调度的起始 weekday</strong></h4><p>以下方法将会设置 start_day 参数, 确定调度开始的时间点; 同时统一设置 unit 参数为 ‘weeks’:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monday</span><span class="params">(self)</span>:</span>       </span><br><span class="line">    self.start_day = <span class="string">'monday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tuesday</span><span class="params">(self)</span>:</span>      </span><br><span class="line">    self.start_day = <span class="string">'tuesday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wednesday</span><span class="params">(self)</span>:</span>    </span><br><span class="line">    self.start_day = <span class="string">'wednesday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thursday</span><span class="params">(self)</span>:</span>   </span><br><span class="line">    self.start_day = <span class="string">'thurday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">friday</span><span class="params">(self)</span>:</span>       </span><br><span class="line">    self.start_day = <span class="string">'friday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saturday</span><span class="params">(self)</span>:</span>     </span><br><span class="line">    self.start_day = <span class="string">'saturday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sunday</span><span class="params">(self)</span>:</span>     </span><br><span class="line">    self.start_day = <span class="string">'sunday'</span></span><br><span class="line">    self.unit = <span class="string">'weeks'</span></span><br></pre></td></tr></table></figure></p><p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def _schedule_next_run(self)</span></span><br><span class="line">    <span class="keyword">if</span> self.start_day <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.unit == <span class="string">'weeks'</span></span><br><span class="line">        weekdays = (<span class="string">'monday'</span>, <span class="string">'tuesday'</span>, <span class="string">'wednesday'</span>, <span class="string">'thursday'</span>, <span class="string">'friday'</span>, <span class="string">'saturday'</span>, <span class="string">'sunday'</span>)</span><br><span class="line">        <span class="keyword">assert</span> self.start_day <span class="keyword">in</span> weekdays</span><br><span class="line">        weekday = weekdays.index(self.start_day)</span><br><span class="line">        days_ahead = weekday - self.next_run.weekday()</span><br><span class="line">        <span class="keyword">if</span> days_ahead &lt;= <span class="number">0</span>:  <span class="comment"># Target day already happened this week</span></span><br><span class="line">            days_ahead += <span class="number">7</span></span><br><span class="line">        self.next_run += datetime.timedelta(days_ahead) - self.period</span><br></pre></td></tr></table></figure></p><p>可以发现, start_day 只是在 next_run 原有的 weekday 基础上增加了一个 offset, 相当于是 delay time;</p><h4 id="局部调整2-指定调度的起始时间"><a href="#局部调整2-指定调度的起始时间" class="headerlink" title="局部调整2: 指定调度的起始时间"></a><strong>局部调整2: 指定调度的起始时间</strong></h4><p>以下方法将会设置 at_time 参数, 其针对 unit == ‘hours’ 只设置 minute 变量, 而对 unit == ‘days’ 或 ‘weeks’ 才会设置 hour 变量;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">at</span><span class="params">(self, time_str)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> self.unit <span class="keyword">in</span> (<span class="string">'days'</span>, <span class="string">'hours'</span>) <span class="keyword">or</span> self.start_day</span><br><span class="line">    hour, minute = time_str.split(<span class="string">':'</span>)</span><br><span class="line">    minute = int(minute)</span><br><span class="line">    <span class="keyword">if</span> self.unit == <span class="string">'days'</span> <span class="keyword">or</span> self.start_day:</span><br><span class="line">        hour = int(hour)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt;= hour &lt;= <span class="number">23</span></span><br><span class="line">    <span class="keyword">elif</span> self.unit == <span class="string">'hours'</span>:</span><br><span class="line">        hour = <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= minute &lt;= <span class="number">59</span></span><br><span class="line">    self.at_time = datetime.time(hour, minute)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>其对应的 _schedule_next_run() 逻辑也与上面类似, 针对 unit == ‘days’ 或 ‘weeks’ 才设 hour 字段, 否则只设置 minute 和 second;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def _schedule_next_run(self)</span></span><br><span class="line">    <span class="keyword">if</span> self.at_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.unit <span class="keyword">in</span> (<span class="string">'days'</span>, <span class="string">'hours'</span>) <span class="keyword">or</span> self.start_day <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">        kwargs = &#123;</span><br><span class="line">            <span class="string">'minute'</span>: self.at_time.minute,</span><br><span class="line">            <span class="string">'second'</span>: self.at_time.second,</span><br><span class="line">            <span class="string">'microsecond'</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> self.unit == <span class="string">'days'</span> <span class="keyword">or</span> self.start_day <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            kwargs[<span class="string">'hour'</span>] = self.at_time.hour</span><br><span class="line">        self.next_run = self.next_run.replace(**kwargs)</span><br></pre></td></tr></table></figure></p><h4 id="局部调整3-在给定范围内随机安排调度时刻"><a href="#局部调整3-在给定范围内随机安排调度时刻" class="headerlink" title="局部调整3: 在给定范围内随机安排调度时刻"></a><strong>局部调整3: 在给定范围内随机安排调度时刻</strong></h4><p>对应的就是上文提及的 latest 参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to</span><span class="params">(self, latest)</span>:</span></span><br><span class="line">    self.latest = latest</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>其对应的 _schedule_next_run() 逻辑如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def _schedule_next_run(self)</span></span><br><span class="line">    <span class="keyword">if</span> self.latest <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.latest &gt;= self.interval</span><br><span class="line">        interval = random.randint(self.interval, self.latest)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        interval = self.interval</span><br></pre></td></tr></table></figure></p><p>具体逻辑就是在给定的 [interval, latest) 区间内, 生成一个随机数作为下次调度的 interval;<br>&nbsp;<br>至此, Job 类的逻辑就都分析完了;</p><h2 id="apscheduler"><a href="#apscheduler" class="headerlink" title="apscheduler"></a><strong>apscheduler</strong></h2><h2 id="celery"><a href="#celery" class="headerlink" title="celery"></a><strong>celery</strong></h2><h2 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h2><ul><li><a href="">python module 使用总结: heapq</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul><li><a href="https://docs.python.org/2/library/sched.html" target="_blank" rel="noopener">8.8. sched — Event scheduler</a></li><li><a href="http://blog.csdn.net/leonard_wang/article/details/54017537" target="_blank" rel="noopener">python sched模块学习</a></li><li><a href="https://www.cnblogs.com/anpengapple/p/8051923.html" target="_blank" rel="noopener">python中的轻量级定时任务调度库: schedule</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 java 里, 第三方定时调度框架比较常用的是 quartz 和 springframework 提供的 schedule 功能; 不过在各大公司里, 一般都会开发自己能集中管理与灵活调控的调度组件; 这样一来, 第三方的调度框架反而就接触的少了;&lt;br&gt;我相信在以 python 为主要使用语言的公司里, 一定也有自己的调度中间件; 但是对于以 java 为主的公司里, 肯定不可能专为 python 维护一套调度系统, 所以就很有必要了解一下 python 里的定时调度模块; 本文将介绍几种常用的 python 定时调度框架:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单的实现: sched 与 schedule;&lt;/li&gt;
&lt;li&gt;功能增强版: apscheduler;&lt;/li&gt;
&lt;li&gt;分布式调度器: celery;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="http://zshell.cc/categories/python/"/>
    
      <category term="module" scheme="http://zshell.cc/categories/python/module/"/>
    
    
      <category term="python:module" scheme="http://zshell.cc/tags/python-module/"/>
    
      <category term="python" scheme="http://zshell.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一个 dev 的拙劣前端笔记: 使用 jQuery ajax 上传文件</title>
    <link href="http://zshell.cc/2018/02/03/web--%E4%B8%80%E4%B8%AAdev%E7%9A%84%E6%8B%99%E5%8A%A3%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0_%E4%BD%BF%E7%94%A8jQuery_ajax%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://zshell.cc/2018/02/03/web--一个dev的拙劣前端笔记_使用jQuery_ajax上传文件/</id>
    <published>2018-02-03T13:48:08.000Z</published>
    <updated>2018-02-07T15:43:29.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;<br>本文整理了从传统方式到 ajax 方式上传文件的各种方法;</p></blockquote><a id="more"></a><hr><h3 id="传统的上传文件方式"><a href="#传统的上传文件方式" class="headerlink" title="传统的上传文件方式"></a><strong>传统的上传文件方式</strong></h3><p>form 表单有三种可能的 MIME 编码类型: 默认的 <code>application/x-www-form-urlencoded</code>, 不对字符编码而保留原始信息的 <code>multipart/form-data</code>, 以及纯文本 <code>text/plain</code>;<br>如果没有异步刷新的需求, 只需要将 form 表单的 enctype 属性设置为 <code>multipart/form-data</code>, 便可以二进制的方式提交表单内容, 以达到上传文件的目的:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form_id"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"str"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"fileAttach"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>关于 MIME 类型 <code>multipart/form-data</code> 的更多内容, 请参见: <a href="">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a>;<br>&nbsp;<br><strong>下面来讨论如何使用 ajax 实现文件上传;</strong></p><h3 id="使用-jQuery-ajaxFileUpload-插件实现文件上传"><a href="#使用-jQuery-ajaxFileUpload-插件实现文件上传" class="headerlink" title="使用 jQuery ajaxFileUpload 插件实现文件上传"></a><strong>使用 jQuery ajaxFileUpload 插件实现文件上传</strong></h3><p>ajax 默认使用的 MIME 类型是 <code>application/x-www-form-urlencoded</code>, 这种方式只适用于传输普通字符串类型的数据; 由于在 HTML4 时代, 没有对 javascript 提供文件读取的接口, 使用 <code>document.getElementById(&#39;field_id&#39;).value</code> 也只能获得文件的 name, 并不能拿到文件的二进制数据; 所以, 想直接使用 ajax 无刷新提交表单是无法做到的;<br>所以只能采用间接的方案, 比如基于 jQuery 拓展的 ajaxFileUpload 插件, 其代码逻辑大致如下: </p><ol><li>function createUploadIframe():<br>创建一个独立的 iframe, 并追加到 body 中;</li><li>function createUploadForm(file_elem_id):<br>创建一个独立的 form, 设置 enctype 为 <code>multipart/form-data</code>;<br>根据 file_elem_id 找到页面里的目标 <code>&lt;input type=&quot;file&quot; /&gt;</code> 对象, 使用 jQuery.clone 方法, 将新的克隆对象替换到目标对象的位置, 而将原目标对象追加到新建的 form 中(偷梁换柱);<br>最后将新创建的 form 追加到 body 中;</li><li>function addOtherRequestsToForm(data, new_form):<br>将页面中目标表单的其他元素数据, 一并追加到新创建的 form 里;</li><li>function ajaxFileUpload:<br>调用 createUploadForm 方法创建新 form;<br>调用 addOtherRequestsToForm 方法捎带除 file 之外的其余元素数据;<br>调用 createUploadIFrame 方法创建 iframe;<br>将新 form 的 target 属性设置为新创建 iframe 的 id, 以实现间接的无刷新;<br>submit 提交新 form;</li></ol><p>&nbsp;<br>ajaxFileUpload 的实现逻辑并不复杂, 类似这样的插件在 github 上有各种各样的版本, 我选取了一个比较典型的实现: <a href="https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js" target="_blank" rel="noopener">carlcarl/AjaxFileUpload/ajaxfileupload.js</a>;<br>然后开发者在实际使用时需要调用的是 <code>jQuery.ajaxFileUpload</code> 方法, 设置一些参数与回调方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax_submit</span>(<span class="params">field_id</span>) </span>&#123;</span><br><span class="line">    $.ajaxFileUpload(&#123;</span><br><span class="line">        fileElementId: field_id,    <span class="comment">// &lt;input id="field_id" type="file"&gt;, 对应元素的 id</span></span><br><span class="line">        data: fetch_form_data(<span class="string">'form_id'</span>),   <span class="comment">// 捎带其余元素的数据</span></span><br><span class="line">        url: <span class="string">'/xxx/yyy/upload'</span></span><br><span class="line">        type: <span class="string">'post'</span>,</span><br><span class="line">        dataType: <span class="string">'json'</span>,</span><br><span class="line">        secureuri: <span class="literal">false</span>,   <span class="comment">//是否启用安全提交，默认为false</span></span><br><span class="line">        <span class="keyword">async</span> : <span class="literal">true</span>,   <span class="comment">//是否是异步</span></span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data[<span class="string">'status'</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">                alert(<span class="string">"提交成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">                alert(<span class="string">"提交失败:"</span> + data[<span class="string">'message'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">data, status, e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">            alert(<span class="string">"提交失败:"</span> + data[<span class="string">'message'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将给定的表单数据转为对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch_form_data</span>(<span class="params">form_id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = $(<span class="string">'#'</span> + form_id).serializeArray();  </span><br><span class="line">    <span class="keyword">var</span> values = &#123;&#125;;  </span><br><span class="line">    <span class="keyword">for</span>( x <span class="keyword">in</span> params ) &#123;  </span><br><span class="line">        values[params[x].name] = params[x].value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抛开 iframe 的性能影响不谈, 看起来这样的 api 还是相当友好的, 与 jQuery.ajax 同样方便, 还解决了 ajax 不能传输二进制流的问题;<br>另外, 由于这种方式真正提交的表单完全是 javascript 创建出来的, 页面上自己写的那个表单, 只作为数据 clone 的载体, 所以只需要确保表单和其中的 file input 元素有自己的 id, 最后提交按钮的 onclick 事件指向了目标方法即可;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form_id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"str"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"file_attach"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"fileAttach"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"ajax_submit('file_attach')"</span>  <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-jQuery-ajax-结合-HTML5-API-实现文件上传"><a href="#使用-jQuery-ajax-结合-HTML5-API-实现文件上传" class="headerlink" title="使用 jQuery ajax 结合 HTML5 API 实现文件上传"></a><strong>使用 jQuery ajax 结合 HTML5 API 实现文件上传</strong></h3><p>使用 ajaxFileUplaod 插件, 无论怎么优化改造, 其需要使用 iframe 作间接无刷新的逻辑是没法绕开的; 而使用 iframe 必然会带来额外资源的消耗, 如果有更原生直接的解决方案, 我们一定乐于在项目中取代 ajaxFileUpload;<br>于是, 在 HTML5 时代, 出现了一个新的接口: <code>FormData</code>, 它给出了完美的解决方案;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form_content = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">"form_id"</span>));</span><br></pre></td></tr></table></figure></p><p>这行代码便拿到了目标表单对象的所有信息; 我们只需要确保表单的 enctype 属性为 <code>multipart/form-data</code>, 通过该接口获得的 FormData 对象, 便是完整的二进制序列化信息:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form_id"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"str"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"fileAttach"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"upload_file()"</span>  <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样, 一个 onclick 事件触发 upload_file 方法, 使用原生的 jQuery ajax 就实现了上传文件的功能了, 同时表单内的其他字符串数据, 也一并以 multi part 的形式上传上去了;<br>对应的 javascript upload_file 方法如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uplaod_file</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> form_content = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'form_id'</span>));</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">'POST'</span>,</span><br><span class="line">        url: <span class="string">'/xxx/yyy/upload'</span>,</span><br><span class="line">        data: form_content,</span><br><span class="line">        processData: <span class="literal">false</span>,     <span class="comment">// 阻止默认的 application/x-www-form-urlencoded 对象处理方法</span></span><br><span class="line">        contentType: <span class="literal">false</span>,     <span class="comment">// 与 processData 保持一直, 不使用默认的 application/x-www-form-urlencoded</span></span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data[<span class="string">'status'</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">                alert(<span class="string">"提交成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">                alert(<span class="string">"提交失败:"</span> + data[<span class="string">'message'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">            alert(<span class="string">"提交失败:"</span> + data[<span class="string">'message'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码需要注意的是:<br><code>processData</code> 参数默认为 true, 即将 data 转为 url 键值对形式, 这里已经是序列化后的二进制数据, 不需要再次处理,  所以应主动设置其为 false;<br>同时, <code>contentType</code> 默认为 <code>application/x-www-form-urlencoded</code>, 这里不应该使用默认值;<br>关于 jQuery ajax 方法, 更多的内容请参见: <a href="">jQuery ajax 阅读与理解</a>;<br>&nbsp;<br>这便是 HTML5 时代下,  ajax 异步上传文件的最佳实践;</p><h3 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h3><ul><li><a href="">一个 dev 的拙劣前端笔记: content-type 之 multipart/form-data 规范整理</a></li><li><a href="">jQuery ajax 阅读与理解</a></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="http://blog.csdn.net/qq_33556185/article/details/51086114" target="_blank" rel="noopener">jquery Ajax提交表单(使用jquery Ajax上传附件)</a></li><li><a href="https://www.cnblogs.com/zhanghaoliang/p/6513964.html" target="_blank" rel="noopener">JQuery的ajaxFileUpload的使用</a></li><li><a href="https://github.com/carlcarl/AjaxFileUpload/blob/master/ajaxfileupload.js" target="_blank" rel="noopener">carlcarl/AjaxFileUpload/ajaxfileupload.js</a></li><li><a href="http://blog.csdn.net/it_man/article/details/43800957" target="_blank" rel="noopener">jquery插件–ajaxfileupload.js上传文件原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从传统的刷新提交到 ajax 提交, 从间接的 iframe 刷新 ajax 提交到真正意义上的 ajax 提交, 关于前端文件上传的方法, 伴随着 web 技术与标准的演进, 不断推陈出新;&lt;br&gt;本文整理了从传统方式到 ajax 方式上传文件的各种方法;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://zshell.cc/categories/web/"/>
    
    
      <category term="ajax" scheme="http://zshell.cc/tags/ajax/"/>
    
      <category term="jQuery" scheme="http://zshell.cc/tags/jQuery/"/>
    
      <category term="文件上传" scheme="http://zshell.cc/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>logrotate 配置与运维</title>
    <link href="http://zshell.cc/2018/01/15/linux-varlog--logrotate%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    <id>http://zshell.cc/2018/01/15/linux-varlog--logrotate配置与运维/</id>
    <published>2018-01-14T16:23:27.000Z</published>
    <updated>2018-01-27T14:53:07.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要讨论以下几个方面:</p><ol><li>logrotate 的关键配置文件和配置项语法;</li><li>logrotate 的使用与运维技巧;</li><li>logrotate 的运行原理;</li><li>特殊场景下 logrotate 的代替方案;</li></ol></blockquote><a id="more"></a><hr><h3 id="配置文件与配置语法"><a href="#配置文件与配置语法" class="headerlink" title="配置文件与配置语法"></a><strong>配置文件与配置语法</strong></h3><p>logrotate 的配置文件主要是 <code>/etc/logrotate.conf</code> 和 <code>/etc/logrotate.d</code> 目录;<br>/etc/logrotate.conf 文件作为主配置文件, include 了 /etc/logrotate.d 目录下具体的配置内容;<br>以下是 /etc/logrotate.conf 的默认内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的历史日志保留周期单位: 周</span></span><br><span class="line">weekly</span><br><span class="line"><span class="comment"># 历史日志保留四个周期单位, 即四周, 一个月</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="comment"># use the syslog group by default, since this is the owning group of /var/log/syslog.</span></span><br><span class="line">su root syslog</span><br><span class="line"><span class="comment"># 当旧日志作了 rotate 之后, 将会创建一个和旧日志同名的新文件</span></span><br><span class="line">create</span><br><span class="line"><span class="comment"># 默认使用 gzip 压缩旧日志文件</span></span><br><span class="line">compress</span><br><span class="line"><span class="comment"># 将 /etc/logrotate.d 下面的所有独立配置文件都 include 进来</span></span><br><span class="line">include /etc/logrotate.d</span><br></pre></td></tr></table></figure></p><p>/etc/logrotate.conf 的默认配置优先级比 /etc/logrotate.d/ 目录下的独立配置要低, /etc/logrotate.d 下所有的独立配置文件中的配置项可以覆盖 /etc/logrotate.conf;<br>以 rsyslog 的配置文件为例, 以下是 /etc/logrotate.d/rsyslog 的内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/syslog &#123;</span><br><span class="line">    <span class="comment"># 以 天 为周期单位, 保留 7 天的日志</span></span><br><span class="line">    daily</span><br><span class="line">    rotate 7</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 忽略任何错误, 比如找不到文件</span></span><br><span class="line">    missingok</span><br><span class="line"></span><br><span class="line">    <span class="comment"># not if empty, 当日志内容为空时, 不作 rotate</span></span><br><span class="line">    notifempty</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 压缩日志, 但是采用延时压缩, 即本轮周期产生的日志不压缩, 而在下一个周期时压缩之</span></span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line"></span><br><span class="line">    <span class="comment"># postrotate/endscript 内的命令, 作为后处理, 会在本轮周期 rotate 之后回调执行</span></span><br><span class="line">    postrotate</span><br><span class="line">invoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以同时指定多个目标日志使用同一段配置</span></span><br><span class="line">/var/<span class="built_in">log</span>/mail.info</span><br><span class="line">/var/<span class="built_in">log</span>/mail.warn</span><br><span class="line">/var/<span class="built_in">log</span>/mail.err</span><br><span class="line">/var/<span class="built_in">log</span>/mail.log</span><br><span class="line">/var/<span class="built_in">log</span>/daemon.log</span><br><span class="line">/var/<span class="built_in">log</span>/kern.log</span><br><span class="line">/var/<span class="built_in">log</span>/auth.log</span><br><span class="line">/var/<span class="built_in">log</span>/user.log</span><br><span class="line">/var/<span class="built_in">log</span>/lpr.log</span><br><span class="line">/var/<span class="built_in">log</span>/cron.log</span><br><span class="line">/var/<span class="built_in">log</span>/debug</span><br><span class="line">/var/<span class="built_in">log</span>/messages &#123;</span><br><span class="line">    weekly</span><br><span class="line">    rotate 4</span><br><span class="line"></span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line"></span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 共享处理脚本, 仅对 prerotate/postrotate 定义时生效</span></span><br><span class="line">    sharedscripts</span><br><span class="line"></span><br><span class="line">    postrotate</span><br><span class="line">invoke-rc.d rsyslog rotate &gt; /dev/null</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意:</p><ol><li><code>sharedscripts</code> 选项打开后, 所有使用该段配置作 rotate 的目标日志名都会作为参数一次性传给 prerotate/postrotate;<br>而默认的选项 <code>nosharedscripts</code> 则是将每一个日志名分别作为参数传给 prerotate/postrotate;</li><li>logrotate 支持的周期单位, 有 hourly, daily, weekly, monthly; 但是这里有坑: hourly 默认是不生效的, 具体原因见本文第三节;</li></ol><p>&nbsp;<br>如上所叙, prerotate/postrotate 是一种在 rotate 过程中某个时机回调的一段脚本, 像这样类似的配置项总共有如下几种 (所有的配置项必须与 <code>endscript</code> 成对出现):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在所有匹配的日志 rotate 之前, 仅执行一次</span></span><br><span class="line">firstaction/endscript</span><br><span class="line"><span class="comment"># 在日志 rotate 之前回调</span></span><br><span class="line">prerotate/endscript</span><br><span class="line"><span class="comment"># 在日志 rotate 之后回调</span></span><br><span class="line">postrotate/endscript</span><br><span class="line"><span class="comment"># 在所有匹配的日志 rotate 之后, 仅执行一次</span></span><br><span class="line">lastaction/endscript</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个日志将要被删除之前回调执行</span></span><br><span class="line">preremove/endscript</span><br></pre></td></tr></table></figure></p><p>这几种回调时间点的设计, 不禁让人想到 junit 测试类几种注解的方法执行时机, 不得不说有异曲同工之妙;<br>&nbsp;<br>rsyslog 的 logrotate 配置是一个典型, 但同时 logrotate 还有着其他的个性化配置选项:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是另一段案例</span></span><br><span class="line">/var/<span class="built_in">log</span>/test.log &#123;</span><br><span class="line">    <span class="comment"># 不以时间为周期单位, 而是以 日志size 为周期单位, 当日志大小达到 100MB 时, 作一次 rotate, 日志保留 5 个周期</span></span><br><span class="line">    size=100M</span><br><span class="line">    rotate 5</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用日期命名 rotate 后的旧文件, 日期格式采用 -%Y-%m-%d</span></span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 以指定的权限掩码, owner/group 创建 rotate 后的新文件</span></span><br><span class="line">    create 644 root root</span><br><span class="line">    </span><br><span class="line">    postrotate</span><br><span class="line">        /usr/bin/killall -HUP rsyslogd</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logrotate-命令的常用运维选项"><a href="#logrotate-命令的常用运维选项" class="headerlink" title="logrotate 命令的常用运维选项"></a><strong>logrotate 命令的常用运维选项</strong></h3><p>1.指定目标配置文件, 手动执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将会执行 /etc/logrotate.d/ 下所有的配置</span></span><br><span class="line">logrotate /etc/logrotate.conf</span><br><span class="line"><span class="comment"># 将会只执行指定配置文件中的配置</span></span><br><span class="line">logrotate /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p><p>2.debug 验证配置文件正误:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d:   --debug</span></span><br><span class="line">&gt; logrotate -d /etc/logrotate.d/redis-server.log</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">reading config file /etc/logrotate.d/redis-server</span><br><span class="line">Handling 1 logs</span><br><span class="line">rotating pattern: /var/<span class="built_in">log</span>/redis/redis-server*.<span class="built_in">log</span>  weekly (12 rotations)</span><br><span class="line">empty <span class="built_in">log</span> files are not rotated, old logs are removed</span><br><span class="line">considering <span class="built_in">log</span> /var/<span class="built_in">log</span>/redis/redis-server.log</span><br><span class="line">  <span class="built_in">log</span> does not need rotating</span><br></pre></td></tr></table></figure></p><p>3.强制 rotate:<br>即便当前不满足 rotate 的条件, force rotate 也会强制作一次 rotate, 而那些超过指定轮数的旧日志将会被删除;<br>force rotate 比较适用于加入了新的配置文件, 需要对其存量历史立即作一次 rotate;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -f:   --force</span></span><br><span class="line">logrotate -f /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p><p>4.verbose 详细信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v:   --verbose</span></span><br><span class="line">logrotate -vf /etc/logrotate.d/xxx.log</span><br></pre></td></tr></table></figure></p><p>5.指定 logrotate 自身的日志文件路径:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -s:   --state</span></span><br><span class="line"><span class="comment"># 默认 logrotate 的日志路径: /var/lib/logrotate/status</span></span><br><span class="line">logrotate -s /tmp/logrotate.log /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p><h3 id="logrotate-的运行原理及其缺陷"><a href="#logrotate-的运行原理及其缺陷" class="headerlink" title="logrotate 的运行原理及其缺陷"></a><strong>logrotate 的运行原理及其缺陷</strong></h3><p>logrotate 并不是一个 daemon service, 其本质上只是一个 ‘什么时候调用就什么时候立即执行一次’ 的 C 程序;<br>所以 logrotate 的执行, 依赖于其他 daemon service 的调用, 那么最自然的就是通过 crond 定时任务来调用了;<br>默认情况下, logrotate 是一天被调用一次的, 因为与它相关的 crontab 配置在 <code>/etc/cron.daily</code> 里:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean non existent log file entries from status file</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/logrotate</span><br><span class="line"><span class="built_in">test</span> -e status || touch status</span><br><span class="line">head -1 status &gt; status.clean</span><br><span class="line">sed <span class="string">'s/"//g'</span> status | <span class="keyword">while</span> <span class="built_in">read</span> logfile date</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -e <span class="string">"<span class="variable">$logfile</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"\"<span class="variable">$logfile</span>\" <span class="variable">$date</span>"</span></span><br><span class="line"><span class="keyword">done</span> &gt;&gt; status.clean</span><br><span class="line">mv status.clean status</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x /usr/sbin/logrotate || <span class="built_in">exit</span> 0</span><br><span class="line">/usr/sbin/logrotate /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p><p>如本文第二节所述, 由于 logrotate 的执行方式是通过 cron 默认 1 天执行一次, 所以按小时 rotate 的 <code>hourly</code> 配置项, 默认是不生效的; logrotate 的 manual 文档里也有说明:</p><blockquote><p><code>hourly</code> Log files are rotated every hour. Note that usually logrotate is configured to be run by cron daily. You have to change this configuration and run logrotate hourly to be able to really rotate logs hourly.</p></blockquote><p>不过, 这还不是最大的问题, 毕竟我们只要把上述脚本放到 <code>cron.hourly</code> 里, 就能解决该问题;<br>这种靠定时任务来运行的方式, 最大的问题是: 当我们对某个日志配置成按 <code>size</code> 来 rotate 时, 无法做到当日志触达 size 条件时及时切分, 其所能实现的最小延时是一分钟 (当把 logrotate 脚本的定时任务配成 * * * * *, 即每分钟执行一次时), 没法更短了;</p><h3 id="其他的特殊场景"><a href="#其他的特殊场景" class="headerlink" title="其他的特殊场景"></a><strong>其他的特殊场景</strong></h3><p>logrotate 集日志切分, 日志压缩, 删除旧日志, 邮件提醒等功能为一体, 提供了非常完整的日志管理策略; 不过, 并不是所有的系统日志, 自身都不具有上述功能, 都需要依赖 logrotate 来管理自己;<br>有一个非常典型, 而且使用十分广泛的场景: tomcat web 服务器; 当我们在 tomcat 上部署的服务使用了诸如 logback 之类的第三方日志框架时, 日志切分, 日志压缩等服务它自己便能够胜任了 (与 logback 相关功能的文章请见: <a href="">logback appender 使用总结</a>), 而且我们绝大部分人 (去哪儿网), 即便不怎么接触 logback 的日志压缩功能, 也至少都习惯于使用 logback  <code>RollingFileAppender</code> 的基础功能去作日志切分;<br>基于以上, 我们只需要一个简单的脚本, 便能够满足日常的 tomcat web 服务器日志运维:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">HOUR1=$(date -d <span class="string">"1 hours ago"</span> +%F-%H)</span><br><span class="line">DATE7=$(date -d <span class="string">"7 days ago"</span> +%F-%H)</span><br><span class="line"><span class="comment"># for example: /home/web/my_server/logs</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `find /home/web/ -maxdepth 2 \( -<span class="built_in">type</span> d -o -<span class="built_in">type</span> l \) -name logs`; <span class="keyword">do</span></span><br><span class="line">        find -L <span class="variable">$i</span> -maxdepth 1 -<span class="built_in">type</span> f \( -name <span class="string">"*<span class="variable">$&#123;HOUR1&#125;</span>*"</span> -a ! -name <span class="string">"*.gz"</span> \) -<span class="built_in">exec</span> gzip &#123;&#125; \;</span><br><span class="line">        find -L <span class="variable">$i</span> -maxdepth 1 -<span class="built_in">type</span> f \( -name <span class="string">"*<span class="variable">$&#123;DATE7&#125;</span>*"</span> -a -name <span class="string">"*.gz"</span> \) -<span class="built_in">exec</span> rm -f &#123;&#125; \;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>本节内容讨论的是针对 tomcat web 系统上的日志切分, 压缩, 以及删除等常规运维内容; 其实, 针对公司各业务线 web 系统的业务日志, 除此之外至少还有另外两项重要的运维内容: <em>日志冷备份收集</em> 与 <em>日志实时收集及其可视化 (ELK)</em>; 与之相关的内容请参见如下文章: </p><ol><li><a href="">改造 flume-ng: 融入公司的技术体系</a>;</li><li><a href="">日志冷备份收集的方案选型</a>;</li></ol><h3 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h3><ul><li><a href="">cron 相关全梳理</a></li><li><a href="">logback appender 使用总结</a></li><li><a href="">改造 flume-ng: 融入公司的技术体系</a></li><li><a href="">日志冷备份收集的方案选型</a></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="https://linux.cn/article-4126-1.html" target="_blank" rel="noopener">Linux日志文件总管——logrotate</a></li><li><a href="https://huoding.com/2013/04/21/246" target="_blank" rel="noopener">被遗忘的 Logrotate</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要讨论以下几个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;logrotate 的关键配置文件和配置项语法;&lt;/li&gt;
&lt;li&gt;logrotate 的使用与运维技巧;&lt;/li&gt;
&lt;li&gt;logrotate 的运行原理;&lt;/li&gt;
&lt;li&gt;特殊场景下 logrotate 的代替方案;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zshell.cc/categories/linux/"/>
    
      <category term="varlog" scheme="http://zshell.cc/categories/linux/varlog/"/>
    
    
      <category term="linux:varlog" scheme="http://zshell.cc/tags/linux-varlog/"/>
    
  </entry>
  
  <entry>
    <title>财富先锋 2017 年各股池成绩单</title>
    <link href="http://zshell.cc/2017/12/31/%E8%AF%81%E5%88%B8-%E8%B4%A2%E5%AF%8C%E5%85%88%E9%94%8B--%E8%B4%A2%E5%AF%8C%E5%85%88%E9%94%8B2017%E5%B9%B4%E5%90%84%E8%82%A1%E6%B1%A0%E6%88%90%E7%BB%A9%E5%8D%95/"/>
    <id>http://zshell.cc/2017/12/31/证券-财富先锋--财富先锋2017年各股池成绩单/</id>
    <published>2017-12-31T14:00:00.000Z</published>
    <updated>2018-01-27T14:53:07.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;<br>‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;<br>不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;<br>另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;<br>各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;</p></blockquote><a id="more"></a><hr><h3 id="支撑压力"><a href="#支撑压力" class="headerlink" title="支撑压力"></a><strong>支撑压力</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E6%94%AF%E6%92%91%E5%8E%8B%E5%8A%9B.png" alt="2017 支撑压力 final review" title="">                </div>                <div class="image-caption">2017 支撑压力 final review</div>            </figure><h3 id="热点轮动"><a href="#热点轮动" class="headerlink" title="热点轮动"></a><strong>热点轮动</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E7%83%AD%E7%82%B9%E8%BD%AE%E5%8A%A8.png" alt="2017 热点轮动 final review" title="">                </div>                <div class="image-caption">2017 热点轮动 final review</div>            </figure><h3 id="股东增持"><a href="#股东增持" class="headerlink" title="股东增持"></a><strong>股东增持</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_%E8%82%A1%E4%B8%9C%E5%A2%9E%E6%8C%81.png" alt="2017 股东增持 final review" title="">                </div>                <div class="image-caption">2017 股东增持 final review</div>            </figure><h3 id="多头趋势"><a href="#多头趋势" class="headerlink" title="多头趋势"></a><strong>多头趋势</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/finance/rcmd_diary/2017_recommend_review_多头趋势.png" alt="2017 多头趋势 final review" title="">                </div>                <div class="image-caption">2017 多头趋势 final review</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;综合来看, 同花顺财富先锋 2017 年的几个股池系统的年度收益率还是比较令人满意的;&lt;br&gt;‘热点轮动’, ‘股东增持’ 两个股池系统的收益率达到了 200%, ‘支撑压力’ 股池系统的收益率超过 150%;&lt;br&gt;不过 ‘多头趋势’ 股池系统的表现比较糟糕, 2017 年净收益为负;&lt;br&gt;另外还有 ‘深一度’ 股池系统的收益率未显示相关指标, 暂无法统计;&lt;br&gt;各个股池系统 2017 年度收益率的指标, 反映出了各个选股策略在 2017 年 A 股市场上的成效; 以此为鉴, 2018 年的中国资本市场, 我们继续前行;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="证券" scheme="http://zshell.cc/categories/%E8%AF%81%E5%88%B8/"/>
    
      <category term="财富先锋" scheme="http://zshell.cc/categories/%E8%AF%81%E5%88%B8/%E8%B4%A2%E5%AF%8C%E5%85%88%E9%94%8B/"/>
    
    
      <category term="证券:财富先锋" scheme="http://zshell.cc/tags/%E8%AF%81%E5%88%B8-%E8%B4%A2%E5%AF%8C%E5%85%88%E9%94%8B/"/>
    
  </entry>
  
  <entry>
    <title>nginx module 使用总结: ngx_http_gzip_module</title>
    <link href="http://zshell.cc/2017/12/21/nginx-module--nginx_module_%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93_ngx_http_gzip_module/"/>
    <id>http://zshell.cc/2017/12/21/nginx-module--nginx_module_使用总结_ngx_http_gzip_module/</id>
    <published>2017-12-21T07:13:33.000Z</published>
    <updated>2018-05-13T06:36:48.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ngx_http_gzip_module 是十分有用的 nginx 模块, 其有效压缩了 http 请求大小, 节省了流量, 加快了传输速度, 提升了用户体验;<br>当然, 其在使用上也有一些坑, 本文将具体讨论一下相关内容;</p></blockquote><a id="more"></a><p>ngx_http_gzip_module 这个模块的名字其实是 <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">官方文档</a> 里定义的; 然而在 nginx 源码里 (v1.11.2), 这个模块所在的源码文件名叫 <code>src/http/ngx_http_gzip_filter_module.c</code>;</p><h3 id="gzip-模块的安装"><a href="#gzip-模块的安装" class="headerlink" title="gzip 模块的安装"></a><strong>gzip 模块的安装</strong></h3><p>ngx_http_gzip_module 编译默认安装, 无需额外操作;</p><h3 id="gzip-模块的配置"><a href="#gzip-模块的配置" class="headerlink" title="gzip 模块的配置"></a><strong>gzip 模块的配置</strong></h3><p>gzip 模块的配置可以在如下位置:</p><ol><li>nginx.conf 中的 http 指令域下;</li><li>某个具体 vhost.conf 配置下的 server 指令域下;</li><li>某个具体 server 指令下的 location 指令域下;</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span>  ngx_http_gzip_filter_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123; ngx_string(<span class="string">"gzip"</span>),</span><br><span class="line">      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF</span><br><span class="line">                        |NGX_CONF_FLAG,</span><br><span class="line">      ngx_conf_set_flag_slot,</span><br><span class="line">      NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">      offsetof(<span class="keyword">ngx_http_gzip_conf_t</span>, enable),</span><br><span class="line">      <span class="literal">NULL</span> &#125;,</span><br><span class="line">      </span><br><span class="line">    &#123; ngx_string(<span class="string">"gzip_buffers"</span>),</span><br><span class="line">      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,</span><br><span class="line">      ngx_conf_set_bufs_slot,</span><br><span class="line">      NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">      offsetof(<span class="keyword">ngx_http_gzip_conf_t</span>, bufs),</span><br><span class="line">      <span class="literal">NULL</span> &#125;,</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">      ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码片段列举了 <code>gzip</code> 指令与 <code>gzip_buffers</code>, 其余的指令与 <code>gzip_buffers</code> 在使用上下文设置上基本相同, 都是 <code>NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF</code>;<br>从源码中可以看出, 在 gzip 模块里, <code>gzip</code> 指令相比其他指令有一个特别的地方: 除了 http, server, location 之外, 还有一个地方可以使用 <code>gzip</code> 指令, <code>NGX_HTTP_LIF_CONF</code>, 即 location 指令域中的 if 配置下;</p><p>以下是一个典型完整的 gzip 配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启/关闭, 默认 off</span></span><br><span class="line">gzip on | off;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 response header 中包含 Via 头信息时, 根据 request header 中某些头信息决定是否需要开启 gzip, 默认 off</span></span><br><span class="line">gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 User-Agent 的值匹配, 针对部分请求不使用 gzip, 比如老旧的 IE6</span></span><br><span class="line">gzip_disable <span class="string">"msie6"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 response header 中添加 Vary: Accept-Encoding, 告诉 cache/cdn 同时缓存 压缩与非压缩两种版本的 response, 默认 off</span></span><br><span class="line">gzip_vary on | off;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 gzip 的最小 size, size 值取决于 Content-length 的值, 默认 20 bytes</span></span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 gzip 压缩缓冲区的 num 与 size</span></span><br><span class="line"><span class="comment"># 建议 num 为 cpu 核心数, size 为 cpu cache page 大小</span></span><br><span class="line">gzip_buffers 32 8k;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持 gzip 模块的最低 http 版本, 默认 1.1</span></span><br><span class="line">gzip_http_version 1.0;</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip 压缩级别, [1-9], 默认 1, 级别越高, 压缩率越高, 同时消耗的 cpu 资源越高</span></span><br><span class="line">gzip_comp_level 1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对哪些 Content-type 使用 gzip, 默认是 text/html</span></span><br><span class="line"><span class="comment"># text/html 不需要设置到 gzip_types 中, 在其他条件满足时, text/html 会自动被压缩</span></span><br><span class="line"><span class="comment"># 若设置了 text/html 反而会输出 warn </span></span><br><span class="line">gzip_types text/css application/javascript application/json;</span><br></pre></td></tr></table></figure></p><h3 id="gzip-模块实践中遇到的坑"><a href="#gzip-模块实践中遇到的坑" class="headerlink" title="gzip 模块实践中遇到的坑"></a><strong>gzip 模块实践中遇到的坑</strong></h3><p><strong>(1) gzip_comp_level 级别的选择</strong><br>在 <a href="https://serverfault.com/questions/253074/what-is-the-best-nginx-compression-gzip-level" target="_blank" rel="noopener">stackoverflow 上的一个问题</a> 里曾讨论到, gzip_comp_level 压缩级别, 虽然其越高压缩率越高, 但是压缩边际提升率在 level = 1 之后却是在下降的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对 text/html</span></span><br><span class="line">0    55.38 KiB (100.00% of original size)</span><br><span class="line">1    11.22 KiB ( 20.26% of original size)</span><br><span class="line">2    10.89 KiB ( 19.66% of original size)</span><br><span class="line">3    10.60 KiB ( 19.14% of original size)</span><br><span class="line">4    10.17 KiB ( 18.36% of original size)</span><br><span class="line">5     9.79 KiB ( 17.68% of original size)</span><br><span class="line">6     9.62 KiB ( 17.37% of original size)</span><br><span class="line">7     9.50 KiB ( 17.15% of original size)</span><br><span class="line">8     9.45 KiB ( 17.06% of original size)</span><br><span class="line">9     9.44 KiB ( 17.05% of original size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 application/x-javascript</span></span><br><span class="line">0    261.46 KiB (100.00% of original size)</span><br><span class="line">1     95.01 KiB ( 36.34% of original size)</span><br><span class="line">2     90.60 KiB ( 34.65% of original size)</span><br><span class="line">3     87.16 KiB ( 33.36% of original size)</span><br><span class="line">4     81.89 KiB ( 31.32% of original size)</span><br><span class="line">5     79.33 KiB ( 30.34% of original size)</span><br><span class="line">6     78.04 KiB ( 29.85% of original size)</span><br><span class="line">7     77.85 KiB ( 29.78% of original size)</span><br><span class="line">8     77.74 KiB ( 29.73% of original size)</span><br><span class="line">9     77.75 KiB ( 29.74% of original size)</span><br></pre></td></tr></table></figure></p><p>随着压缩级别的提高, 更高的 cpu 消耗却换不来有效的压缩提升效率; 所以 gzip_comp_level 的最佳实践是将其设为 1, 便足够了;<br>&nbsp;</p><p><strong>(2) gzip_min_length 的陷阱</strong><br>一般经验上, 我们会将 gzip_min_length 设置为 1KB, 以防止 response size 太小, 压缩后反而变大;<br>只是, ngx_http_gzip_module 取决于 response headers 里的 Content-length; 如果 response 里面有这个 header, 那没有任何问题, 但是如果 response 里面没这个 header, gzip_min_length 设置就失效了;<br>这种情况其实并不少见: <code>Transfer-Encoding: chunked</code>; </p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">Module ngx_http_gzip_module</a></li><li><a href="http://www.jianshu.com/p/af6304f7cbd6" target="_blank" rel="noopener">nginx の gzip 使用</a></li><li><a href="https://www.darrenfang.com/2015/01/setting-up-http-cache-and-gzip-with-nginx/" target="_blank" rel="noopener">加速nginx: 开启gzip和缓存</a></li><li><a href="http://www.webkaka.com/blog/archives/how-to-set-Vary-Accept-Encoding-header.html" target="_blank" rel="noopener">标头 “Vary:Accept-Encoding” 指定方法及其重要性分析</a></li><li><a href="https://serverfault.com/questions/253074/what-is-the-best-nginx-compression-gzip-level" target="_blank" rel="noopener">What is the best nginx compression gzip level</a></li><li><a href="https://segmentfault.com/q/1010000002686639" target="_blank" rel="noopener">关于 nginx 配置文件 gzip 的配置问题: 不太明白这个 gzip_proxied 的作用是什么, 应该如何正确配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ngx_http_gzip_module 是十分有用的 nginx 模块, 其有效压缩了 http 请求大小, 节省了流量, 加快了传输速度, 提升了用户体验;&lt;br&gt;当然, 其在使用上也有一些坑, 本文将具体讨论一下相关内容;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://zshell.cc/categories/nginx/"/>
    
      <category term="module" scheme="http://zshell.cc/categories/nginx/module/"/>
    
    
      <category term="nginx" scheme="http://zshell.cc/tags/nginx/"/>
    
      <category term="nginx:module" scheme="http://zshell.cc/tags/nginx-module/"/>
    
  </entry>
  
  <entry>
    <title>apache benchmark 使用笔记</title>
    <link href="http://zshell.cc/2017/11/25/linux-other--apache_benchmark_%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://zshell.cc/2017/11/25/linux-other--apache_benchmark_使用笔记/</id>
    <published>2017-11-25T12:41:55.000Z</published>
    <updated>2018-08-18T03:00:51.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>各个公司或多或少都在推出自己的压力测试工具, 形形色色, 种类繁多; 其实, 在开源世界已经有了一个经典成熟的压力测试工具 —- apache benchmark;<br>小巧, 简单, 基于 http 的普适性, 这些都是 apache benchmark 被广泛使用的原因;</p></blockquote><a id="more"></a><hr><p>apache benchmark, 其对应的命令被简称为 ab, 是 httpd-tools 里使用最广泛的工具;</p><h2 id="httpd-tools-安装"><a href="#httpd-tools-安装" class="headerlink" title="httpd-tools 安装"></a><strong>httpd-tools 安装</strong></h2><p>直接用 yum install ab 是找不到软件包的, 因为 ab 并没有单独提供, 而是封装在 httpd-tools 里面;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y httpd-tools</span><br></pre></td></tr></table></figure></p><p>安装完后, httpd-tools 提供的系列工具如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apache benchmark</span><br><span class="line"></span><br><span class="line">htdbm</span><br><span class="line">htdigest</span><br><span class="line">htpassword</span><br><span class="line">httxt2dbm</span><br><span class="line">logresolve</span><br></pre></td></tr></table></figure></p><p>后面的 5 个工具, 都是与 apache 服务器相关的辅助工具, 一旦脱离了 apache server 则作用有限; 但是 apache benchmark 却不一样, 虽然它本来的设计目的也是为了压测 apache server, 但既然是 http 请求, 那么大部分 web server 都可以使用其作压力测试;</p><h2 id="ab-的使用方法"><a href="#ab-的使用方法" class="headerlink" title="ab 的使用方法"></a><strong>ab 的使用方法</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单使用: -c concurrency 并发数; -n requests 请求数量</span></span><br><span class="line">ab -n 10000 -c 100 <span class="variable">$&#123;target_url&#125;</span></span><br><span class="line"><span class="comment"># post 请求: -p 指定需要 post 的数据文件, -T 指定 content-type</span></span><br><span class="line">ab -n 10000 -c 100 -p params.file -T <span class="string">'application/x-www-form-urlencoded'</span> <span class="variable">$&#123;target_url&#125;</span></span><br><span class="line"><span class="comment"># -s: timeout, 单位为秒</span></span><br><span class="line">ab -n 10000 -c 100 -s 20 <span class="variable">$&#123;target_url&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -t: timelimit, 指定本次压测的最长时间限制</span></span><br><span class="line"><span class="comment"># 如果不指定 -n, 这里还会默认指定一个 -n 50000</span></span><br><span class="line">ab -c 100 -s 20 -t 60000 <span class="variable">$&#123;target_url&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -r: 当发生 socket error 时不退出, 而是继续执行请求</span></span><br><span class="line"><span class="comment"># -k: 在 http 请求的 headers 中加上 Connection: keep-alive, 以保持连接 </span></span><br><span class="line">ab -n 10000 -c 100 -r -k <span class="variable">$&#123;target_url&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将压测数据记录为 gunplot 可以分析的 dump 文件, 以供其渲染</span></span><br><span class="line">ab -n 10000 -c 100 -g data.plt <span class="variable">$&#123;target_url&#125;</span></span><br></pre></td></tr></table></figure><h2 id="ab-的输出分析"><a href="#ab-的输出分析" class="headerlink" title="ab 的输出分析"></a><strong>ab 的输出分析</strong></h2><h3 id="顺利完成测试任务的输出"><a href="#顺利完成测试任务的输出" class="headerlink" title="顺利完成测试任务的输出"></a><strong>顺利完成测试任务的输出</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部分 version, licene 信息已省略</span></span><br><span class="line">&gt; ab -n 100 -c 10 http://www.baidu.com/</span><br><span class="line">......</span><br><span class="line">Server Software:        BWS/1.1</span><br><span class="line">Server Hostname:        www.baidu.com</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        111488 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   2.055 seconds</span><br><span class="line">Complete requests:      100</span><br></pre></td></tr></table></figure><p>这里有一个需要注意的地方: failed requests;<br>ab 请求失败的原因分为几类:</p><ul><li>Connect: tcp 连接错误, 属于网路问题;</li><li>Length: http response 的 Content-Length 与第一次接收的值不一致, 这种属于业务问题, 并不能严格将其归为失败;</li><li>Exceptions: 服务器端异常, 一般 status code 为 5XX;</li></ul><p>不过, 如果返回客户端错误 4XX, ab 不会判定为 failed requests, 这里需要注意;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed requests:        89 (Connect: 0, Receive: 0, Length: 89, Exceptions: 0)</span><br></pre></td></tr></table></figure><p>如上所示, 像 baidu.com 这种属于动态网页, 每次返回的内容长度不固定, 所以大量请求被 ab 判定为 failed requests;<br>类似这种情况的场景很多, 所以这就提醒我们在使用 ab 作压力测试时, 构造的 mock 接口一定要能够返回固定长度的内容, 而被测试接口的返回内容校验, 应该放在 mock 接口内部逻辑中实现; 一旦校验失败, 不要在返回内容上作标记, 而是直接抛出异常, 以让 ab 识别为 failed requests;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      11320607 bytes</span><br><span class="line">HTML transferred:       11223796 bytes</span><br><span class="line">Requests per second:    48.65 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       205.533 [ms] (mean)</span><br><span class="line">Time per request:       20.553 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          5378.84 [Kbytes/sec] received</span><br></pre></td></tr></table></figure><p>传输各个阶段的统计指标:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Connection Times (ms)</span><br><span class="line"><span class="comment">#             最短时间  平均时间    标准差  中位数时间  最长时间</span></span><br><span class="line">              min       mean        [+/-sd]     median      max</span><br><span class="line">Connect:       36         38            0.8         38       39</span><br><span class="line">Processing:   113        154           14.5        152      198</span><br><span class="line">Waiting:       37         39            1.0         39       42</span><br><span class="line">Total:        150        192           14.7        190      237</span><br></pre></td></tr></table></figure></p><p>最后是 rt 响应时间的分位数统计:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    190</span><br><span class="line">  66%    192</span><br><span class="line">  75%    194</span><br><span class="line">  80%    195</span><br><span class="line">  90%    198</span><br><span class="line">  95%    230</span><br><span class="line">  98%    234</span><br><span class="line">  99%    237</span><br><span class="line"> 100%    237 (longest request)</span><br></pre></td></tr></table></figure></p><h3 id="测试被迫终止"><a href="#测试被迫终止" class="headerlink" title="测试被迫终止"></a><strong>测试被迫终止</strong></h3><p>以上是一个顺利完成压测任务的输出; 有的时候压力测试并不会很顺利得结束, 如果压得比较猛, 可能待测服务会发生各种问题, 这时 ab 就有可能被迫提前终止任务;<br><strong>情况一 tcp connection error</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apr_socket_recv: Connection timed out (110)</span><br><span class="line">apr_socket_recv: Connection reset by peer (104)</span><br></pre></td></tr></table></figure></p><p>当 ab 遇到 connection error 时默认会直接 exit; 此时可以使用 -r 选项:</p><blockquote><p>-r     Don’t exit on socket receive errors.</p></blockquote><p>这样 ab 就不会在遇到 connection error 时退出了; 但这有时并不能从根本上解决问题, 比如在某些高并发环境下, 待测服务所在的系统内核开启了 SYN flood 攻击保护, 故意拖慢了请求速度, 造成 connection error, 这可能会导致所有的请求都失败, 从而失去了压测意义; 这种情况下, 往往需要调整内核参数, 关闭一些安全保护:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭洪流攻击保护</span></span><br><span class="line">net.ipv4.tcp_syncookies = 0</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br><strong>情况二 tcp read/write error</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apr_pollset_poll: The timeout specified has expired (70007)</span><br></pre></td></tr></table></figure></p><p>以上输出反映了 ab 在测试途中遇到了 read/write timeout, 请求服务超过了选项 -s 设置的 timeout 时间; 这其实是一个不合理的设计, 一个请求超时是很正常的事情, 但是它一遇到超时就直接 exit, 这就让使用者不爽了, 它完全可以放到最后的统计里面的;<br>但是除非你修改 ab 的 source code 重新编译, 否则对于这种错误你也只能是修改 -s 增大超时时间了;</p><h2 id="一个典型的使用实践"><a href="#一个典型的使用实践" class="headerlink" title="一个典型的使用实践"></a><strong>一个典型的使用实践</strong></h2><p>光说不练肯定是不行的, 这里正好有一个比较系统性地压力测试报告, 其将 apache benchmark 作为了一个主要的分析工具, 可以分享一下: <a href="http://zshell.cc/2018/08/12/linux-other--berkeley_db7.x压力测试报告">berkeley db 7.x 压力测试报告</a>;</p><h2 id="其他类似工具"><a href="#其他类似工具" class="headerlink" title="其他类似工具"></a><strong>其他类似工具</strong></h2><p>有一个与 ab 类似的开源 http 压力测试工具: <a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wrk - a HTTP benchmarking tool</a>, 在 github 上也获得了 1.7 万的 stars;<br>wrk 与 ab 的类似之处在于它们都是基于 http 的命令行工具, 通过命令选项控制压测条件; 但是 wrk 在某种程度上只能算是 ab 的一个子集:<br>wrk 只能通过给定一个确定的压测时间限制, 在给定的时间内以给定的并发度请求, 当时间到了, 压力测试结束, 其并不能设置请求多少次后结束测试;<br>另外, wrk 的输出与 ab 也不太相同:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Running 30s <span class="built_in">test</span> @ http://127.0.0.1:8080/index.html</span><br><span class="line">  12 threads and 400 connections</span><br><span class="line">  </span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   635.91us    0.89ms  12.92ms   93.69%</span><br><span class="line">    Req/Sec    56.20k     8.07k   62.00k    86.54%</span><br><span class="line">    </span><br><span class="line">  22464657 requests <span class="keyword">in</span> 30.00s, 17.76GB <span class="built_in">read</span></span><br><span class="line">  </span><br><span class="line">Requests/sec: 748868.53</span><br><span class="line">Transfer/sec:    606.33MB</span><br></pre></td></tr></table></figure></p><p>相比 ab 的报告略显简洁, 只能说是见仁见智吧;</p><h2 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h2><ul><li><a href="http://zshell.cc/2018/08/12/linux-other--berkeley_db7.x压力测试报告">berkeley db 7.x 压力测试报告</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul><li><a href="https://www.mankier.com/package/httpd-tools" target="_blank" rel="noopener">Package httpd-tools</a></li><li><a href="http://blog.csdn.net/sangyongjia/article/details/49093945" target="_blank" rel="noopener">Apache Benchmark安装、参数含义&amp;使用总结、结果分析</a></li><li><a href="http://www.ttlsa.com/web/analysis-of-ab-output-information-interpretation-and-failed-requests/" target="_blank" rel="noopener">ab输出信息解释以及Failed requests原因分析</a></li><li><a href="https://www.douban.com/note/501373268/" target="_blank" rel="noopener">apachebench(ab)压测遇到问题的解决方案记录</a></li><li><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener">ab - Apache HTTP server benchmarking tool</a></li><li><a href="http://www.cnblogs.com/archoncap/p/5883723.html" target="_blank" rel="noopener">apache ab压力测试报错 (apr_socket_recv: Connection reset by peer (104))</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;各个公司或多或少都在推出自己的压力测试工具, 形形色色, 种类繁多; 其实, 在开源世界已经有了一个经典成熟的压力测试工具 —- apache benchmark;&lt;br&gt;小巧, 简单, 基于 http 的普适性, 这些都是 apache benchmark 被广泛使用的原因;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zshell.cc/categories/linux/"/>
    
      <category term="other" scheme="http://zshell.cc/categories/linux/other/"/>
    
    
      <category term="linux:other" scheme="http://zshell.cc/tags/linux-other/"/>
    
      <category term="linux:perf" scheme="http://zshell.cc/tags/linux-perf/"/>
    
  </entry>
  
</feed>
