<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    <link rel="canonical" href="http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/">
    
    
    <title>jstack 命令使用经验总结 | 希尔的博客 | 兰之猗猗，扬扬其香。不采而佩，于兰何伤？</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="jvm:tools">
    <meta name="description" content="jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;以往对于 jstack 产生的 thread dump, 我很少字斟句酌得分析过每一部分细节, 针对 jstack 的性能诊断也没有一个模式化的总结; 今天这篇文章我就来详细整理一下与 jstack 相关的内容;">
<meta name="keywords" content="jvm:tools">
<meta property="og:type" content="article">
<meta property="og:title" content="jstack 命令使用经验总结">
<meta property="og:url" content="http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/index.html">
<meta property="og:site_name" content="希尔的博客">
<meta property="og:description" content="jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;以往对于 jstack 产生的 thread dump, 我很少字斟句酌得分析过每一部分细节, 针对 jstack 的性能诊断也没有一个模式化的总结; 今天这篇文章我就来详细整理一下与 jstack 相关的内容;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-06-16T12:16:42.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jstack 命令使用经验总结">
<meta name="twitter:description" content="jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;以往对于 jstack 产生的 thread dump, 我很少字斟句酌得分析过每一部分细节, 针对 jstack 的性能诊断也没有一个模式化的总结; 今天这篇文章我就来详细整理一下与 jstack 相关的内容;">
    
        <link rel="alternate" type="application/atom+xml" title="希尔的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <script src="/js/leancloud-revision.js"></script>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">zshell.zhang</h5>
          <a href="mailto:xaaservice@gmail.com" title="xaaservice@gmail.com" class="mail">xaaservice@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zshellzhang1993-2025" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">jstack 命令使用经验总结</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">jstack 命令使用经验总结</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-09-24T09:11:51.000Z" itemprop="datePublished" class="page-time">
  2017-09-24
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/">jvm</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/tools/">tools</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jstack-命令的基本使用"><span class="post-toc-number">1.</span> <span class="post-toc-text">jstack 命令的基本使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jstack-输出内容结构分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">jstack 输出内容结构分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#输出内容的结构"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">输出内容的结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程的动作"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">线程的动作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程的状态"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">线程的状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程的重要调用修饰"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">线程的重要调用修饰</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁检测的展示"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">死锁检测的展示</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常见-java-进程的-jstack-dump-特征"><span class="post-toc-number">3.</span> <span class="post-toc-text">常见 java 进程的 jstack dump 特征</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#纯-tomcat-容器"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">纯 tomcat 容器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tomcat-with-dubbo"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">tomcat with dubbo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#elasticsearch-datanode-节点"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">elasticsearch datanode 节点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#相关衍生工具"><span class="post-toc-number">4.</span> <span class="post-toc-text">相关衍生工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用代码作-thread-dump"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">使用代码作 thread dump</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程性能诊断的辅助脚本"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">线程性能诊断的辅助脚本</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#thread-dump-可视化分析工具"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">thread dump 可视化分析工具</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考链接"><span class="post-toc-number">5.</span> <span class="post-toc-text">参考链接</span></a></li></ol>
        </nav>
    </aside>


<article id="post-jvm-tools--jstack命令使用经验总结"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">jstack 命令使用经验总结</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-09-24 17:11:51" datetime="2017-09-24T09:11:51.000Z"  itemprop="datePublished">2017-09-24</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/">jvm</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/tools/">tools</a></li></ul></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;<br>以往对于 jstack 产生的 thread dump, 我很少字斟句酌得分析过每一部分细节, 针对 jstack 的性能诊断也没有一个模式化的总结; 今天这篇文章我就来详细整理一下与 jstack 相关的内容;</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="jstack-命令的基本使用"><a href="#jstack-命令的基本使用" class="headerlink" title="jstack 命令的基本使用"></a><strong>jstack 命令的基本使用</strong></h2><p>jstack 在命令使用上十分简洁, 其信息量与复杂度主要体现在 thread dump 内容的分析上;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最基本的使用</span></span><br><span class="line">sudo -u xxx jstack &#123;vmid&#125;</span><br><span class="line"><span class="comment"># 从 core dump 中提取 thread dump</span></span><br><span class="line">sudo -u xxx jstack core_file_path</span><br><span class="line"><span class="comment"># 除了基本输出外, 额外展示 AbstractOwnableSynchronizer 锁的占有信息</span></span><br><span class="line"><span class="comment"># 可能会消耗较长时间</span></span><br><span class="line">sudo -u xxx jstack -l &#123;vmid&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="jstack-输出内容结构分析"><a href="#jstack-输出内容结构分析" class="headerlink" title="jstack 输出内容结构分析"></a><strong>jstack 输出内容结构分析</strong></h2><p>首先展示几段 thread dump 的典型例子:<br>正在 RUNNING 中的线程:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"elasticsearch[datanode-39][[xxx_index_v4][9]: Lucene Merge Thread #2403]"</span> #<span class="number">45061</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fb968213800</span> nid=<span class="number">0x249ca</span> runnable [<span class="number">0x00007fb6843c2000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        ...</span><br><span class="line">        at org.elasticsearch.index.engine.ElasticsearchConcurrentMergeScheduler.doMerge(ElasticsearchConcurrentMergeScheduler.java:<span class="number">94</span>)</span><br><span class="line">        at org.apache.lucene.index.ConcurrentMergeScheduler$MergeThread.run(ConcurrentMergeScheduler.java:<span class="number">626</span>)</span><br></pre></td></tr></table></figure></p>
<p>阻塞在 java.util.concurrent.locks.Condition 上:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"DubboServerHandler-10.64.16.66:20779-thread-510"</span> #<span class="number">631</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fb6f4ce5800</span> nid=<span class="number">0x1743</span> waiting on condition [<span class="number">0x00007fb68ed2f000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000e2978ef0</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>阻塞在内置锁上:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"qtp302870502-26-acceptor-0@45ff00a-ServerConnector@63475ace&#123;HTTP/1.1&#125;&#123;0.0.0.0:9088&#125;"</span> #<span class="number">26</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f1830d3a800</span> nid=<span class="number">0xdf64</span> waiting <span class="keyword">for</span> monitor entry [<span class="number">0x00007f16b5ef9000</span>]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:<span class="number">234</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000c07549f8</span>&gt; (a java.lang.Object)</span><br><span class="line">        at org.eclipse.jetty.server.ServerConnector.accept(ServerConnector.java:<span class="number">377</span>)</span><br><span class="line">        ...</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"JFR request timer"</span> #<span class="number">6</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fc2f6b1f800</span> nid=<span class="number">0x18070</span> in Object.wait() [<span class="number">0x00007fb9aa96b000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.util.TimerThread.mainLoop(Timer.java:<span class="number">526</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">        at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br></pre></td></tr></table></figure>
<p>以上展示了四个线程的 jstack dump, 有 running 状态, 也有阻塞状态, 覆盖面广, 具有典型性; 下面来对 jstack 的输出内容作详细梳理;</p>
<h3 id="输出内容的结构"><a href="#输出内容的结构" class="headerlink" title="输出内容的结构"></a><strong>输出内容的结构</strong></h3><p>首先还是要说一下 jstack 输出的内容结构, 就以上方举的第四个线程为例:<br>以下是第一部分内容, 记录了线程的一些基本信息, 从左到右每个元素的含义已经以注释标注在元素上方; 其中比较重要的是 <code>nid</code>, 它是 java 线程与操作系统的映射, 在 linux 中它和与其对应的轻量级进程 pid 相同 (需要十六进制与十进制转换), 这将为基于 java 线程的性能诊断带来帮助, 详细请见本文后面段落 <a href="#线程性能诊断的辅助脚本">#线程性能诊断的辅助脚本</a>;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//|-----线程名------| |-线程创建次序-| |是否守护进程| |---线程优先级---| |-------线程 id-------| |-所映射的linux轻量级进程id-| |-------------线程动作--------------|</span></span><br><span class="line">  <span class="string">"JFR request timer"</span> #<span class="number">6</span>              daemon        prio=<span class="number">5</span> os_prio=<span class="number">0</span>  tid=<span class="number">0x00007fc2f6b1f800</span> nid=<span class="number">0x18070</span>                 in Object.wait() [<span class="number">0x00007fb9aa96b000</span>]</span><br></pre></td></tr></table></figure></p>
<p>以下是第二部分内容, 表示线程当前的状态;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br></pre></td></tr></table></figure></p>
<p>以下是第三部分内容, 主要记录了线程的调用栈; 其中比较重要的是一些关键调用上的 <a href="#线程的重要调用修饰">#动作修饰</a>, 这些为线程死锁问题的排查提供了依据;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">at java.util.TimerThread.mainLoop(Timer.java:<span class="number">526</span>)</span><br><span class="line">- locked &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="线程的动作"><a href="#线程的动作" class="headerlink" title="线程的动作"></a><strong>线程的动作</strong></h3><p>线程动作的记录在每个 thread dump 的第一行末尾, 一般情况下可分为如下几类:</p>
<ol>
<li><code>runnable</code>, 表示线程在参与 cpu 资源的竞争, 可能在被调度运行也可能在就绪等待;</li>
<li><code>sleeping</code>, 表示调用了 Thread.sleep(), 线程进入休眠;</li>
<li><code>waiting for monitor entry [0x...]</code>, 表示线程在试图获取内置锁, 进入了等待区 Entry Set, 方括号内的地址表示线程等待的资源地址;</li>
<li><code>in Object.wait() [0x...]</code>, 表示线程调用了 object.wait(), 放弃了内置锁, 进入了等待区 Wait Set, 等待被唤醒, 方括号内的地址表示线程放弃的资源地址;</li>
<li><code>waiting on condition [0x...]</code>, 表示线程被阻塞原语所阻塞, 方括号内的地址表示线程等待的资源地址; 这种和 jvm 的内置锁体系没有关系, 它是 jdk5 之后的 java.util.concurrent 包下的锁机制;</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h3><p>线程的状态记录在每个 thread dump 的第二行, 并以 java.lang.Thread.State 开头, 一般情况下可分为如下几类:</p>
<ol>
<li><code>RUNNABLE</code>, 这种一般与线程动作 <code>runnable</code> 一起出现;</li>
<li><code>BLOCKED (on object monitor)</code>, 这种一般与线程动作 <code>waiting for monitor entry</code> 一起出现, 不过在其线程调用栈最末端并没有一个固定的方法, 因为 <code>synchronized</code> 关键字可以修饰各种方法或者同步块;</li>
<li><code>WAITING (on object monitor)</code> 或者 <code>TIMED_WAITING (on object monitor)</code>, 这种一般与线程动作 <code>in Object.wait() [0x...]</code> 一起出现, 并且线程调用栈的最末端调用方法为 at java.lang.Object.wait(Native Method), 以表示 object.wait() 方法的调用;<br>另外, <code>WAITING</code> 与 <code>TIMED_WAITING</code> 的区别在于是否设置了超时中断, 即 <code>wait(long timeout)</code> 与 <code>wait()</code> 的区别;</li>
<li><code>WAITING (parking)</code> 或者 <code>TIMED_WAITING (parking)</code>, 这种一般与线程动作 <code>waiting on condition [0x...]</code> 一起出现, 并且线程调用栈的最末端调用方法一般为 at sun.misc.Unsafe.park(Native Method);<br>Unsafe.park 使用的是线程阻塞原语, 主要在 java.util.concurrent.locks.AbstractQueuedSynchronizer 类中被使用到, 很多基于 AQS 构建的同步工具, 如 ReentrantLock, Condition, CountDownLatch, Semaphore 等都会诱发线程进入该状态;<br>另外, <code>WAITING</code> 与 <code>TIMED_WAITING</code> 的区别与第三点中提到的原因一致;</li>
</ol>
<h3 id="线程的重要调用修饰"><a href="#线程的重要调用修饰" class="headerlink" title="线程的重要调用修饰"></a><strong>线程的重要调用修饰</strong></h3><p>thread dump 的第三部分线程调用栈中, 一般会把与锁相关的资源使用状态以附加的形式作重点修饰, 这与线程的动作及状态有着密切的联系, 一般情况下可分为如下几类:</p>
<ol>
<li><code>locked &lt;0x...&gt;</code>, 表示其成功获取了内置锁, 成为了 owner;</li>
<li><code>parking to wait for &lt;0x...&gt;</code>, 表示其被阻塞原语所阻塞, 通常与线程动作 <code>waiting on condition</code> 一起出现;</li>
<li><code>waiting to lock &lt;0x...&gt;</code>, 表示其在 Entry Set 中等待某个内置锁, 通常与线程动作 <code>waiting for monitor entry</code> 一起出现;</li>
<li><code>waiting on &lt;0x...&gt;</code>, 表示其在 Wait Set 中等待被唤醒, 通常与线程动作 <code>in Object.wait() [0x...]</code> 一起出现;<br>另外, waiting on 调用修饰往往与 locked 调用修饰一同出现, 如之前列举的第四个 thread dump:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">  - waiting on &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">  at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">  at java.util.TimerThread.mainLoop(Timer.java:<span class="number">526</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x00007fba6b50ea38</span>&gt; (a java.util.TaskQueue)</span><br><span class="line">  at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这是因为该线程之前获得过该内置锁, 现在因为 object.wait() 又将其放弃了, 所以在调用栈中会出现先后两个调用修饰;</p>
<h3 id="死锁检测的展示"><a href="#死锁检测的展示" class="headerlink" title="死锁检测的展示"></a><strong>死锁检测的展示</strong></h3><p>在 jdk5 之前, Doug Lea 大神还没有发布 java.util.concurrent 包, 这个时候提及的锁, 就仅限于 jvm 监视器内置锁; 此时如果进程内有死锁发生, jstack 将会把死锁检测信息打印出来:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-xxx"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0134003ae8</span> (object <span class="number">0x00000007d6aa2c98</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"Thread-yyy"</span></span><br><span class="line"><span class="string">"Thread-yyy"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0134006168</span> (object <span class="number">0x00000007d6aa2ca8</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"Thread-xxx"</span></span><br><span class="line"></span><br><span class="line">Java <span class="built_in">stack</span> information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-xxx"</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="string">"Thread-yyy"</span>:</span><br><span class="line">    ...</span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure></p>
<p>然而后来 Doug Lea 发布了 java.util.concurrent 包, 当谈及 java 的锁, 除了内置锁之外还有了基于 AbstractOwnableSynchronizer 的各种形式; 由于是新事物, 彼时 jdk5 的 jstack 没有及时提供对以 AQS 构建的同步工具的死锁检测功能, 直到 jdk6 才完善了相关支持;</p>
<h2 id="常见-java-进程的-jstack-dump-特征"><a href="#常见-java-进程的-jstack-dump-特征" class="headerlink" title="常见 java 进程的 jstack dump 特征"></a><strong>常见 java 进程的 jstack dump 特征</strong></h2><p>首先, 不管是什么类型的 java 应用, 有一些通常都会存在的线程:</p>
<p><strong>VM Thread 与 VM Periodic Task Thread</strong><br>虚拟机线程, 属于 native thread, 凌驾与其他用户线程之上;<br>VM Periodic Task Thread 通常用于虚拟机作 sampling/profiling, 收集系统运行信息, 为 JIT 优化作决策依据;</p>
<p><strong>C1 / C2 CompilerThread</strong><br>虚拟机的 JIT 及时编译器线程:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C1 CompilerThread2"</span> #<span class="number">10</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007feb34114000</span> nid=<span class="number">0x18b2</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">"C2 CompilerThread1"</span> #<span class="number">9</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007feb34112000</span> nid=<span class="number">0x18b1</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">"C2 CompilerThread0"</span> #<span class="number">8</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007feb3410f800</span> nid=<span class="number">0x18b0</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure></p>
<p><strong>Reference Handler 线程与 Finalizer 线程</strong><br>这两个线程用于虚拟机处理 override 了 Object.finalize() 方法的实例, 对实例回收前作最后的判决;<br>Reference Handler 线程用于将目标对象放入 reference queue:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Reference Handler"</span> #<span class="number">2</span> daemon prio=<span class="number">10</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f91e007f000</span> nid=<span class="number">0xa80</span> in Object.wait() [<span class="number">0</span>x...]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">157</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000c0495140</span>&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure></p>
<p>Finalizer 线程用于从 reference queue 中取出对象以执行其 finalize 方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Finalizer"</span> #<span class="number">3</span> daemon prio=<span class="number">8</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f91e0081000</span> nid=<span class="number">0xa81</span> in Object.wait() [<span class="number">0</span>x...]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000c008db88</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">209</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>gc 线程</strong><br>这块对于不同的 gc 收集器选型有各自不同的线程状态 (线程数视 cpu 核心数而定);<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parallel Scavenge</span></span><br><span class="line"><span class="string">"GC task thread#0 (ParallelGC)"</span> os_prio=0 tid=0x00007f91e0021000 nid=0xa7a runnable </span><br><span class="line"><span class="string">"GC task thread#1 (ParallelGC)"</span> os_prio=0 tid=0x00007f91e0023000 nid=0xa7b runnable</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ParNew</span></span><br><span class="line"><span class="string">"Gang worker#0 (Parallel GC Threads)"</span> os_prio=0 tid=0x00007feb3401e800 nid=0x18a4 runnable </span><br><span class="line"><span class="string">"Gang worker#1 (Parallel GC Threads)"</span> os_prio=0 tid=0x00007feb34020000 nid=0x18a5 runnable</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMS</span></span><br><span class="line"><span class="string">"Concurrent Mark-Sweep GC Thread"</span> os_prio=0 tid=0x00007feb34066800 nid=0x18a8 runnable</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># G1</span></span><br><span class="line"><span class="string">"G1 Main Concurrent Mark GC Thread"</span> os_prio=0 tid=0x00007fc2f4091800 nid=0x1805e runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#0 (G1 Parallel Marking Threads)"</span> os_prio=0 tid=0x00007fc2f4093800 nid=0x1805f runnable </span><br><span class="line"><span class="string">"Gang worker#1 (G1 Parallel Marking Threads)"</span> os_prio=0 tid=0x00007fc2f4095800 nid=0x18060 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"G1 Concurrent Refinement Thread#0"</span> os_prio=0 tid=0x00007fc2f4079000 nid=0x1805d runnable </span><br><span class="line"><span class="string">"G1 Concurrent Refinement Thread#1"</span> os_prio=0 tid=0x00007fc2f4077000 nid=0x1805c runnable</span><br></pre></td></tr></table></figure>
<p>以上便是 java 进程里通常都会存在的线程;</p>
<h3 id="纯-tomcat-容器"><a href="#纯-tomcat-容器" class="headerlink" title="纯 tomcat 容器"></a><strong>纯 tomcat 容器</strong></h3><h3 id="tomcat-with-dubbo"><a href="#tomcat-with-dubbo" class="headerlink" title="tomcat with dubbo"></a><strong>tomcat with dubbo</strong></h3><h3 id="elasticsearch-datanode-节点"><a href="#elasticsearch-datanode-节点" class="headerlink" title="elasticsearch datanode 节点"></a><strong>elasticsearch datanode 节点</strong></h3><h2 id="相关衍生工具"><a href="#相关衍生工具" class="headerlink" title="相关衍生工具"></a><strong>相关衍生工具</strong></h2><h3 id="使用代码作-thread-dump"><a href="#使用代码作-thread-dump" class="headerlink" title="使用代码作 thread dump"></a><strong>使用代码作 thread dump</strong></h3><p>除了使用 jstack 之外, 还有其他一些方法可以对 java 进程作 thread dump, 如果将其封装为 http 接口, 便可以不用登陆主机, 直接在浏览器上查询 thread dump 的情况;<br><strong>使用 jmx 的 api</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">threadDump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">   <span class="keyword">for</span> (ThreadInfo threadInfo : threadMxBean.dumpAllThreads(<span class="keyword">true</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">       <span class="comment">// deal with threadInfo.toString()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用 Thread.getAllStackTraces() 方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadDump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread.getAllStackTraces().entrySet()) &#123;</span><br><span class="line">        Thread thread = (Thread) stackTrace.getKey();</span><br><span class="line">        StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();</span><br><span class="line">        <span class="keyword">if</span> (thread.equals(Thread.currentThread())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// deal with thread</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stack) &#123;</span><br><span class="line">            <span class="comment">// deal with stackTraceElement</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程性能诊断的辅助脚本"><a href="#线程性能诊断的辅助脚本" class="headerlink" title="线程性能诊断的辅助脚本"></a><strong>线程性能诊断的辅助脚本</strong></h3><p>使用 jstack 还有一个重要的功能就是分析热点线程: 找出占用 cpu 资源最高的线程;<br>首先我先介绍一下手工敲命令分析的方法:</p>
<ul>
<li><p>使用 top 命令找出 cpu 使用率高的 thread id:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p pid: 只显示指定进程的信息</span></span><br><span class="line"><span class="comment"># -H: 展示线程的详细信息</span></span><br><span class="line">top -H -p &#123;pid&#125;</span><br><span class="line"><span class="comment"># 使用 P 快捷键按 cpu 使用率排序, 并记录排序靠前的若干 pid (轻量级进程 id)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作进制转换:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将记录下的十进制 pid 转为十六进制</span></span><br><span class="line">thread_id_0x=`<span class="built_in">printf</span> <span class="string">"%x"</span> <span class="variable">$thread_id</span>`</span><br><span class="line">`<span class="built_in">echo</span> <span class="string">"obase=16; <span class="variable">$thread_id</span>"</span> | bc`</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 thread dump 中记录的每个线程的 nid 是与 linux 轻量级进程 pid 一一对应的 (只是十进制与十六进制的区别), 所以便可以拿转换得到的十六进制 thread_id_0x, 去 thread dump 中搜索对应的 nid, 定位问题线程;<br>&nbsp;</p>
</li>
</ul>
<p>下面介绍一个脚本, 其功能是: 按照 cpu 使用率从高到低排序, 打印指定 jvm 进程的前 n 个线程;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">default_lines=10</span><br><span class="line">top_head_info_padding_lines=8</span><br><span class="line">default_stack_lines=15</span><br><span class="line"></span><br><span class="line">jvm_pid=<span class="variable">$1</span></span><br><span class="line">jvm_user=<span class="variable">$2</span></span><br><span class="line">((thread_stack_lines=<span class="variable">$&#123;3:-$default_lines&#125;</span>+top_head_info_padding_lines))</span><br><span class="line"></span><br><span class="line">threads_top_capture=$(top -b -n1 -H -p <span class="variable">$jvm_pid</span> | grep <span class="variable">$jvm_user</span> | head -n <span class="variable">$thread_stack_lines</span>)</span><br><span class="line">jstack_output=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$(sudo -i -u $jvm_user jstack $jvm_pid)</span>"</span>)</span><br><span class="line">top_output=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$(echo "$threads_top_capture" | perl -pe 's/\e\[?.*?[\@-~] ?//g' | awk '&#123;gsub(/^ +/,"")</span>;print&#125;' | awk '&#123;gsub(/ +|[+-]/,"</span> <span class="string">");print&#125;' | cut -d "</span> <span class="string">" -f 1,9 )\n "</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"***********************************************************"</span></span><br><span class="line">uptime</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Analyzing top <span class="variable">$top_threads</span> threads"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"***********************************************************"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> %s <span class="string">"<span class="variable">$top_output</span>"</span> | <span class="keyword">while</span> IFS= <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    pid=$(<span class="built_in">echo</span> <span class="variable">$line</span> | cut -d <span class="string">" "</span> -f 1)</span><br><span class="line">    hexapid=$(<span class="built_in">printf</span> <span class="string">"%x"</span> <span class="variable">$pid</span>)</span><br><span class="line">    cpu=$(<span class="built_in">echo</span> <span class="variable">$line</span> | cut -d <span class="string">" "</span> -f 2)</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="variable">$cpu</span> <span class="string">"% [<span class="variable">$pid</span>] "</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$jstack_output</span>"</span> | grep <span class="string">"tid.*0x<span class="variable">$hexapid</span> "</span> -A <span class="variable">$default_stack_lines</span> | sed -n -e <span class="string">'/0x'</span><span class="variable">$hexapid</span><span class="string">'/,/tid/ p'</span> | head -n -1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>该脚本有多种版本, 在我司的每台主机上的指定路径下都存放了一个副本; 出于保密协议, 该脚本源码不便于公开, 上方所展示的版本是基于美团点评的技术专家王锐老师在一次 <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651746699&amp;idx=2&amp;sn=c52feeab2576056e4a65e26a99702206&amp;chksm=bd12a8c68a6521d0de81ac8ab437df1a9e702053b7840af9ac86b29979865c6fc1000286875e&amp;mpshare=1&amp;scene=1&amp;srcid=0610dNiqShEJLkHiQLiIN4z1#rd" target="_blank" rel="noopener">问答分享</a> 中给出的代码所改造的;</p>
<h3 id="thread-dump-可视化分析工具"><a href="#thread-dump-可视化分析工具" class="headerlink" title="thread dump 可视化分析工具"></a><strong>thread dump 可视化分析工具</strong></h3><p>与 <a href="gceasy.io">gceasy.io</a> 一道, 同出自一家之手: <a href="http://fastthread.io" target="_blank" rel="noopener">fastthread.io</a>;</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul>
<li><a href="https://www.jianshu.com/p/6690f7e92f27" target="_blank" rel="noopener">如何使用jstack分析线程状态</a></li>
<li><a href="http://www.cnblogs.com/kongzhongqijing/articles/3630264.html" target="_blank" rel="noopener">java命令–jstack 工具</a></li>
<li><a href="https://my.oschina.net/dabird/blog/691692" target="_blank" rel="noopener">7 个抓取 Java Thread Dumps 的方式</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651746699&amp;idx=2&amp;sn=c52feeab2576056e4a65e26a99702206&amp;chksm=bd12a8c68a6521d0de81ac8ab437df1a9e702053b7840af9ac86b29979865c6fc1000286875e&amp;mpshare=1&amp;scene=1&amp;srcid=0610dNiqShEJLkHiQLiIN4z1#rd" target="_blank" rel="noopener">你与Java大牛的距离，只差这24个问题</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        <strong>本文链接:</strong> <a href="/2017/09/24/jvm-tools--jstack命令使用经验总结/" rel="external">http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结</a> <br/> 感谢您的阅读与支持！
        
    </div>
    
    <footer>
        <a href="http://zshell.cc">
            <img src="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" alt="zshell.zhang">
            zshell.zhang
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm-tools/">jvm:tools</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&title=《jstack 命令使用经验总结》 — 希尔的博客&pic=https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&title=《jstack 命令使用经验总结》 — 希尔的博客&source=
jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;以往对于 jstack 产生的 thread dump, ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《jstack 命令使用经验总结》 — 希尔的博客&url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&via=http://zshell.cc" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/10/14/rsync--rsyncd配置与运行/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">rsyncd 配置与运维</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/08/25/alert-nagios--nagios配置文件梳理及运维实践/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">nagios 配置文件梳理及运维实践</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "fMh2JHgkPnDtARiQapOg8Jrk-gzGzoHsz",
            appKey: "UPNXLDUkngDnuhfC9XQPgF6n",
            avatar: "mm",
            placeholder: "您的评论, 吾愿洗耳恭听!",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>zshell.zhang &copy; 2016 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&title=《jstack 命令使用经验总结》 — 希尔的博客&pic=https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&title=《jstack 命令使用经验总结》 — 希尔的博客&source=
jstack 在命令使用上十分简洁, 然而其输出的内容却十分丰富, 信息量足, 值得深入分析;以往对于 jstack 产生的 thread dump, ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《jstack 命令使用经验总结》 — 希尔的博客&url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/&via=http://zshell.cc" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://zshell.cc/2017/09/24/jvm-tools--jstack命令使用经验总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuklEQVR42u3aQW7cQAwEQP//0w4Q+JCLtN2kZtcBSifBWEtTcxgRTX59xdf33+vq/t/r/gnJ72fPX114eHh4o6Xfvz65b7fj6vf5FkdbhoeHh3eMtz+gk62ZHffJMy//joeHh/dRXovJj/L7TwUeHh7e/8u7ek0bVdxvVhuI4OHh4X2Kl4QR+SGexwqzoOFI1oKHh4cX8/YNsPffv7W/h4eHhxd/EvKPwX15vRkamK3z53/x8PDwDvCSAjeJDGZbs4lu82AXDw8P71lee1jn4UK7cTmgWA8eHh7eW3htbJof4vlAVV5ev3gaHh4e3gFeHi4kj5uNYT1V3EddPjw8PLw1Ly9wn22hbQa2Vq/Ew8PDOzBrNCujkwK6DRpa0otvHR4eHt5DvKQ4bgvo/GlJ+T4ru6NmGB4eHt6aly/u9LhVHuYOPyp4eHh4C96sbM0ZszA3D3xf/C8eHh7eMV7b+G9HDfbjAqvkGA8PD+9RXv6ydmvakno2lJBsJR4eHt5p3ixQaMezNm2wfD14eHh4J3jt0FXboMpD23zcqoiD8fDw8A7w9i+etfw3IwVJG+xFeY2Hh4e35m1C2LbkzUmbd+Hh4eGd5m0aY8knoW3/PxVY4OHh4Z3mbcLTzYI2sW8xcICHh4f3EC85xNuH5u20dmuSWCTKdPHw8PAe4rXR6ixyzT8S7f2L0QE8PDy8h3j54dsGDe2WFcd9G3Dg4eHhPcpLyuVNODvjFXnzfYSBh4eHd5iXD1TN2lftiNU+5sDDw8M7wWsP3HZBsyVu2mbDCw8PD6/kJR+D/L4NETZRRbTFeHh4eMd47SLakHc2yNWy8fDw8H4bLy+1N5XtrEy/XA8eHh7eL+PlkW7ygdm3yi6zajw8PLwDvM2RPWuS7ctxPDw8vE/xNg2wPFxIPjZJGPFwZw8PDw+v4/0BDcRzqJ5RbW4AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
