<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>elasticsearch 6.x 升级调研报告 | 希尔的博客 | 兰之猗猗，扬扬其香。不采而佩，于兰何伤？</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="elasticsearch">
    <meta name="description" content="关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 公司专门抽调人力资源作前期调研, 故为此文以记之;在这篇文章中, 我从 客户端, 索引创建, query dsl, search api, plugins, 监控体系等多方面">
<meta name="keywords" content="elasticsearch">
<meta property="og:type" content="article">
<meta property="og:title" content="elasticsearch 6.x 升级调研报告">
<meta property="og:url" content="https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/index.html">
<meta property="og:site_name" content="希尔的博客">
<meta property="og:description" content="关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 公司专门抽调人力资源作前期调研, 故为此文以记之;在这篇文章中, 我从 客户端, 索引创建, query dsl, search api, plugins, 监控体系等多方面">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png">
<meta property="og:updated_time" content="2018-04-01T15:29:07.163Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="elasticsearch 6.x 升级调研报告">
<meta name="twitter:description" content="关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 公司专门抽调人力资源作前期调研, 故为此文以记之;在这篇文章中, 我从 客户端, 索引创建, query dsl, search api, plugins, 监控体系等多方面">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png">
    
        <link rel="alternate" type="application/atom+xml" title="希尔的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <script src="/js/leancloud-revision.js"></script>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">zshell.zhang</h5>
          <a href="mailto:xaaservice@gmail.com" title="xaaservice@gmail.com" class="mail">xaaservice@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/ZhangZhi1993-2025" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">elasticsearch 6.x 升级调研报告</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">elasticsearch 6.x 升级调研报告</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-03-24T14:11:48.000Z" itemprop="datePublished" class="page-time">
  2018-03-24
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/elasticsearch/">elasticsearch</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#客户端兼容性问题"><span class="post-toc-number">1.</span> <span class="post-toc-text">客户端兼容性问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#巨轮转向的前提-es-adapter"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">巨轮转向的前提: es-adapter</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#升级过渡期-client-端的技术选型"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">升级过渡期 client 端的技术选型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HighLevelClient-的使用注意事项"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">HighLevelClient 的使用注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#语法兼容性问题"><span class="post-toc-number">2.</span> <span class="post-toc-text">语法兼容性问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#索引创建的兼容性"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">索引创建的兼容性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#query-dsl-的兼容性"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">query dsl 的兼容性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#search-api-的兼容性"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">search api 的兼容性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#底层索引数据兼容性问题"><span class="post-toc-number">3.</span> <span class="post-toc-text">底层索引数据兼容性问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#工具兼容性问题"><span class="post-toc-number">4.</span> <span class="post-toc-text">工具兼容性问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#http-访问工具兼容性"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">http 访问工具兼容性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插件兼容性"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">插件兼容性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#监控体系"><span class="post-toc-number">5.</span> <span class="post-toc-text">监控体系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基于-rest-api-graphite-grafana-的方案"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">基于 rest api + graphite + grafana 的方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#elastic-官方组件-x-pack"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">elastic 官方组件 x-pack</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#本文总结"><span class="post-toc-number">6.</span> <span class="post-toc-text">本文总结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#站内相关文章"><span class="post-toc-number">7.</span> <span class="post-toc-text">站内相关文章</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考链接"><span class="post-toc-number">8.</span> <span class="post-toc-text">参考链接</span></a></li></ol>
        </nav>
    </aside>


<article id="post-elasticsearch--elasticsearch6.x升级调研报告"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">elasticsearch 6.x 升级调研报告</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-03-24 22:11:48" datetime="2018-03-24T14:11:48.000Z"  itemprop="datePublished">2018-03-24</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/elasticsearch/">elasticsearch</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提升一个 major 版本是一件非常有挑战性的事情; 为了迎接这一挑战, 公司专门抽调人力资源作前期调研, 故为此文以记之;<br>在这篇文章中, 我从 客户端, 索引创建, query dsl, search api, plugins, 监控体系等多方面讨论了从 2.4.2 版本迁移到 6.2.2 版本的一系列可能遇到的兼容性问题及解决方案;<br>希望能给各位读者带来工作上的帮助!</p>
</blockquote>
<a id="more"></a>
<hr>
<p><strong>万字长文, 高能预警! 如只希望了解最终结论, 请点击:</strong> <em><a href="#本文总结">本文总结</a>;</em><br>&nbsp;<br>间歇断续, 历时余月, 本文终于迎来了收尾;<br>这篇文章缘起于部门自建 elasticsearch 集群的一个线上故障, 这是我们技术 TL 在 elastic 论坛的提问: <a href="https://discuss.elastic.co/t/es-consume-high-cpu-with-threadlocal/117402" target="_blank" rel="noopener">ES consume high cpu with threadlocal</a>; 随着业务规模的扩大, 业务数据的积累, 我们意识到当前 2.4.2 版本的 elasticsearch 已经满足不了我们的需求, 此刻亟需升级我们的集群; 比较之后, 我们打算将 6.2.2 版本作为升级的目标, 并着手开始调研; 本文便是该升级调研的一个总结报告;<br>相比于公司内部发表的版本, 本篇博客脱去了所有涉及公司的敏感信息, 并在开篇第一节补充介绍了一下我们使用 elasticsearch 的方式, 以方便外部读者更好得理解本文的其余部分内容;</p>
<h2 id="客户端兼容性问题"><a href="#客户端兼容性问题" class="headerlink" title="客户端兼容性问题"></a><strong>客户端兼容性问题</strong></h2><h3 id="巨轮转向的前提-es-adapter"><a href="#巨轮转向的前提-es-adapter" class="headerlink" title="巨轮转向的前提: es-adapter"></a><strong>巨轮转向的前提: es-adapter</strong></h3><p>我相信, 搞过 elasticsearch major 版本升级的人都对 elastic 公司深有体会: 从不按牌理出牌, 一个毫不妥协的技术理想主义者, 在其世界里根本没有兼容性这个词; 对于这样的公司做出的产品, 升级必定是一个痛苦的过程;<br>如果请求 elasticsearch 的代码逻辑散落在部门众多业务线的众多系统里, 要推动他们修改代码势必比登天还难: 因为这个过程对他们的 PKI 没有任何帮助, 只会挤占他们的工时, 增加他们的额外负担和 “无效” 工作量, 他们一定不会积极配合, 我们将无法推动进展;<br>还好部门的 VP 有技术远见,在各系统建立之初, 就定下了访问 elasticsearch 的规范: 禁止各系统自己主动连接 elasticsearch, 必须统一由专门的系统代理, 负责语法校验, 行为规范, 请求监控, 以及统一的调优, 这个系统被命名为 es-adapter;<br>当然, es-adapter 系统设计的早期也有一些硬伤, 并直接诱发了一个严重的线上故障: <a href="">apache httpclient 初始化参数设置总结</a>; 那次事故之后, 甚至有技术 TL 开始怀疑 es-adapter 成为了当前体系的瓶颈, 需要评估有无必要废弃该系统; 但是船大掉头难, 整改谈何容易? 最后还是老老实实完善了 es-adapter 的逻辑继续使用;<br>有的时候 es-adapter 也会做一些语法兼容性的逻辑, 比如之前从 1.7.3 升级到 2.4.2 的时候, 部分 dsl 语法的改动就完全在 es-adapter 上代理了, 对业务线无感知, 轻描淡写地升级了一个 major 版本; 尽管这么做带来了一些技术债务, 但确实为有限时间内的快速升级提供了可能性; 在后面的时间, 业务线可以慢慢地迭代版本, 逐渐适配新 elasticsearch 版本的 api, 偿还债务; 正所谓: 万事之先, 圆方门户; 虽覆能复, 不失其度;<br>不得不说, 当系统规模与复杂度发展到了一个 “船大难掉头” 的程度时, es-adapter 就像是《三体》中描述的 “水滴” 一样, 带领整个体系从一个更高的维度完成 “平滑” 转向; 没有 es-adapter, 升级 elasticsearch 到 6.2.2 就无从谈起; 只不过这次的情形相比上一次有些难看, 没法做到完全透明了, es-adapter 部分特有的逻辑设计在这次升级可能会栽一个跟头, 具体的内容请见下文: <a href="#search-api-的兼容性">search api 的兼容性</a>;</p>
<h3 id="升级过渡期-client-端的技术选型"><a href="#升级过渡期-client-端的技术选型" class="headerlink" title="升级过渡期 client 端的技术选型"></a><strong>升级过渡期 client 端的技术选型</strong></h3><p>关于 elasticsearch java 官方客户端, 除了 TransportClient 之外, 最近又新出了一个 HighLevelClient, 而且官方准备在接下来的一两个 major 版本中, 让 HighLevelClient 逐步取代 TransportClient, 官方原话是这样描述的:</p>
<blockquote>
<p>We plan on deprecating the <code>TransportClient</code> in Elasticsearch 7.0 and removing it completely in 8.0.</p>
</blockquote>
<p>所以没有什么好对比的, 我们必须选择 HighLevelClient, 否则没两年 TransportClient 就要被淘汰了; 现在唯一需要考虑的是, 在升级过渡期, 怎么处理 es-adapter 中新 client 和旧 client的关系, 如何同时访问 6.2.2 与 2.4.2 两个集群;<br>值得注意的是, HighLevelClient 是基于 http 的 rest client, 这样一来, 在客户端方面, elasticsearch 将 java, python, php, javascript 等各种语言的底层接口就都统一起来了; 与此同时, 使用 rest api, 还可以屏蔽各版本之前的差异, 之前的 TransportClient 使用 serialized java object, 各版本之前的微小差异便会导致不兼容;<br>要使用 HighLevelClient, 其 maven 坐标需要引到如下三个包:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- elasticsearch core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- low level rest client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- high level rest client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>后两者没的说, 都是新引入的坐标; 但是第一个坐标, elasticsearch 的核心 package, 就无法避免与现在 es-adapter 引的 2.4.2 版本冲突了;<br>之前从 1.7.3 升 2.4.2 时, 由于 TransportClient 跨 major 版本不兼容, 导致 es-adapter 无法用同一个 TransportClient 访问两个集群, 只能苦苦寻找有没有 rest 的解决方案, 后来总算找到一个: Jest (github 地址: <a href="https://github.com/searchbox-io/Jest" target="_blank" rel="noopener">searchbox-io/Jest</a>), 基本囊括了 elasticsearch 各种类别的请求功能;<br>但这还是架不住各业务线种种小众的需求(比如 nested_filter, function_score 等等), 以致于对两个不同版本的集群, es-adapter 不能完美提供一致的功能;<br>这一次升 6.2.2, 又遇到了和上一次差不多的问题, 不过一个很大的不同是: 现在官方推荐的 HighLevelClient 是 rest client, 所以很有必要尝试验证下其向下兼容的能力;<br>我们经过 demo 快速测试验证, 初步得出了结论:<br>&nbsp;<br><strong>6.2.2 版本的 RestHighLevelClient 可以兼容 2.4.2 版本的 elasticsearch;</strong><br>&nbsp;<br>这也体现了 elasticsearch 官方要逐步放弃 TransportClient 并推荐 HighLevelClient 的原因: 基于 http 屏蔽底层差异, 最大限度地提升 client 端的兼容性; 后来我在其官方文档中也看到了相关的观点: <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html" target="_blank" rel="noopener">Compatibility</a>;<br>所以, 本次升级过渡期就不需要像上次 1.7.3 升 2.4.2 那么繁琐, 还要再引入一个第三方的 rest client; 现在唯一需要做的就是直接把 client 升级到 6.2.2, 使用 HighLevelClient 同时访问 2.4.2 和 6.2.2 两个版本;</p>
<h3 id="HighLevelClient-的使用注意事项"><a href="#HighLevelClient-的使用注意事项" class="headerlink" title="HighLevelClient 的使用注意事项"></a><strong>HighLevelClient 的使用注意事项</strong></h3><p><strong>(1) 初始化的重要选项</strong><br>HighLevelClient 底层基于 org.apache.httpcomponents, 一提起这个老牌 http client, 就不得不提起与它相关的几个关键 settings:</p>
<ol>
<li><code>CONNECTION_REQUEST_TIMEOUT</code></li>
<li><code>CONNECT_TIMEOUT</code></li>
<li><code>SOCKET_TIMEOUT</code></li>
<li><code>MAX_CONN_TOTAL</code></li>
<li><code>MAX_CONN_PER_ROUTE</code></li>
</ol>
<p>不过, HighLevelClient 关于这几个参数的设置有些绕人, 它是通过如下两个回调实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;HttpHost&gt; httpHosts = Lists.newArrayListWithExpectedSize(serverNum);</span><br><span class="line">serverAddressList.forEach((server) -&gt; httpHosts.add(<span class="keyword">new</span> HttpHost(server.getAddr(), server.getPort(), <span class="string">"http"</span>)));</span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient highLevelClient = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">        RestClient.builder(httpHosts.toArray(<span class="keyword">new</span> HttpHost[<span class="number">0</span>]))</span><br><span class="line">        <span class="comment">// timeout settings</span></span><br><span class="line">        .setRequestConfigCallback((callback) -&gt; callback</span><br><span class="line">                .setConnectTimeout(CONNECT_TIMEOUT_MILLIS)</span><br><span class="line">                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS)</span><br><span class="line">                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS))</span><br><span class="line">        <span class="comment">// connections total and connections per host</span></span><br><span class="line">        .setHttpClientConfigCallback((callback) -&gt; callback</span><br><span class="line">                .setMaxConnPerRoute(MAX_CONN_PER_ROUTE)</span><br><span class="line">                .setMaxConnTotal(MAX_CONN_TOTAL)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) request timeout 的设置</strong><br>对于 index, update, delete, bulk, query 这几个请求动作, HighLevelClient 与它们相关的 Request 类都提供了 timeout 设置, 都比较方便; 但是, 偏偏 get 与 multiGet 请求没有提供设置 timeout 的地方;<br>这就有点麻烦了, get 与 multiGet 是重要的请求动作, 绝对不能没有 timeout 机制: 之前遇到过的几次惨痛故障, 都无一例外强调了合理设置 timeout 的重要性;<br>那么, 这种就只能自己动手了, 还好 HighLevelClient 对每种请求动作都提供了 async 的 api, 我可以结合 CountDownLatch 的超时机制, 来实现间接的 timeout 控制;<br>首先需要定义一个 response 容器来盛装异步回调里拿到的 result:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T response;</span><br><span class="line">    <span class="keyword">private</span> Exception exception;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getResponse</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> response; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(T response)</span> </span>&#123; <span class="keyword">this</span>.response = response; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exception <span class="title">getException</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> exception; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Exception exception)</span> </span>&#123; <span class="keyword">this</span>.exception = exception;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是使用 CountDownLatch 实现 timeout 的 get 请求具体逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get request with timeout */</span></span><br><span class="line"><span class="keyword">final</span> ResponseWrapper&lt;GetResponse&gt; wrapper = <span class="keyword">new</span> ResponseWrapper&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">highLevelClient.getAsync(request, <span class="keyword">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(GetResponse documentFields)</span> </span>&#123;</span><br><span class="line">        wrapper.setResponse(documentFields);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        wrapper.setException(e);</span><br><span class="line">        wrapper.setResponse(<span class="keyword">null</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    latch.await(getTimeOutTime(indexName, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchTimeoutException(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wrapper.getResponse() == <span class="keyword">null</span>) &#123; <span class="comment">// 异常处理 &#125; </span></span><br><span class="line"><span class="keyword">else</span> &#123; 处理 wrapper.getResponse() 的返回结果 &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>(3) query 请求 dsl 的传参问题</strong><br>es-adapter 之前查询相关的请求动作, 对业务线提供的接口是基于 search api 设计的, 就是下面这样的模型:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="string">"_source"</span>: &#123;</span><br><span class="line">        <span class="string">"include"</span>: [ ... ],</span><br><span class="line">        <span class="string">"exclude"</span>: [ ... ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"from"</span>: xxx,</span><br><span class="line">    <span class="string">"size"</span>: yyy,</span><br><span class="line">    <span class="string">"sort"</span>: [ ... ],</span><br><span class="line">    <span class="string">"aggs"</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>业务线需要提供以上参数给 es-adapter, 而这里面最重要的就是第一个 query 参数, 这里原先设计的是传一个 dsl 字符串; 但是现在我发现 HighLevelClient 的 SearchSourceBuilder 不能直接 set 一个字符串, 而必须是使用各种 QueryBuilder 去构造对应的 Query 对象;<br>这个问题就比较严重了, 如果要改就是牵涉到所有的业务线; 而且即便是想改, 也没那么简单: 这些 QueryBuilders 都没有实现 Serializable 接口, 根本没法被 dubbo 序列化;<br>权衡之下, 感觉还是要努力想办法把 dsl 字符串 set 进去; 我看到 SearchSourceBuilder 有一个方法是 fromXContent(XContentParser parser), 考虑到 dsl 字符串其实都是 json, 可以使用 JsonXContent 将 dsl 反序列化成各种 QueryBuilders; 摸索了一阵子, 验证了以下代码是可行的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String dslStr = <span class="string">"..."</span>;</span><br><span class="line">SearchModule searchModule = <span class="keyword">new</span> SearchModule(Settings.EMPTY, <span class="keyword">false</span>, Collections.emptyList());</span><br><span class="line">XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(</span><br><span class="line">        <span class="keyword">new</span> NamedXContentRegistry(searchModule.getNamedXContents()), dslStr);</span><br><span class="line"></span><br><span class="line">SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.fromXContent(parser);</span><br></pre></td></tr></table></figure></p>
<p>HighLevelClient 的使用基本上要解决的就是以上几个问题了;</p>
<h2 id="语法兼容性问题"><a href="#语法兼容性问题" class="headerlink" title="语法兼容性问题"></a><strong>语法兼容性问题</strong></h2><p>语法兼容性问题是一个比较基础的问题, 这一节主要讨论三个方面: 索引创建的兼容性, query dsl 的兼容性, search api 的兼容性;</p>
<h3 id="索引创建的兼容性"><a href="#索引创建的兼容性" class="headerlink" title="索引创建的兼容性"></a><strong>索引创建的兼容性</strong></h3><p>es 6.2 在索引创建方面, 有如下几点与 es 2.4 有区别:<br>&nbsp;<br><strong>首先是 settings 中的区别;</strong><br>&nbsp;<br>部分字段不能出现在索引创建语句中了, 只能由 elasticsearch 自动生成;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"index"</span>:&#123;</span><br><span class="line">        <span class="comment">// creation_date 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"creation_date"</span>: <span class="string">"1502713848656"</span>,</span><br><span class="line">        <span class="string">"number_of_shards"</span>:<span class="string">"2"</span>,</span><br><span class="line">        <span class="string">"analysis"</span>:&#123;</span><br><span class="line">            <span class="string">"analyzer"</span>:&#123;</span><br><span class="line">                <span class="string">"comma_analyzer"</span>:&#123;</span><br><span class="line">                    <span class="string">"type"</span>:<span class="string">"custom"</span>,</span><br><span class="line">                    <span class="string">"tokenizer"</span>:<span class="string">"comma_tk"</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;,  </span><br><span class="line">            <span class="string">"tokenizer"</span>:&#123;</span><br><span class="line">                <span class="string">"comma_tk"</span>:&#123;</span><br><span class="line">                    <span class="string">"pattern"</span>:<span class="string">","</span>,</span><br><span class="line">                    <span class="string">"type"</span>:<span class="string">"pattern"</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"number_of_replicas"</span>:<span class="string">"1"</span>,</span><br><span class="line">        <span class="comment">// uuid 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"uuid"</span>:<span class="string">"Oa0tz0x-SpSfuC591_ASIQ"</span>,</span><br><span class="line">        <span class="comment">// version.create, version.update 不能出现在索引创建的定义语句里</span></span><br><span class="line">        <span class="string">"version"</span>:&#123;</span><br><span class="line">            <span class="string">"created"</span>:<span class="string">"1070399"</span>,</span><br><span class="line">            <span class="string">"upgraded"</span>:<span class="string">"2040299"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这算是一个规范化, 这些字段原本就不该自己定义, 之前我们是复制的时候图省事, 懒得删掉, 现在不行了;<br>&nbsp;<br><strong>然后是 mappings 中的区别;</strong><br>&nbsp;<br><strong>(1) 布尔类型的取值内容规范化</strong><br>elasticsearch 索引定义的 settings/mappings 里有很多属性是布尔类型的开关; 在 6.x 之前的版本, elasticsearch 对布尔类型的取值内容限制很宽松: true, false, on, off, yes, no, 0, 1 都可以接受, 产生了一些混乱, 对初学者造成了困扰:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elasticsearch 2.4.2</span></span><br><span class="line"><span class="comment">// xxx_idx/_mapping/field/xxx_field</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"xxx_idx"</span>:&#123;</span><br><span class="line">        <span class="string">"mappings"</span>:&#123;</span><br><span class="line">            <span class="string">"xxx_type"</span>:&#123;</span><br><span class="line">                <span class="string">"xxx_field"</span>:&#123;</span><br><span class="line">                    <span class="string">"full_name"</span>:<span class="string">"xxx_field"</span>,</span><br><span class="line">                    <span class="string">"mapping"</span>:&#123;</span><br><span class="line">                        <span class="string">"xxx_field"</span>:&#123;</span><br><span class="line">                            <span class="string">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                            <span class="string">"index_name"</span>:<span class="string">"xxx_field"</span>,</span><br><span class="line">                            <span class="comment">// 以下属性都有布尔类型的含义, 但取值五花八门, 容易造成歧义</span></span><br><span class="line">                            <span class="string">"index"</span>:<span class="string">"not_analyzed"</span>, </span><br><span class="line">                            <span class="string">"store"</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="string">"doc_values"</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="string">"term_vector"</span>:<span class="string">"no"</span>,</span><br><span class="line">                            <span class="string">"norms"</span>:&#123;</span><br><span class="line">                                <span class="string">"enabled"</span>:<span class="literal">false</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">"null_value"</span>:<span class="literal">null</span>,</span><br><span class="line">                            <span class="string">"include_in_all"</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 6.x 版本开始, 所有的布尔类型的属性 elasticsearch 只接受两个值: <code>true</code> 或 <code>false</code>;<br><em>从当前 2.4.2 集群的使用状况来看, 这个改动对我们的影响不是特别大, 因为我们在定义索引创建 DSL 语句时, 很多布尔类型的选项都是用的默认值, 并未显式定义, 只有 <code>index</code> 属性可能会经常用到;</em></p>
<p><strong>(2) _timestamp 字段被废弃</strong><br><em>这个改变对我们的影响不是很大, 我们现在绝大部分索引都会自己定义 createTime / updateTime 字段, 用于记录该文档的创建 / 更新时间, 几乎不依赖系统自带的 _timestamp 字段;</em><br>&nbsp;<br>况且, _timestamp 字段在 2.4.2 版本时, 就已经默认不自动创建了, 要想添加 _timestamp 字段, 必须这样定义:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"_timestamp"</span>: &#123;</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然, 在 6.2.2 版本中, 以上定义就直接报 unsupported parameter 错误了;</p>
<p><strong>(3) _all 字段被 deprecated, include_in_all 属性被废弃</strong><br>在 elasticsearch 6.x, _all 字段被 deprecated 了, 与此同时, _all 字段的 enabled 属性默认值也由 true 改为了 false;<br>之前, 为了阻止 _all 字段生效, 我们都会不遗余力得在每个索引创建语句中加上如下内容:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"_all"</span>: &#123;</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 6.0 版本开始, 这些语句就不需要再出现了, 出现了反而会导致 elasticsearch 打印 WARN 级别的日志, 告诉我们 _all 字段已经被 deprecated, 不要再对其作配置了;<br>与 _all 密切相关的属性是 include_in_all, 在 6.0 版本之前, 这个属性值默认也是 true; 不过不像 _all 的过渡那么温和, 从 6.0 开始, 我在 elasticsearch reference 官方文档里就找不到这个属性的介绍了, 直接被废弃; 而在其上一个版本 5.6 中, 我还能看到它, 也没有被 deprecated, 着实有些突然;<br>elasticsearch 放弃 _all 这个概念, 是希望让 query_string 时能够更加灵活, 其给出的替代者是 <code>copy_to</code> 属性:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"first_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"copy_to"</span>: <span class="string">"full_name"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"last_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"copy_to"</span>: <span class="string">"full_name"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"full_name"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样, 把哪些字段 merge 到一起, merge 到哪个字段里, 都是可以自定义的, 而不用束缚在固定的 _all 字段里;<br>&nbsp;<br><em>无论如何, _all 与 include_in_all 的废弃对我们来说影响都是很小的, 首先我们就很少有全文检索的场景, 其次我们也没有使用 query_string 查询 merged fields 的需求, 甚至将 _all 禁用已被列入了我们索引创建的规范之中;</em></p>
<p><strong>(4) 史诗级大改变: string 类型被废弃</strong><br>string 类型被废弃, 代替者是分词的 <code>text</code> 类型和不分词的 <code>keyword</code> 类型;<br>当前正在使用的 2.4.2 版本的集群里, string 类型大概是被使用最多的类型了; 保守估计, 一个普通的索引里, 60%  以上的字段类型都是 string; 现在 6.x 把这个类型废弃了, 就意味着几乎所有索引里的大多数字段都要修改;<br>&nbsp;<br><em>不过好在, 这种修改也只是停留在 index 的 schema 映射层面, 对 store 于底层的 document 而言是完全透明的, 所有原始数据都不需要有任何修改;</em><br>&nbsp;<br>经过搜索发现, 其实早在 elasticsearch 5.0 时, string 类型就已经被 deprecated 了, 然后在 6.1 时被彻底废弃, 详细的 changelog 见官方文档: <a href="https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst" target="_blank" rel="noopener">Changelog</a>;<br>仔细一想, 这个改变是有道理的: elasticsearch 想要结束掉目前混乱的概念定义;<br>比如说, 在 5.0 之前的版本, 一个字符串类型的字段, 是这样定义的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"xxx"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"not_analyzed"</span> <span class="comment">// 不需要分词, 但要索引</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"yyy"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"no"</span> <span class="comment">// 不需要分词, 也不需要索引</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"zzz"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span> <span class="comment">// 默认情况, 需要索引, 也需要分词</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>index</code> 的原本含义是定义是否需要索引, 是一个布尔概念; 但由于字符串类型的特殊性, 索引的同时还需要再区分是否需要分词, 结果 index 属性被设计为允许设置成 <code>not_analyzed</code>, <code>analyzed</code>, <code>no</code> 这样的内容; 然后其他诸如数值类型, 亦被其拖累, index 属性的取值也需要在 <code>not_analyzed</code>, <code>no</code> 中作出选择; 不得不说这非常混乱;<br>要把这块逻辑理清楚, 第一个选择是再引入一个控制分词的开关 word_split, 只允许字符串类型使用, 第二种选择就是把字符串类型拆分成 text 和 keyword;<br>至于 elasticsearch 为何选择了第二种方案, 我猜主要还是默认值不好确定; 对初学者而言, 一般都习惯于使用默认值, 但是究竟默认要不要分词? 以 elasticsearch 的宗旨和初衷来看, 要分词, search every where; 但是以实际使用者的情况来看, 很多的场景下都不需要分词; 如果是把类型拆分, 那么就得在 text 和 keyword 中二选一, 不存在默认值, 使用者自然会去思考自己真正的需求;<br>现在逻辑理清楚了, <code>index</code> 的取值类型, 也就如上一节所说的, 必须要在 <code>true</code> 或 <code>false</code> 中选择, 非常清晰;</p>
<p><strong>(5) mapping 中取消 multi types</strong><br>从 elasticsearch 6.1 开始, 同一个 index(mapping) 下不允许创建多个 type, index 与 type 必须一一对应; 从下一个 major 版本开始, elasticsearch 将废弃 type 的概念, 详见官方文档: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html" target="_blank" rel="noopener">Removal of mapping types</a>;<br>由于底层 Lucene 的限制, 同一个 index 下的不同 type 中的同名的字段, 其背后是共享的同一个 lucene segment; 这就意味着, 同一个 index 下不同 type 中的同名字段, 类型定义也必须相同; 原文如下:</p>
<blockquote>
<p>In an Elasticsearch index, fields that have the same name in different mapping types are backed by the same Lucene field internally; In other words, both fields must have the same mapping (definition) in both types.</p>
</blockquote>
<p>&nbsp;<br><em>这个改变对我们是有些影响的, 我们有小一部分的索引都存在 multi types 的问题, 这就意味着需要新建索引来承接多出来的 type, 这些索引的使用者必须要修改代码, 使用新的索引名访问不同的 type;</em></p>
<h3 id="query-dsl-的兼容性"><a href="#query-dsl-的兼容性" class="headerlink" title="query dsl 的兼容性"></a><strong>query dsl 的兼容性</strong></h3><p>索引创建的兼容性调研只能算是一个热身, 按照以往经验, elasticsearch 一旦有 major 版本升级, query dsl 变动都不会小, 这次也不例外;</p>
<p><strong>(1) filtered query 被废弃</strong><br>其实早在 2.0 版本时, filtered query 就已经被 deprecated 了, 5.0 就彻底废弃了; 这的确是一个不太优雅的设计, 在本来就很复杂的 query dsl 中又增添了一个绕人的概念;<br>filtered query 原本的设计初衷是想在一个 query context 中引入一个 filter context 作前置过滤: </p>
<blockquote>
<p>Exclude as many document as you can with a filter, then query just the documents that remain.</p>
</blockquote>
<p>然而, filtered query 这样的命名方式, 让人怎么也联系不了上面的描述; 其实要实现上述功能, elasticsearch 有另一个更加清晰的语法: bool query, 详细的内容在接下来的第 (2) 小节介绍;<br>&nbsp;<br><em>从目前 es-adapter 的使用情况来看, 依然有请求会使用到 filtered query; 好在 filtered 关键字一般出现在 dsl 的最外层, 比较固定, 这块可以在 es-adapter 中代理修改:</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 在 es-adapter 中删除 filtered</span></span><br><span class="line">  <span class="string">"filtered"</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果有 filter, 将其移动到 query -&gt; bool 中</span></span><br><span class="line">    <span class="string">"filter"</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"bool"</span>: &#123;</span><br><span class="line">        <span class="string">"must"</span>: &#123; ... &#125;,</span><br><span class="line">        <span class="string">"should"</span>: &#123; ... &#125;,</span><br><span class="line">        <span class="string">"must_not"</span>: &#123; ... &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) filter context 被限定在 bool query 中使用</strong><br>如下所示, 以下 dsl 是 elasticsearch 6.x 中能够使用 filter context 的唯一方式, 用于取代第 (1) 小节所说的 filtered query:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="comment">// 引入 filter context 作前置过滤</span></span><br><span class="line">      <span class="string">"filter"</span>: &#123; ... &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="string">"must"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"should"</span>: &#123; ... &#125;,</span><br><span class="line">      <span class="string">"must_not"</span>: &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;<br><em>由于这个规范只是一个限定, 而不是废弃, 所以对目前生产环境肯定是没有影响, 只是需要各业务线慢慢将使用方式改成这种规范, 否则以后也会带来隐患;</em></p>
<p><strong>(3) and/or/not query 被废弃</strong><br>与 filtered query 不同, and query, or query, not query 这三个是语义清晰, 见名知意的 query dsl, 但是依然被 elasticsearch 废弃了, 所有 and, or, not 逻辑, 现在只能使用 bool query 去实现, 如第 (2) 小节所示;<br>可以发现, elasticsearch 以前为了语法的灵活丰富, 定义了各种各样的关键字; 要实现同一个语义的查询, 可以使用几种不同的 query dsl; 很多时候, 这样导致的结果, 就是让新人感到眼花缭乱, 打击了学习热情;<br>现在 and query, or query, not query 被废弃, 干掉了冗余的设计, 精简了 query dsl 的体系, 不得不说这是一件好事;<br>但从另一个角度讲, 每逢 major 版本升级就来一次大动作, 破坏了前后版本的兼容性, 让使用者很头疼; 想想 java 为了兼容性到现在都还不支持真正的泛型, 要是换 elastic 公司来操作, 估计 JDK 1.6 就准备放弃兼容了;<br>&nbsp;<br><em>从 es-adapter 的使用情况来看, 目前业务线基本没有 and/or/not query 的使用, 相关逻辑大家都使用的 bool query, 所以这一点对我们影响有限;</em></p>
<p><strong>(4) missing query 被废弃</strong><br>要实现 missing 语义的 query, 现在必须统一使用 must_not exists:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"bool"</span>: &#123;</span><br><span class="line">            <span class="string">"must_not"</span>: &#123;</span><br><span class="line">                <span class="string">"exists"</span>: &#123;</span><br><span class="line">                    <span class="string">"field"</span>: <span class="string">"xxx"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这也算是对 query dsl 体系的精简化: 可以用 exists query 实现的功能, 就不再支持冗余的语法了;<br>&nbsp;<br><em>这个改动对我们是有一定影响的, 目前不少的 query 都还在使用 missing;</em><br><em>另外, 由于从 missing 改为 must_not exists 结构变化大, 而且 missing 的使用比较灵活, 在 dsl 中出现的位置不固定, 这两个因素叠加, 导致在 es-adapter 中代理修改的难度非常高, 基本不可行;</em><br><em>所以, 关于 missing , 必须由业务线自己来修改相关代码了;</em></p>
<h3 id="search-api-的兼容性"><a href="#search-api-的兼容性" class="headerlink" title="search api 的兼容性"></a><strong>search api 的兼容性</strong></h3><p>相比于 query dsl 的巨大改变, search api 总体上延续了之前的设计, 仅有部分 search type 被废弃; 感觉上比较温和, 可惜却因为 es-adapter 一些没有前瞻性的设计而闪着了腰;</p>
<p><strong>(1) search_type <code>scan</code> 被废弃</strong><br>关于这一点, 我们早就作好了心理准备; 早在从 1.7.3 升 2.4.2 的时候, 我们就已经发现 scan 这种 search type 被 deprecated 了, 从 5.0 开始, 就要被彻底废弃了, 所以 es-adapter 同期开始支持真正的 scroll 请求 (可惜业务线使用得不多);<br>从类别上说, scan 只不过是 scroll 操作中的一种特例: 不作 sort, fetch 后不作 merge; 从执行效果上看, scan 相比 scroll 可能稍微快一些, 并会获得 shards_num * target_size 数量的结果集大小; 除此之外, 没有其他什么区别;<br>&nbsp;<br><em>然而, 理论上很简单, 实际上却很棘手: 这源于 es-adapter 一个比较糟糕的设计:</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* es-adapter 的查询服务 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseContent <span class="title">query</span><span class="params">(RequestParam param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (param.getSearchType().equals(SearchType.SCAN) || param.getUseScroll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> scroll(param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.getSearchType().equals(SearchType.COUNT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> count(param);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> normallyQuery(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>可以发现, 在当前的逻辑中, 业务线的 scan 请求, 是通过调用 query 方法并设置 search type 为 scan 来实现的; 这里的 scroll(param) 方法是个 private 方法; 当 es-adapter 升级 api 到 6.2.2 后, 就识别不了 scan 了;</em><br><em>这就要求 es-adapter 修改 scroll(param) 方法为 public, 然后各业务线直接调 scroll(param) 方法; 这需要一定的修改工作量;</em></p>
<p><strong>(2) search_type <code>count</code> 被废弃</strong><br>count 与 scan 一样早在 2.4.2 时就已经被 deprecated 了, 不过之前我们对 count 的关注度没有 scan 高; 在 2.4.2 版本 SearchType 类的源码注释中, elastic 官方是这么说明的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only counts the results, will still execute aggregations and the like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> does not any improvements compared to &#123;<span class="doctag">@link</span> #QUERY_THEN_FETCH&#125; with a `size` of &#123;<span class="doctag">@code</span> 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">COUNT((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>对于 es-adapter 来说, 修改方法很明显, 正如注释中所述: 该怎么请求就怎么请求, 拿到 response 后从里面取出 totalHits 就行了;<br>&nbsp;<br><em>可惜, 如上一节所述, 同样由于 es-adapter 中糟糕的逻辑, 业务线需要通过调用 query 方法并设置 search type 为 count 来实现 count 请求; 现在没有 count 这个 search type 了, 需要业务线改成直接调用 count(param) 方法;</em></p>
<p><strong>(3) search_type <code>query_and_fetch</code> / <code>dfs_query_and_fetch</code> 被废弃</strong><br>这两个 search type 被 deprecated 的时间比 scan 和 count 稍晚一些; 好在这两个 search type 比较冷门, 业务线知道的不多, 所以用的也不多; 后来只要发现有人这么用, 我们就会告诉他们这个 api 已经不推荐了;<br>&nbsp;<br><em>所以, 相比 scan 和 count, query_and_fetch 和 dfs_query_and_fetch 被废弃的影响十分有限;</em></p>
<h2 id="底层索引数据兼容性问题"><a href="#底层索引数据兼容性问题" class="headerlink" title="底层索引数据兼容性问题"></a><strong>底层索引数据兼容性问题</strong></h2><p>根据官方文档, 6.x 版本可以兼容访问 5.x 创建的索引; 5.x 版本可以兼容 2.x 创建的索引;<br>背后其实是 lucene 版本的兼容性问题, 目前我们 2.4.2 版本的集群使用的 lucene 版本是 5.5.2, 而 6.2.2 版本的 elasticsearch 使用的 lucene 版本是 7.2.1;</p>
<ul>
<li>由于主机资源有限, 没办法再弄出一组机器来搭建新集群, 我首先想到的是: 能否以 5.x 作跳板, 先原地升级到 5.x, 再从 5.x 升到 6.x;<br>但是看了官方文档, 这个想法是不可行的: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/reindex-upgrade.html" target="_blank" rel="noopener">Reindex before upgrading</a>; elasticsearch 只认索引是在哪个版本的集群中创建的, 并不关心这个索引现在在哪个集群; 一个索引在 2.4.2 集群中创建, 现在运行在 5.x 版本的 elasticsearch 中, 这时候将 5.x 的集群升级到 6.x, 该索引是无法在 6.x 中访问的;</li>
<li><p>其次我想到的是使用 hdfs snapshot / restore 插件来升级索引; 这种方式曾在之前 1.7.3 升级 2.4.2 版本时大量使用, 总体来说速度比普通的 scroll / index 全量同步要快很多; 但是看了官方文档, 发现这个想法也是不可行的, (文档链接: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">Snapshot And Restore</a>):</p>
<blockquote>
<p>A snapshot of an index created in 5.x can be restored to 6.x.<br>A snapshot of an index created in 2.x can be restored to 5.x.<br>A snapshot of an index created in 1.x can be restored to 2.x.</p>
</blockquote>
</li>
<li><p>接着我又想到了 elasticsearch 自带的 reindex 模块; reindex 模块也是官方文档推荐的从 5.x 升 6.x 时的索引升级方法; 经过 beta 测试, 我发现这个方法基本可行, 速度也尚可, 唯一需要注意的就是在 elasticsearch.yml 配置文件中要加上一段配置: <code>reindex.remote.whitelist: oldhost:port</code> 以允许连接远程主机作 reindex;<br>以下是 _reindex api 的使用方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"source"</span>: &#123;</span><br><span class="line">    <span class="string">"remote"</span>: &#123;</span><br><span class="line">      <span class="string">"host"</span>: <span class="string">"http://oldhost:9273"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"source_idx"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"source_type"</span>,</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">      <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dest"</span>: &#123;</span><br><span class="line">    <span class="string">"index"</span>: <span class="string">"dest_idx"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"dest_type"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了 reindex 模块之外, 其实还有一种更保守的方法, 就是用基于 es-spark 的索引迁移工具来完成迁移, 这也是之前经常使用的工具;</p>
</li>
</ul>
<h2 id="工具兼容性问题"><a href="#工具兼容性问题" class="headerlink" title="工具兼容性问题"></a><strong>工具兼容性问题</strong></h2><h3 id="http-访问工具兼容性"><a href="#http-访问工具兼容性" class="headerlink" title="http 访问工具兼容性"></a><strong>http 访问工具兼容性</strong></h3><p>目前我们经常使用的基于 http 的访问工具主要是 elasticsearch-head 和 cerebro;<br>关于 http 请求, elasticsearch 6.2.2 也有一个重大的改变: <a href="https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests" target="_blank" rel="noopener">Strict Content-Type Checking for Elasticsearch REST Requests</a>;<br>现在所有带 body 的请求都必须要加上 <code>Content-Type</code> 头, 否则会被拒绝; 我们目前正在使用的 elasticsearch-head:2 和 cerebro v0.6.1 肯定是不支持这点的, head 是所有针对数据的 CRUD 请求使用不了, cerebro 甚至连接机器都会失败;<br>&nbsp;<br>目前, cerebro 在 github 上已经发布了最新支持 elasticsearch 6.x 的 docker 版本: <a href="https://github.com/yannart/docker-cerebro" target="_blank" rel="noopener">yannart/docker-cerebro</a>; 经过部署测试, 完全兼容 elasticsearch 6.2.2;<br>不过, elasticsearch-head 就没那么积极了, 目前最近的一次 commit 发生在半年之前, 那个时候 elasticsearch 的最新版本还是 v 5.5;<br>&nbsp;<br>没有 elasticsearch-head 肯定是不行的, 这个时候就只能自己动手了;<br>首先, 肯定是希望从源码入手, 看能不能改一改, 毕竟只是加一个 <code>Content-Type</code>, 并不需要动大手术; 只可惜, 我 clone 下了 elasticsearch-head 的源码, 发现这个纯 javascript 的工程, 复杂度远远超出我的想象, 早已不是一个非前端工程师所能驾驭的了的; 我全局搜索了一些疑似 post 请求的逻辑, 但终究也没把握这些是不是真正要改的地方; 思来忖去, 只得作罢;<br>然后, 我开始思考能否通过间接的方式解决问题; 我注意到一个现象, 凡是带 body 的请求, body 必定是一个 json, 无论是 POST 还是 PUT; 那就是说, 如果必须要指定 <code>Content-Type</code> 的时候, 那就指定为 <code>application/json</code> 就 OK 了; 与此同时, 如果是一个不带 body 的 GET 请求, 携带上该 header 理论上也不会造成额外影响;<br>如果这个假设成立, 那我只需要对所有 elasticsearch-head 发起的请求挂一层代理, 全部转到 nginx 上去, 并统一加上个 header:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name esbetae.corp.11bee.com;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">      proxy_pass http://l-es5.beta.p1.11bee.com:9273/;</span><br><span class="line"></span><br><span class="line">      proxy_set_header X-Real-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 统一加上 application/json 的 Content-Type</span></span><br><span class="line">      proxy_set_header Content-Type application/json;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试环境下的实验验证了这个方案是完全可行的, 原本正常访问的请求以及原本不能正常访问的请求, 现在都没有任何问题了;<br>其实, 这个方案相比之前还是有自己的好处的: 它隐藏了真正的 elasticsearch 节点地址与端口号, 只对业务线暴露了一个代理 url, 从而更加灵活与可控;</p>
<h3 id="插件兼容性"><a href="#插件兼容性" class="headerlink" title="插件兼容性"></a><strong>插件兼容性</strong></h3><p>笼统上讲, cerebro 与 elasticsearch-head 也是插件, 只不过它们是独立部署的, 所以被划归到 http 访问工具的类别中了; 而这一小节要讲的, 则是真正的需要依赖于具体的 elasticsearch 节点的插件;<br><strong>(1) elasticfence</strong><br>这个插件追踪溯源的话是这个项目: <a href="https://github.com/elasticfence/elasticsearch-http-user-auth" target="_blank" rel="noopener">elasticfence</a>; 后来由于各种各样的需求, 我们在这个插件的基础之上, 作了大量的修改; 到目前为止, 跑在我们节点上的该插件代码已经与 github 上的原项目代码没有半毛钱关系了;<br>当前我们版本的 elasticfence 最大的功能是整合了 qconfig, 使得其拥有热配置及时生效的能力; 然而, 也正是这个功能, 成了该插件本次兼容 elasticsearch 6.x 的噩梦;<br>首先第一道困难是, 2.4 与 6.2 版本的插件 api 彻底大改变; 但这与接下来的困难相比, 也只不过是热个身而已;<br>当我把 pom.xml 中的 elasticsearch 版本从 2.4.2 改成 6.2.2 时, 意料之中地发现代码红了一片, 不过仔细一看, 发现 api 变化的尺度之大, 还是超出了我的预计: RestFilter 接口直接被干掉了;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A filter allowing to filter rest operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFilter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process the rest request. Using the channel to send a response, or the filter chain to continue processing the request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(RestRequest request, RestChannel channel, RestFilterChain filterChain)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原本在 2.4.2 版本中, RestFilter 是该插件的核心组件, 所有的请求都经过该过滤器, 由其中的逻辑判断是否具有访问权限; 现在该类被干掉, 我又搜不到其他类似 filter 的代替者, 这就没法操作了;<br>经过一段时间的努力, 我终于在 google 和 github 的帮助下找到了解决该问题的线索, 6.2 版本其实是提供了一个类似的 api 的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public interface ActionPlugin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a function used to wrap each rest request before handling the request.</span></span><br><span class="line"><span class="comment"> * Note: Only one installed plugin may implement a rest wrapper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> UnaryOperator&lt;RestHandler&gt; <span class="title">getRestHandlerWrapper</span><span class="params">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让插件的 main class 继承此接口, 使用 lambda 表达式十分简洁地解决问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class ElasticfencePlugin extends Plugin implements ActionPlugin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UnaryOperator&lt;RestHandler&gt; <span class="title">getRestHandlerWrapper</span><span class="params">(ThreadContext threadContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPluginDisabled()) &#123;</span><br><span class="line">        <span class="comment">// 透传请求</span></span><br><span class="line">        <span class="keyword">return</span> (originRestHandler) -&gt; authRestFilter.wrapNone(originRestHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 权限控制</span></span><br><span class="line">        <span class="keyword">return</span> (originRestHandler) -&gt; authRestFilter.wrap(originRestHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本以为搞定了 api 就万事大吉了, 然后就遇到了第二道困难: java security manager;<br>换句话说, 就是基于安全考虑, 默认情况下不允许插件往任何磁盘路径写入东西, 大部分磁盘路径的内容不允许读取, 不允许发起 http 请求或 socket 连接, 不允许使用反射或者 Unsafe 类; 还有其他无数的动作限制…… 要想使用, 就必须申请权限!<br>当前版本的 elasticfence 由于使用了 qconfig, 所以首先需要引入公司的 common 客户端以初始化标准 web 应用, 期间需要申请磁盘路径读写权限以及一些系统变量的读写权限; qconfig-client 本身也有定时任务发起 http 请求, 所以还需要申请 http 资源的请求权限;<br>然而实际上, 申请权限却不是那么顺利: 我按照官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions" target="_blank" rel="noopener">Help for plugin authors</a> 的步骤申请了对应的权限, 重启节点, 发现无济于事: 该被禁止的依然被禁止; 我对 java security manager 的机制不熟悉, google 求助但所获甚少, 按正常的思路似乎遇到了阻碍;<br>&nbsp;<br>根据官方的描述, 从 6.x 开始, security manager 已无法被 disable, 要想在当前版本里 run 起来, 安全机制就是绕不开的问题; 听起来似乎已经绝了, 遂内心生发出一个狠想法: 去改 elasticsearch 源码, 把 security manager 相关代码全部注释掉, 然后重新编译, 堂而皇之, 若无其事!<br>想了下我们确实没有代码行为方面的安全需求, 这个 security manager 对我们而言其实是可有可无, 现在它阻碍了其他对我们很有必要的东西, 那么它就是可无的;<br>不过 elasticsearch 可不是一般的 java 项目, 其体系之复杂, 依赖之错综, 让人望而生畏; 小心翼翼得 pull 下来最新的代码, checkout 到目标 tag v6.2.2, 然后傻了: gradle 下载不了任何依赖, 代码全是红色的一片;<br>在网上搜了一阵子, 按部就班地操作, 还算顺利, 总算在 Intellij IDEA 里将项目正常加载起来了; 不得不感叹, 关于 elasticsearch 6.x, 即便是本地 IDE 的环境问题, 也值得写一篇文章好好总结一下;<br>源码中与 java security manager 相关的代码主要有以下几个地方:<br>首先是 elasticsearch 的主方法( elasticsearch 启动后执行的第一个逻辑便是设置 security manager):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.Elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// we want the JVM to think there is a security manager installed so that if internal policy </span></span><br><span class="line">    <span class="comment">// decisions that would be based on the presence of a security manager</span></span><br><span class="line">    <span class="comment">// or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> SecurityManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    LogConfigurator.registerErrorListener();</span><br><span class="line">    <span class="keyword">final</span> Elasticsearch elasticsearch = <span class="keyword">new</span> Elasticsearch();</span><br><span class="line">    <span class="keyword">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (status != ExitCodes.OK) &#123;</span><br><span class="line">        exit(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着是 Bootstrap 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.Bootstrap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">boolean</span> addShutdownHook, Environment environment)</span> <span class="keyword">throws</span> BootstrapException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// install SM after natives, shutdown hooks, etc.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是 BootstrapChecks 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.elasticsearch.bootstrap.BootstrapChecks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the list of checks to execute</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;BootstrapCheck&gt; <span class="title">checks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;BootstrapCheck&gt; checks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ......</span><br><span class="line">    checks.add(<span class="keyword">new</span> AllPermissionCheck());</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(checks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AllPermissionCheck</span> <span class="keyword">implements</span> <span class="title">BootstrapCheck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BootstrapCheckResult <span class="title">check</span><span class="params">(BootstrapContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAllPermissionGranted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> BootstrapCheck.BootstrapCheckResult.failure(<span class="string">"granting the all permission effectively disables security"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BootstrapCheckResult.success();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAllPermissionGranted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">assert</span> sm != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> AllPermission());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与 java security manager 相关的代码就在以上三个类中了; 可以发现它们都在 org.elasticsearch.bootstrap 包中;<br>重新编译后, 使用新处理过的 elasticsearch, 重启节点, 加载插件, 完美启动;</p>
<p><strong>(2) elasticsearch-analysis-ik</strong><br>这个插件没的说, 作为唯一一个在 elastic 公司任职的中国人, <a href="https://github.com/medcl" target="_blank" rel="noopener">medcl</a> 一定会在新版本发布第一时间更新 <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">elasticsearch-analysis-ik</a>, 与公司共进退;<br>安装了最新的 6.2.2 版本的 elasticsearch-analysis-ik, 重启节点, 加载插件, 完美运行;</p>
<p><strong>(3) 其余插件</strong><br>在 2.4.2 中, 还有两个使用到的插件, marvel 和 licence; 在 6.x 中, 这些插件已经被 x-pack 取代了, 下一节将会介绍, 此处不再赘述;</p>
<h2 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a><strong>监控体系</strong></h2><h3 id="基于-rest-api-graphite-grafana-的方案"><a href="#基于-rest-api-graphite-grafana-的方案" class="headerlink" title="基于 rest api + graphite + grafana 的方案"></a><strong>基于 rest api + graphite + grafana 的方案</strong></h3><p>基于 elasticsearch 的 rest api, 我们可以使用脚本定时收集到集群内各种状态的指标; 使用 graphite 收集 elasticsearch 汇报的指标, 并以 grafana 作为前端展示; 使用以上开源框架自建的监控系统, 已经成为我们最监控 elasticsearch 集群健康状况的主力工具;<br>将收集指标的脚本部署到 elasticsearch 6.x 测试节点, 发现一些 rest api 有了变化:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.4.2 的 _stats api 可以加一个不痛不痒的 all 参数</span></span><br><span class="line">_nodes/stats?all=<span class="literal">true</span></span><br><span class="line">_stats?all=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>all 参数在 6.x 中已经不支持了, 不过这是个不痛不痒的参数, 加与不加对结果的输出似没有任何影响;<br>其余的 api 都没有什么变化, 测试比较顺利; </p>
<h3 id="elastic-官方组件-x-pack"><a href="#elastic-官方组件-x-pack" class="headerlink" title="elastic 官方组件 x-pack"></a><strong>elastic 官方组件 x-pack</strong></h3><p>在 x-pack 诞生之前, elastic 官方提供了如下几个辅助工具: kibana, shield, marvel, watcher, 分别用于数据可视化, 权限控制, 性能监控和系统报警; 功能很强大, 可惜除了基础功能外, 进阶功能都要收费;<br>从 elasticsearch 5.0 开始, 这些独立的工具被 elastic 公司打成了一个包: x-pack, 同时在原有的基础之上, 又进一步提供了机器学习, 可视化性能诊断 (visual search profiler) 等其他特性, 并以 kibana 为呈现这些功能的载体; 只不过, 收费的功能还是一个都没少:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-fee.png" alt="x-pack-fee-table" title="">
                </div>
                <div class="image-caption">x-pack-fee-table</div>
            </figure><br>对我们来说, 之前我们主要使用到的是 marvel, 用于观察索引分片转移的源目节点与复制进度 (shard activity), 偶尔也会用于辅助自建的监控系统, 观察一些请求的 qps 和 latency;<br>我分别在 elasticsearch node 与 kibana 上安装了 x-pack 套件, 剔除了需要付费的 security, watcher, ml, graph 模块;<br>可以看到, monitoring 部分相比以前的 marvel, 总体结构上没有太大变化:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-monitor.png" alt="x-pack-monitor" title="">
                </div>
                <div class="image-caption">x-pack-monitor</div>
            </figure><br>另外, 在 x-pack 免费的功能里, 还有一个比较实用的工具: dev-tools; 这里面有两个子栏目: search profiler 和 grok debugger; 其中, search profiler 在之前的 search api 基础上实现了可视化的诊断, 相比之前在 response json 字符串里面分析查询性能瓶颈, 这样的工具带来了巨大的直观性:<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/zshell-zhang/static-content/master/cs/elasticsearch/elasticsearch_6.2_升级调研纪实/x-pack-search-profiler.png" alt="x-pack-search-profiler" title="">
                </div>
                <div class="image-caption">x-pack-search-profiler</div>
            </figure><br>除了以上免费功能, kibana 本身还有最基础的 Discover 和 Visualize 数据可视化功能, 只不过各业务线都习惯于使用 head 工具来访问线上数据, 并且 kibana 的该部分功能较之以前无显著变化, 此处便不再详述;<br>以上便是 elasticsearch 6.x 下 x-pack 最常见的使用情况;</p>
<h2 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a><strong>本文总结</strong></h2><p>本文主要讨论当前生产环境下从 elasticsearch 2.4.2 升级成 6.2.2 的可行性与兼容性问题;<br><strong>首先是客户端兼容性问题:</strong><br>elastic 公司新推出的 <code>RestHighLevelClient</code> 从 http 层面最大限度得屏蔽了各版本间的差异, 使得跨版本调用成为了可能; 使用 6.2.2 的 <code>RestHighLevelClient</code> 可以正常访问 2.4.2 的集群, 这为集群升级带来了便利;<br><strong>其次是语法兼容性问题:</strong><br>此处仍需细分为三个方面: <strong>create index</strong>, <strong>query dsl</strong> 和 <strong>search api</strong> ;<br><strong>create index</strong> 方面, 其他的零碎变化都显得不痛不痒, 对我们的影响微乎其微, 唯一一个显著的大改变就是废弃了 <code>string</code> 类型, 改而细分出两个司职更明确的类型: <code>text</code> 与 <code>keyword</code>, 分别对应于分词和不分词的情形; 这个大改变需要我们对现有所有的索引作一次大整改;<br><strong>query dsl</strong> 方面, 对我们的影响也在控制范围之内: 只有 <code>missing</code> 语句被废弃需要业务线作一定的修改, 其他的大多可以由 es-adapter 代理兼容;<br><strong>search api</strong> 方面, 可能影响就比较大了: <code>scan</code> 和 <code>count</code> 两种 search type 被废弃, 并在 es-adapter 糟糕的设计之下, 影响被放大, 需要麻烦各业务线配合修改;<br><strong>然后是索引数据迁移兼容性问题:</strong><br>经过多方测试, 发现只有两种方法可以在我们这种跨两个 major 版本的情况下迁移索引数据: reindex 模块和 es-spark 工具; 好在这两种方法 (由其是后者) 之前就是我们主要的索引迁移工具;<br><strong>接着是工具兼容性问题:</strong><br>经过不断探索与变通, 最后 <code>cerebro</code>, <code>elasticsearch-head</code>, <code>elasticfence</code>, <code>elasticsearch-analysis-ik</code>, <code>curator</code> 等一系列原有生产环境下的 elasticsearch 工具 (插件) 都 “顺利” 实现了对 6.2.2 版本的兼容;<br><strong>最后是监控体系兼容性问题:</strong><br>得益于 6.x 版本 rest api 对先前的延续, 之前生产环境使用的基于一系列开源方案的自建监控系统, 在 6.x 下依然做到了正常运转;<br>另外, 从 5.0 开始横空出世的 x-pack, 也在本次调研中被部署测试; 其中 monitoring, search-profiler 等功能都展示出了其实用的价值;</p>
<p>&nbsp;<br><strong>以上便是本文的全部内容;</strong></p>
<h2 id="站内相关文章"><a href="#站内相关文章" class="headerlink" title="站内相关文章"></a><strong>站内相关文章</strong></h2><ul>
<li><a href="">apache httpclient 初始化参数设置总结</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><ul>
<li><a href="https://github.com/elastic/elasticsearch-dsl-py/blob/master/Changelog.rst" target="_blank" rel="noopener">Changelog</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/removal-of-types.html" target="_blank" rel="noopener">Removal of mapping types</a></li>
<li><a href="https://www.elastic.co/blog/strict-content-type-checking-for-elasticsearch-rest-requests" target="_blank" rel="noopener">Strict Content-Type Checking for Elasticsearch REST Requests</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.2/java-rest-high-compatibility.html" target="_blank" rel="noopener">Compatibility</a></li>
<li><a href="https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients" target="_blank" rel="noopener">State of the official Elasticsearch Java clients</a></li>
<li><a href="http://blog.csdn.net/napoay/article/details/79135136" target="_blank" rel="noopener">Elasticsearch 6 新特性与重要变更解读</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.2/plugin-authors.html#_java_security_permissions" target="_blank" rel="noopener">Help for plugin authors</a></li>
<li><a href="https://elasticsearch.cn/article/338" target="_blank" rel="noopener">Intellij Idea 编译 Elasticsearch 源码</a></li>
<li><a href="https://github.com/elastic/elasticsearch#building-from-source" target="_blank" rel="noopener">elasticsearch: Building from Source</a></li>
<li><a href="https://www.elastic.co/blog/elasticsearch-sequence-ids-6-0" target="_blank" rel="noopener">Sequence IDs: Coming Soon to an Elasticsearch Cluster Near You</a></li>
<li><a href="https://www.cnblogs.com/Leo_wl/p/6181563.html" target="_blank" rel="noopener">Kibana+X-Pack</a></li>
<li><a href="https://www.elastic.co/subscriptions" target="_blank" rel="noopener">Subscriptions that Go to Work for You</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        <strong>本文链接:</strong> <a href="/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/" rel="external">https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告</a> <br/> 感谢您的阅读与支持！
        
    </div>
    
    <footer>
        <a href="https://zshell-zhang.github.io">
            <img src="https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" alt="zshell.zhang">
            zshell.zhang
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&title=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&pic=https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&title=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&source=
关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&via=https://zshell-zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/04/06/linux-disk--chattr_lsattr使用总结/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">chattr / lsattr 使用总结</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/02/23/python-module--python_module_使用总结_定时调度器/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">python module 使用总结: 定时调度器</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "fMh2JHgkPnDtARiQapOg8Jrk-gzGzoHsz",
            appKey: "UPNXLDUkngDnuhfC9XQPgF6n",
            avatar: "mm",
            placeholder: "您的评论, 吾愿洗耳恭听!",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>zshell.zhang &copy; 2016 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&title=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&pic=https://avatars0.githubusercontent.com/u/8027247?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&title=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&source=
关于 elasticsearch, 吐槽最多的就是其前后版本的兼容性问题; 在任何一个上规模的系统体系里, 要将使用中的 elasticsearch 提..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《elasticsearch 6.x 升级调研报告》 — 希尔的博客&url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/&via=https://zshell-zhang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zshell-zhang.github.io/2018/03/24/elasticsearch--elasticsearch6.x升级调研报告/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJ0lEQVR42u3aQXLbMBAEQP//08o1h1CeWVBV4qZ5SjmWiEYOE8zi5yd+XhfP33+bfPbqJ+9/8/1b3r/96MHGxsZ+CPv19kmWfgXIl9tuSrLO9yvExsbG3seeLSt/ZR5XySbeEHLY2NjY/z273Y73sFko5ocibGxsbOz865KgSqIojytsbGxs7LysyUcF59+Zb+XHuzRsbGzsr2fnU9Hv//NH5tvY2NjYX8x+lc/JUaSt+89j8vIbsLGxsRex8wCYVfYnA9rZbxbrx8bGxl7BziMqr3vao0K+ce3B4/Kz2NjY2IvYd9VMbWXfVvn50SUJXWxsbOyt7DyKTsaxM1jCGEYpNjY29gr27ECSX8GZhVC7qnYLsLGxsfexzyuhkzhJAuxkPXXnhI2Njf0Q9ucC42QkkI8KhsUTNjY29iJ2e2zIRwJ5cJ6ME/IAvmzRsLGxsR/OPqmEckYShHlkng8YsLGxsTex22q+HR7MKq3Z1tQFEzY2NvYK9iw28vpp9q68Nmqj7h+5jY2Njf1w9iw2XvHzUz5tXA1bNGxsbOxF7HawOhsStN95Dv7lJ9jY2NiL2PmyWnzUZsXXbto3RlGKjY2NvYJ9PgY4GTC0g+QkzKLqChsbG3sde1bfv8onD8XkIlF+lSc6gWFjY2M/nH1SJ7VD1naQ0H5PFMnY2NjYi9j5ASOvh04u9ySD2+QaUPQPho2Njb2Cfe/otC2VZoD8ak5xZQcbGxv7sezkxXeVSu0xZrY19fAAGxsbex07KfTzmj6pmVrG7DpRcXLCxsbGfiC7/S9+vri8uD/ZyuG2YmNjY69jt6GVD4Dv2sRZsF0GMzY2NvZS9mwk0JZHeaE/i6goxrCxsbHXsfOYmS0rP07Mhgf50QgbGxt7E3s2ps2vy8wCbxao9WAAGxsbewU7f04u37QHhpP66eZNwcbGxn4Iuw2tZNHnl3tm212EJTY2NvY69rBkH6Vl8m35pufBho2NjY2dLyIvntrxwHmIYmNjY2O3pNmYYbaVeShiY2Nj72PnBVA7DMg/lQ+bbzjAYGNjYy9inwxT792yth76XOBhY2NjP4T9B1ASct7ApoQ6AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
